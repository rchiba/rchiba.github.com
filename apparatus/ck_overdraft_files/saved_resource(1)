/*! Credit Karma Offers Plugin - v1.0.1
 * 
 * Copyright (c) 2019; * Licensed */

!function(){"use strict";var o=o||{};o.EXPANDER={init:function(){o.EXPANDER.bind()},bind:function(){var e=document.querySelectorAll(".ck-offer-widget .expandable"),t=document.querySelectorAll(".ck-offer-widget .expand-control");[].forEach.call(e,function(i,e){t[e].addEventListener("click",function(e){e.preventDefault();var t=this.querySelectorAll(".det-copy-swap"),n="See"==t[0].textContent?"Hide":"See";i.classList.toggle("expand"),t[0].textContent=n,this.classList.toggle("expand"),o.IFRAME.exist()&&setTimeout(o.IFRAME.update,333)})})}},o.IFRAME={exist:function(){return 0<document.querySelectorAll("body[iframe-offer-widget]").length},update:function(){var e=document.querySelectorAll(".entry-content");0<e.length&&e[0]&&window.parent.postMessage({sentinel:"amp",type:"embed-size",height:e[0].offsetHeight},"*")}},o.EXPANDER.init(),o.IFRAME.exist()&&setTimeout(o.IFRAME.update,350)}();;
!function(t){var n={};function e(i){if(n[i])return n[i].exports;var s=n[i]={i:i,l:!1,exports:{}};return t[i].call(s.exports,s,s.exports,e),s.l=!0,s.exports}e.m=t,e.c=n,e.d=function(t,n,i){e.o(t,n)||Object.defineProperty(t,n,{enumerable:!0,get:i})},e.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},e.t=function(t,n){if(1&n&&(t=e(t)),8&n)return t;if(4&n&&"object"==typeof t&&t&&t.__esModule)return t;var i=Object.create(null);if(e.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:t}),2&n&&"string"!=typeof t)for(var s in t)e.d(i,s,function(n){return t[n]}.bind(null,s));return i},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},e.p="",e(e.s=382)}({382:function(t,n,e){"use strict";e(383),e(385),e(387),e(389),e(391),e(393),e(395),e(397)},383:function(t,n,e){e(7)(e(384))},384:function(t,n){t.exports="/**\n * Name: Accessible Modal Plugin\n * Contributors: Tim Wright (tim@10up.com, @csskarma)\n * License: MIT, https://opensource.org/licenses/MIT\n * Converted from a jQuery plugin originally written by @scottohara: https://github.com/scottaohara/accessible-components\n */\n\n( function() {\n\n\t'use strict';\n\n\t// Define global TenUp object if it doesn't exist\n\tif ( 'object' !== typeof window.TenUp ) {\n\t\twindow.TenUp = {};\n\t}\n\n\n\t// Polyfill for el.matches\n\tif (!Element.prototype.matches) {\n\t\tElement.prototype.matches =\n\t\tElement.prototype.matchesSelector ||\n\t\tElement.prototype.mozMatchesSelector ||\n\t\tElement.prototype.msMatchesSelector ||\n\t\tElement.prototype.oMatchesSelector ||\n\t\tElement.prototype.webkitMatchesSelector ||\n\t\tfunction(s) {\n\t\t\tvar matches = (this.document || this.ownerDocument).querySelectorAll(s),\n\t\t\ti = matches.length;\n\t\t\twhile (--i >= 0 && matches.item(i) !== this) {}\n\t\t\treturn i > -1;\n\t\t};\n\t}\n\n\t/*\n\t * Cross-browser way to deal with class management\n\t */\n\n\tTenUp.hasClass = function ( el, cls ) {\n\t\treturn el.className && new RegExp(\"(\\\\s|^)\" + cls + \"(\\\\s|$)\").test( el.className );\n\t};\n\n\t/*\n\t * Cross-browser way to add a class\n\t */\n\n\tTenUp.addClass = function ( el, cls ) {\n\n\t\tif ( el.classList ) {\n\t\t\tel.classList.add(cls);\n\t\t} else if (!TenUp.hasClass(el, cls)) {\n\t\t\tel.className += \" \" + cls;\n\t\t}\n\n\t};\n\n\t/*\n\t * Cross-browser way to remove a class\n\t */\n\n\tTenUp.removeClass = function ( el, cls ) {\n\t\tif ( el.classList ) {\n\t\t\tel.classList.remove( cls );\n\t\t} else if( TenUp.hasClass( el, cls ) ) {\n\t\t\tvar reg = new RegExp( '(\\\\s|^)' + cls + '(\\\\s|$)' );\n\t\t\tel.className = el.className.replace( reg, ' ' );\n\t\t}\n\t};\n\n\t// Caching and setting up some variables\n\n\tvar i;\n\n\t// use this defualt title if the attr isn't set\n\tvar safetyModalTitle  = \"Dialog Window\";\n\n\n\n\n\n\n\t// initialize all the modals\n\tTenUp.modal = function ( options, callback ) {\n\n\t\t// Define the default values\n\t\tvar defaults = {\n\t\t\t'target': '.a11y-modal'\n\t\t};\n\t\tvar defaults_count = defaults.length;\n\t\tvar opt;\n\n\t\t// Map all default settings to user defined options\n\t\tfor ( opt = 0; opt < defaults_count; opt = opt + 1) {\n\t\t\tif( typeof options[opt] === \"undefined\" ) {\n\t\t\t\toptions[opt] = defaults[opt];\n\t\t\t}\n\t\t}\n\n\t\tvar el = document.querySelector( options.target );\n\n\t\tif ( ! el ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar id = el.id;\n\t\tvar self = document.getElementById( id );\n\n\t\tvar modalTrigger = options.trigger;\n\t\tvar modal = '.a11y-modal';\n\t\tvar modalDoc = '.ck__modal';\n\t\tvar modalTitle = '[data-modal-title]';\n\t\tvar modalClose = '[data-modal-close]';\n\t\tvar bodyElements = 'a11y-hide-if-modal-open';\n\t\tvar genModalClose = document.createElement( 'button' );\n\t\tvar html = document.body;\n\t\tvar modallisting = document.querySelectorAll( modal );\n\t\tvar modallistingCount = modallisting.length;\n\n\t\t// build out the fallback button\n\t\tgenModalClose.setAttribute( 'type', 'button' );\n\t\tgenModalClose.setAttribute( 'data-modal-close', 'true' );\n\t\tTenUp.addClass( genModalClose, 'modal__outro__close' );\n\n\t\tgenModalClose.innerHTML = '<span aria-hidden=\"true\">x</span>';\n\t\t// setup modals properly\n\t\tvar setup_a11y_modal = function () {\n\n\t\t\t// setup each modal instance to have the\n\t\t\t// appropriate attributes. These attributes\n\t\t\t// are applied to what would be considered the\n\t\t\t// modal container, or 'overlay'\n\n\t\t\tvar findTitle = self.querySelector( modalTitle );\n\t\t\tvar findHeading = self.querySelector( '[data-modal-title]' );\n\t\t\tvar modalDocVar = self.querySelectorAll( modalDoc );\n\t\t\tvar modalDocVarCount = modalDocVar.length;\n\t\t\tvar modalObj;\n\t\t\tvar thisLabel;\n\t\t\tvar j;\n\n\t\t\t// first check to see what sort of dialog this should be\n\t\t\t// if a data-modal-alert attribute is set to true, then\n\t\t\t// this is meant to be an alert dialog, so set the role\n\t\t\t// to 'alertdialog'. If it's not set, it's mean to be\n\t\t\t// a normal dialog. So set the role to just 'dialog'\n\n\t\t\tif ( self.getAttribute( 'data-modal-alert' ) === 'true' ) {\n\t\t\t\tself.setAttribute( 'role', 'alertdialog' );\n\t\t\t} else {\n\t\t\t\tself.setAttribute( 'role', 'dialog' );\n\t\t\t}\n\n\t\t\t// we will need to set focus to the modal content\n\t\t\t// container for focus trapping reasons, so we\n\t\t\t// need this to have a tabindex\n\n\t\t\tself.setAttribute( 'tabindex', '-1' );\n\t\t\tself.querySelector( modalDoc ).setAttribute( 'tabindex', '-1' );\n\n\t\t\t// check to see if an aria-label was set on the modal\n\t\t\t// if not, then start running checks to apply an aria-labelledby\n\n\t\t\tif ( !self.getAttribute( 'aria-label' ) ) {\n\n\t\t\t\t// if the modal window has a child modalTitle set,\n\t\t\t\t// then add an aria-labelledby attribute to the dialog,\n\t\t\t\t// pointing to that element.\n\n\t\t\t\tif ( findTitle ) {\n\n\t\t\t\t\tthisLabel = findTitle.getAttribute( 'id' );\n\n\t\t\t\t} //if\n\n\t\t\t\t// in the event that a modalTitle wasn't manually set,\n\t\t\t\t// then we should look to see if there's a heading element\n\t\t\t\t// present at all, and then make THAT the source for the\n\t\t\t\t// aria-labelledby\n\n\t\t\t\telse if ( findHeading ) {\n\n\t\t\t\t\t// does the heading we found have an id already?\n\t\t\t\t\t// let's check\n\n\t\t\t\t\tif ( findHeading.setAttribute( 'id' ) ) {\n\n\t\t\t\t\t\tthisLabel = findHeading.setAttribute( 'id' );\n\n\t\t\t\t\t} else { // if it doesn't, then generate one\n\n\t\t\t\t\t\tthisLabel = self.setAttribute( 'id' ) + '_title';\n\n\t\t\t\t\t\tfindHeading.setAttribute( 'id', thisLabel );\n\n\t\t\t\t\t} // else\n\n\t\t\t\t} // else/if\n\n\t\t\t\tself.setAttribute( 'aria-labelledby', thisLabel );\n\n\t\t\t} // if\n\n\t\t\t// setup each modal content area (the component that\n\t\t\t// contains the actual content)\n\n\t\t\tfor ( j = 0; j < modalDocVarCount; j = j + 1 ) {\n\n\t\t\t\tmodalObj = modalDocVar[j];\n\n\t\t\t\t// important for older versions of NVDA to accurately\n\t\t\t\t// understand a modal's content\n\n\t\t\t\tmodalObj.setAttribute( 'role', 'document' );\n\n\t\t\t\t// Modals need a close button, and it should be the last\n\t\t\t\t// element in the modal.\n\n\t\t\t\t// If a modal doesn't have a close button, create it.\n\n\t\t\t\tif ( typeof modalObj.querySelector( modalClose ) === 'undefined' ) {\n\n\t\t\t\t\tif ( typeof modalObj.querySelector( '.modal__outro' ) === 'undefined' ) {\n\n\t\t\t\t\t\tmodalObj.querySelector( '.modal__outro' ).appendChild( genModalClose );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmodalObj.appendChild( genModalClose );\n\n\t\t\t\t\t} // if/else\n\n\t\t\t\t} // if\n\n\t\t\t\t// Set aria-label and control attributes to the close trigger.\n\n\t\t\t\tmodalObj.querySelector( modalClose ).setAttribute( 'aria-label', 'Close Modal' );\n\t\t\t\tmodalObj.querySelector( modalClose ).setAttribute( 'aria-controls', modalObj.parentNode.getAttribute( 'id' ) );\n\n\t\t\t} // end for loop\n\n\t\t};\n\n\t\t// setup modal triggers\n\t\t// the following applies needed aria-attributes\n\t\t// to the modal triggers, as well as doing a\n\t\t// final check to ensure that the modal window\n\t\t// has appropriate labeling\n\n\t\tvar setup_a11y_modal_triggers = function () {\n\n\t\t\tvar modalTriggerEl = document.querySelectorAll( modalTrigger );\n\t\t\tvar modalTriggerCount = modalTriggerEl.length;\n\t\t\tvar grabTarget;\n\t\t\tvar modalTarget;\n\t\t\tvar modalObj;\n\t\t\tvar m;\n\n\t\t\tfor ( m = 0; m < modalTriggerCount; m = m + 1 ) {\n\n\t\t\t\tmodalObj = modalTriggerEl[m];\n\n\t\t\t\t// if the trigger is a link, we need to give it a\n\t\t\t\t// button role.\n\n\t\t\t\tif ( modalObj.getAttribute( 'href' ) ) {\n\n\t\t\t\t\tmodalObj.setAttribute( 'role', 'button' );\n\n\t\t\t\t}\n\n\t\t\t\t// The triggers need to point to the modals they control via\n\t\t\t\t// the aria-controls attribute. So run a check to see if the\n\t\t\t\t// attribute exists on the button.\n\t\t\t\t//\n\t\t\t\t// It's likely that it WON'T exist, as the optimal method for\n\t\t\t\t// the minimum mark-up is to use a data-modal-open attribute\n\t\t\t\t// instead. The reason for this is that in situations without\n\t\t\t\t// JavaScript, we don't want partial ARIA hooks, as that can\n\t\t\t\t// create confusion for ATs that would expect certain\n\t\t\t\t// functionality that wouldn't be available due to lack of JS.\n\n\t\t\t\tif ( !modalObj.getAttribute( 'aria-controls' ) ) {\n\n\t\t\t\t\t// make sure that the trigger actually triggers something.\n\t\t\t\t\t// if it there's no data-modal-open attribute set, then\n\t\t\t\t\t// pull the target from the href\n\n\t\t\t\t\tif ( modalObj.getAttribute( 'data-modal-open' ) ) {\n\n\t\t\t\t\t\tgrabTarget = modalObj.getAttribute( 'data-modal-open' );\n\t\t\t\t\t\tmodalObj.setAttribute( 'aria-controls', grabTarget );\n\n\t\t\t\t\t}\n\t\t\t\t\t// if there's no data-modal-open, pull the target from\n\t\t\t\t\t// from the href\n\n\t\t\t\t\telse if ( modalObj.getAttribute( 'href' ) ) {\n\n\t\t\t\t\t\tgrabTarget = modalObj.getAttribute( 'href' ).split( '#' )[1];\n\t\t\t\t\t\tmodalObj.setAttribute( 'aria-controls', grabTarget );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// if neither of the above are set, then this just won't work\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// No target set. A target is set by setting the value of an aria-controls attribute, which if absent, can be generated by the trigger's href URI, or a data-modal-open attribute to the value of the modal window ID you are attempting to open.\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t} // end if aria-controls\n\n\t\t\t\t// now that the aria-controls is set, point to the modal's target\n\t\t\t\t// so we can run the next if\n\n\t\t\t\tmodalTarget = document.querySelector( '#' + modalObj.getAttribute( 'aria-controls' ) );\n\n\t\t\t\t// finally a last check to see if the trigger is meant to launch\n\t\t\t\t// an alert dialog modal. If the alertdialog role wasn't set during\n\t\t\t\t// the initial setup function, then look to see if the 'data-modal-alert'\n\t\t\t\t// attribute is present on the trigger, and if so, apply the alertdialog\n\t\t\t\t// role to the modal on trigger activation.\n\n\t\t\t\tif ( modalObj.getAttribute( 'data-modal-alert' ) === 'true' && modalTarget.getAttribute( 'role' ) !== 'alertdialog' ) {\n\t\t\t\t\tmodalTarget.setAttribute( 'role', 'alertdialog' );\n\t\t\t\t}\n\n\t\t\t} // for loop\n\t\t};\n\n\t\t// Place modal window(s) as the first child(ren)\n\t\t// of the body element so tabbing backwards can\n\t\t// move focus into the browser's address bar\n\n\t\tvar organize_dom = function () {\n\n\t\t\tvar body = document.body;\n\t\t\tvar modalEl = document.querySelectorAll( modal );\n\t\t\tvar modalElCount = modalEl.length;\n\t\t\tvar k;\n\n\t\t\t// place all the modal dialogs at the top of the DOM, as the\n\t\t\t// first children of BODY. This will allow for backwards tabbing\n\t\t\t// into the browser's address bar, where as if the modals were\n\t\t\t// not located at the top of the DOM, keyboard focus would be\n\t\t\t// completely trapped within the modal window.\n\n\t\t\tfor( k = 0; k < modalElCount; k = k + 1 ) {\n\t\t\t\tbody.insertBefore( modalEl[k], body.firstChild );\n\t\t\t}\n\n\t\t\t// for all direct children of the BODY element, add a class\n\t\t\t// to target during open/close\n\t\t\tTenUp.addClass( body.querySelector( '*:not(.a11y-modal)' ), bodyElements );\n\n\t\t};\n\n\t\tvar open_a11y_modal = function ( e ) {\n\n\t\t\t// setup vars\n\n\t\t\tvar openTarget = e.target;\n\t\t\tvar modalTarget = document.getElementById( openTarget.getAttribute( 'aria-controls' ) );\n\n\t\t\t// Check to see if the modal has either an aria-label or labelledby attribute\n\t\t\t// if not, that means that the modal didn't have a manually set aria-label,\n\t\t\t// nor does the modal have any sort of heading element to draw a title from.\n\t\t\t// In this instance, pull the safetyModalTitle var in as an aria-label\n\n\t\t\tif ( !modalTarget.getAttribute( 'aria-labelledby' ) && !modalTarget.getAttribute( 'aria-label' ) ) {\n\n\t\t\t\t// Last ditch effort to allow control over what the aria-label will be.\n\t\t\t\t// If the data-set-modal-title attribute is set to the modal trigger,\n\t\t\t\t// its value will be set as the modal's aria-label\n\n\t\t\t\tif ( openTarget.getAttribute( 'data-set-modal-title' ) ) {\n\t\t\t\t\tsafetyModalTitle = openTarget.getAttribute( 'data-set-modal-title' );\n\t\t\t\t}\n\n\t\t\t\t// set an aria-label to the modal\n\t\t\t\tmodalTarget.setAttribute( 'aria-label', safetyModalTitle );\n\n\t\t\t} // if\n\n\t\t\t// traps focus while the modal is open\n\n\t\t\ttrap_focus();\n\n\t\t\t// if modal trigger is an <a>, make sure that URI isn't\n\t\t\t// updated and more importantly that the document doesn't\n\t\t\t// auto-jump to the DOM location of the modal window.\n\n\t\t\te.preventDefault();\n\n\t\t\t// set that modal be visible, controlled by the\n\t\t\t// aria-hidden attribute and CSS\n\t\t\t// then shift focus to it\n\n\t\t\tmodalTarget.setAttribute( 'aria-hidden', 'false' );\n\n\t\t\t// add a class to the HTML, to allow for a CSS hook\n\t\t\t// to help restrict document scroll while the modal\n\t\t\t// is open\n\n\t\t\tTenUp.addClass( html, 'modal-is-open' );\n\n\t\t\t// Hide main document content from screen readers by\n\t\t\t// applying an aria-hidden attribute to all direct\n\t\t\t// siblings of the modal windows. (var bodyElements)\n\n\t\t\tdocument.querySelector( '.' + bodyElements ).setAttribute( 'aria-hidden', 'true' );\n\n\t\t\t// finally, apply focus to the newly opened modal window\n\n\t\t\tmodalTarget.querySelector( modalDoc ).focus();\n\n\t\t};\n\n\t\t// Bind to both the button click and the escape key to\n\t\t// close the modal window  but only if isModalOpen is set to true\n\n\t\tvar close_a11y_modal = function ( e ) {\n\n\t\t\te.preventDefault();\n\n\t\t\tvar returnFocus = document.querySelectorAll( '[aria-controls=\"' + self.getAttribute( 'id' ) + '\"]');\n\t\t\tvar returnFocusCount = returnFocus.length;\n\n\t\t\treturnFocus = returnFocus[returnFocusCount - 1];\n\n\t\t\tTenUp.removeClass( html, 'modal-is-open' );\n\t\t\tself.setAttribute( 'aria-hidden', 'true' );\n\n\t\t\t// remove the aria-hidden that was applied during modal open\n\n\t\t\tdocument.querySelector( '.' + bodyElements ).removeAttribute( 'aria-hidden' );\n\n\t\t\treturnFocus.focus();\n\n\t\t};\n\n\t\t// keyboard controls specific to the modal dialog windows\n\n\t\tvar keytrolls_a11y_modal_trigger = function ( e ) {\n\n\t\t\tvar keyCode = e.keyCode || e.which;\n\n\t\t\tswitch ( keyCode ) {\n\n\t\t\t\t// space & enter\n\n\t\t\t\tcase 32:\n\t\t\t\tcase 13:\n\t\t\t\t\te.stopPropagation();\n\t\t\t\t\te.target.click();\n\t\t\t\t\tbreak;\n\n\t\t\t} // switch\n\n\t\t};\n\n\t\t// trap focus within the modal window, because otherwise\n\t\t// users can tab to obscured elements, and that's just\n\t\t// bad UX.\n\n\t\tvar trap_focus = function () {\n\n\t\t\t// I'm open to better solutions for trapping focus within the modal with it's open\n\t\t\tvar all_nodes = document.querySelectorAll( \"*\" );\n\t\t\tvar trapArea = self.querySelector( modalDoc );\n\t\t\tvar nodeCount =  all_nodes.length;\n\t\t\tvar j;\n\n\n\t\t\tfor ( j = 0; j < nodeCount; j = j + 1 ) {\n\t\t\t\tall_nodes.item( j ).addEventListener( \"focus\", function( e ) {\n\n\t\t\t\t\tif ( TenUp.hasClass( html, 'modal-is-open' ) && !trapArea.contains( e.target ) ) {\n\n\t\t\t\t\t\te.stopPropagation();\n\t\t\t\t\t\ttrapArea.focus();\n\n\t\t\t\t\t}\n\t\t\t\t}, false );\n\t\t\t}\n\n\t\t}; // end trap_focus\n\n\t\t/*\n\t\t * SETUP FUNCTIONS\n\t\t */\n\n\t\torganize_dom();\n\t\tsetup_a11y_modal();\n\t\tsetup_a11y_modal_triggers();\n\n\t\t/*\n\t\t * EVENT BINDINGS\n\t\t */\n\n\t\t// close the modal is the overlay is clicked\n\n\t\tself.addEventListener( \"click\", function( e ) {\n\n\t\t\tif ( e.target === self.querySelector( modalDoc ).parentNode ) {\n\t\t\t\te.stopPropagation();\n\t\t\t\tclose_a11y_modal( e );\n\t\t\t}\n\t\t}, false );\n\n\t\t// close the modal on ESC\n\n\t\tself.addEventListener(\"keydown\", function( e ) {\n\n\t\t\tif( e.keyCode == 27 && TenUp.hasClass( html, 'modal-is-open' ) ) {\n\t\t\t\tclose_a11y_modal( e );\n\t\t\t}\n\t\t}, false);\n\n\t\t// close the modal if you click the close button\n\n\t\tself.querySelector( modalClose ).addEventListener('click', function( e ) {\n\t\t\tclose_a11y_modal( e );\n\t\t}, false );\n\n\t\t// open the modal when the trigger is clicked\n\n\t\tdocument.addEventListener( \"click\", function( e ) {\n\n\t\t\tif ( e.target.matches( modalTrigger ) ) {\n\t\t\t\te.stopPropagation();\n\t\t\t\topen_a11y_modal( e );\n\t\t\t}\n\n\t\t}, false );\n\n\t\t// making sure the modal triggers open with <enter> and <space> (making it act like a button, if it's a link)\n\n\t\tdocument.addEventListener( \"keydown\", function( e ) {\n\t\t\tif (e.target.matches( modalTrigger )) {\n\t\t\t\te.stopPropagation();\n\t\t\t\tkeytrolls_a11y_modal_trigger( e );\n\t\t\t}\n\t\t}, false );\n\n\t\t// accept callback functions, because why not?\n\n\t\tif ( typeof callback === 'function' ) {\n\t\t\tcallback.call();\n\t\t}\n\n\t}; // end: a11y_modal: function\n\n} )();"},385:function(t,n,e){e(7)(e(386))},386:function(t,n){t.exports="/*\n * ScrollToFixed\n * https://github.com/bigspotteddog/ScrollToFixed\n *\n * Copyright (c) 2011 Joseph Cava-Lynch\n * MIT license\n */\n(function($) {\n    $.isScrollToFixed = function(el) {\n        return !!$(el).data('ScrollToFixed');\n    };\n\n    $.ScrollToFixed = function(el, options) {\n        // To avoid scope issues, use 'base' instead of 'this' to reference this\n        // class from internal events and functions.\n        var base = this;\n\n        // Access to jQuery and DOM versions of element.\n        base.$el = $(el);\n        base.el = el;\n\n        // Add a reverse reference to the DOM object.\n        base.$el.data('ScrollToFixed', base);\n\n        // A flag so we know if the scroll has been reset.\n        var isReset = false;\n\n        // The element that was given to us to fix if scrolled above the top of\n        // the page.\n        var target = base.$el;\n\n        var position;\n        var originalPosition;\n        var originalFloat;\n        var originalOffsetTop;\n        var originalZIndex;\n\n        // The offset top of the element when resetScroll was called. This is\n        // used to determine if we have scrolled past the top of the element.\n        var offsetTop = 0;\n\n        // The offset left of the element when resetScroll was called. This is\n        // used to move the element left or right relative to the horizontal\n        // scroll.\n        var offsetLeft = 0;\n        var originalOffsetLeft = -1;\n\n        // This last offset used to move the element horizontally. This is used\n        // to determine if we need to move the element because we would not want\n        // to do that for no reason.\n        var lastOffsetLeft = -1;\n\n        // This is the element used to fill the void left by the target element\n        // when it goes fixed; otherwise, everything below it moves up the page.\n        var spacer = null;\n\n        var spacerClass;\n\n        var className;\n\n        // Capture the original offsets for the target element. This needs to be\n        // called whenever the page size changes or when the page is first\n        // scrolled. For some reason, calling this before the page is first\n        // scrolled causes the element to become fixed too late.\n        function resetScroll() {\n            // Set the element to it original positioning.\n            target.trigger('preUnfixed.ScrollToFixed');\n            setUnfixed();\n            target.trigger('unfixed.ScrollToFixed');\n\n            // Reset the last offset used to determine if the page has moved\n            // horizontally.\n            lastOffsetLeft = -1;\n\n            // Capture the offset top of the target element.\n            offsetTop = target.offset().top;\n\n            // Capture the offset left of the target element.\n            offsetLeft = target.offset().left;\n\n            // If the offsets option is on, alter the left offset.\n            if (base.options.offsets) {\n                offsetLeft += (target.offset().left - target.position().left);\n            }\n\n            if (originalOffsetLeft == -1) {\n                originalOffsetLeft = offsetLeft;\n            }\n\n            position = target.css('position');\n\n            // Set that this has been called at least once.\n            isReset = true;\n\n            if (base.options.bottom != -1) {\n                target.trigger('preFixed.ScrollToFixed');\n                setFixed();\n                target.trigger('fixed.ScrollToFixed');\n            }\n        }\n\n        function getLimit() {\n            var limit = base.options.limit;\n            if (!limit) return 0;\n\n            if (typeof(limit) === 'function') {\n                return limit.apply(target);\n            }\n            return limit;\n        }\n\n        // Returns whether the target element is fixed or not.\n        function isFixed() {\n            return position === 'fixed';\n        }\n\n        // Returns whether the target element is absolute or not.\n        function isAbsolute() {\n            return position === 'absolute';\n        }\n\n        function isUnfixed() {\n            return !(isFixed() || isAbsolute());\n        }\n\n        // Sets the target element to fixed. Also, sets the spacer to fill the\n        // void left by the target element.\n        function setFixed() {\n            // Only fix the target element and the spacer if we need to.\n            if (!isFixed()) {\n                //get REAL dimensions (decimal fix)\n                //Ref. http://stackoverflow.com/questions/3603065/how-to-make-jquery-to-not-round-value-returned-by-width\n                var dimensions = target[0].getBoundingClientRect();\n\n                // Set the spacer to fill the height and width of the target\n                // element, then display it.\n                spacer.css({\n                    'display' : target.css('display'),\n                    'width' : dimensions.width,\n                    'height' : dimensions.height,\n                    'float' : target.css('float')\n                });\n\n                // Set the target element to fixed and set its width so it does\n                // not fill the rest of the page horizontally. Also, set its top\n                // to the margin top specified in the options.\n\n                cssOptions={\n                    'z-index' : base.options.zIndex,\n                    'position' : 'fixed',\n                    'top' : base.options.bottom == -1?getMarginTop():'',\n                    'bottom' : base.options.bottom == -1?'':base.options.bottom,\n                    'margin-left' : '0px'\n                }\n                if (!base.options.dontSetWidth){ cssOptions['width']=target.css('width'); };\n\n                target.css(cssOptions);\n\n                target.addClass(base.options.baseClassName);\n\n                if (base.options.className) {\n                    target.addClass(base.options.className);\n                }\n\n                position = 'fixed';\n            }\n        }\n\n        function setAbsolute() {\n\n            var top = getLimit();\n            var left = offsetLeft;\n\n            if (base.options.removeOffsets) {\n                left = '';\n                top = top - offsetTop;\n            }\n\n            cssOptions={\n              'position' : 'absolute',\n              'top' : top,\n              'left' : left,\n              'margin-left' : '0px',\n              'bottom' : ''\n            }\n            if (!base.options.dontSetWidth){ cssOptions['width']=target.css('width'); };\n\n            target.css(cssOptions);\n\n            position = 'absolute';\n        }\n\n        // Sets the target element back to unfixed. Also, hides the spacer.\n        function setUnfixed() {\n            // Only unfix the target element and the spacer if we need to.\n            if (!isUnfixed()) {\n                lastOffsetLeft = -1;\n\n                // Hide the spacer now that the target element will fill the\n                // space.\n                spacer.css('display', 'none');\n\n                // Remove the style attributes that were added to the target.\n                // This will reverse the target back to the its original style.\n                target.css({\n                    'z-index' : originalZIndex,\n                    'width' : '',\n                    'position' : originalPosition,\n                    'left' : '',\n                    'top' : originalOffsetTop,\n                    'margin-left' : ''\n                });\n\n                target.removeClass('scroll-to-fixed-fixed');\n\n                if (base.options.className) {\n                    target.removeClass(base.options.className);\n                }\n\n                position = null;\n            }\n        }\n\n        // Moves the target element left or right relative to the horizontal\n        // scroll position.\n        function setLeft(x) {\n            // Only if the scroll is not what it was last time we did this.\n            if (x != lastOffsetLeft) {\n                // Move the target element horizontally relative to its original\n                // horizontal position.\n                target.css('left', offsetLeft - x);\n\n                // Hold the last horizontal position set.\n                lastOffsetLeft = x;\n            }\n        }\n\n        function getMarginTop() {\n            var marginTop = base.options.marginTop;\n            if (!marginTop) return 0;\n\n            if (typeof(marginTop) === 'function') {\n                return marginTop.apply(target);\n            }\n            return marginTop;\n        }\n\n        // Checks to see if we need to do something based on new scroll position\n        // of the page.\n        function checkScroll() {\n            if (!$.isScrollToFixed(target) || target.is(':hidden')) return;\n            var wasReset = isReset;\n            var wasUnfixed = isUnfixed();\n\n            // If resetScroll has not yet been called, call it. This only\n            // happens once.\n            if (!isReset) {\n                resetScroll();\n            } else if (isUnfixed()) {\n                // if the offset has changed since the last scroll,\n                // we need to get it again.\n\n                // Capture the offset top of the target element.\n                offsetTop = target.offset().top;\n\n                // Capture the offset left of the target element.\n                offsetLeft = target.offset().left;\n            }\n\n            // Grab the current horizontal scroll position.\n            var x = $(window).scrollLeft();\n\n            // Grab the current vertical scroll position.\n            var y = $(window).scrollTop();\n\n            // Get the limit, if there is one.\n            var limit = getLimit();\n\n            // If the vertical scroll position, plus the optional margin, would\n            // put the target element at the specified limit, set the target\n            // element to absolute.\n            if (base.options.minWidth && $(window).width() < base.options.minWidth) {\n                if (!isUnfixed() || !wasReset) {\n                    postPosition();\n                    target.trigger('preUnfixed.ScrollToFixed');\n                    setUnfixed();\n                    target.trigger('unfixed.ScrollToFixed');\n                }\n            } else if (base.options.maxWidth && $(window).width() > base.options.maxWidth) {\n                if (!isUnfixed() || !wasReset) {\n                    postPosition();\n                    target.trigger('preUnfixed.ScrollToFixed');\n                    setUnfixed();\n                    target.trigger('unfixed.ScrollToFixed');\n                }\n            } else if (base.options.bottom == -1) {\n                // If the vertical scroll position, plus the optional margin, would\n                // put the target element at the specified limit, set the target\n                // element to absolute.\n                if (limit > 0 && y >= limit - getMarginTop()) {\n                    if (!wasUnfixed && (!isAbsolute() || !wasReset)) {\n                        postPosition();\n                        target.trigger('preAbsolute.ScrollToFixed');\n                        setAbsolute();\n                        target.trigger('unfixed.ScrollToFixed');\n                    }\n                // If the vertical scroll position, plus the optional margin, would\n                // put the target element above the top of the page, set the target\n                // element to fixed.\n                } else if (y >= offsetTop - getMarginTop()) {\n                    if (!isFixed() || !wasReset) {\n                        postPosition();\n                        target.trigger('preFixed.ScrollToFixed');\n\n                        // Set the target element to fixed.\n                        setFixed();\n\n                        // Reset the last offset left because we just went fixed.\n                        lastOffsetLeft = -1;\n\n                        target.trigger('fixed.ScrollToFixed');\n                    }\n                    // If the page has been scrolled horizontally as well, move the\n                    // target element accordingly.\n                    setLeft(x);\n                } else {\n                    // Set the target element to unfixed, placing it where it was\n                    // before.\n                    if (!isUnfixed() || !wasReset) {\n                        postPosition();\n                        target.trigger('preUnfixed.ScrollToFixed');\n                        setUnfixed();\n                        target.trigger('unfixed.ScrollToFixed');\n                    }\n                }\n            } else {\n                if (limit > 0) {\n                    if (y + $(window).height() - target.outerHeight(true) >= limit - (getMarginTop() || -getBottom())) {\n                        if (isFixed()) {\n                            postPosition();\n                            target.trigger('preUnfixed.ScrollToFixed');\n\n                            if (originalPosition === 'absolute') {\n                                setAbsolute();\n                            } else {\n                                setUnfixed();\n                            }\n\n                            target.trigger('unfixed.ScrollToFixed');\n                        }\n                    } else {\n                        if (!isFixed()) {\n                            postPosition();\n                            target.trigger('preFixed.ScrollToFixed');\n                            setFixed();\n                        }\n                        setLeft(x);\n                        target.trigger('fixed.ScrollToFixed');\n                    }\n                } else {\n                    setLeft(x);\n                }\n            }\n        }\n\n        function getBottom() {\n            if (!base.options.bottom) return 0;\n            return base.options.bottom;\n        }\n\n        function postPosition() {\n            var position = target.css('position');\n\n            if (position == 'absolute') {\n                target.trigger('postAbsolute.ScrollToFixed');\n            } else if (position == 'fixed') {\n                target.trigger('postFixed.ScrollToFixed');\n            } else {\n                target.trigger('postUnfixed.ScrollToFixed');\n            }\n        }\n\n        var windowResize = function(event) {\n            // Check if the element is visible before updating it's position, which\n            // improves behavior with responsive designs where this element is hidden.\n            if(target.is(':visible')) {\n                isReset = false;\n                checkScroll();\n            } else {\n              // Ensure the spacer is hidden\n              setUnfixed();\n            }\n        }\n\n        var windowScroll = function(event) {\n            (!!window.requestAnimationFrame) ? requestAnimationFrame(checkScroll) : checkScroll();\n        }\n\n        // From: http://kangax.github.com/cft/#IS_POSITION_FIXED_SUPPORTED\n        var isPositionFixedSupported = function() {\n            var container = document.body;\n\n            if (document.createElement && container && container.appendChild && container.removeChild) {\n                var el = document.createElement('div');\n\n                if (!el.getBoundingClientRect) return null;\n\n                el.innerHTML = 'x';\n                el.style.cssText = 'position:fixed;top:100px;';\n                container.appendChild(el);\n\n                var originalHeight = container.style.height,\n                originalScrollTop = container.scrollTop;\n\n                container.style.height = '3000px';\n                container.scrollTop = 500;\n\n                var elementTop = el.getBoundingClientRect().top;\n                container.style.height = originalHeight;\n\n                var isSupported = (elementTop === 100);\n                container.removeChild(el);\n                container.scrollTop = originalScrollTop;\n\n                return isSupported;\n            }\n\n            return null;\n        }\n\n        var preventDefault = function(e) {\n            e = e || window.event;\n            if (e.preventDefault) {\n                e.preventDefault();\n            }\n            e.returnValue = false;\n        }\n\n        // Initializes this plugin. Captures the options passed in, turns this\n        // off for devices that do not support fixed position, adds the spacer,\n        // and binds to the window scroll and resize events.\n        base.init = function() {\n            // Capture the options for this plugin.\n            base.options = $.extend({}, $.ScrollToFixed.defaultOptions, options);\n\n            originalZIndex = target.css('z-index')\n\n            // Turn off this functionality for devices that do not support it.\n            // if (!(base.options && base.options.dontCheckForPositionFixedSupport)) {\n            //     var fixedSupported = isPositionFixedSupported();\n            //     if (!fixedSupported) return;\n            // }\n\n            // Put the target element on top of everything that could be below\n            // it. This reduces flicker when the target element is transitioning\n            // to fixed.\n            base.$el.css('z-index', base.options.zIndex);\n\n            // Create a spacer element to fill the void left by the target\n            // element when it goes fixed.\n            spacer = $('<div />');\n\n            position = target.css('position');\n            originalPosition = target.css('position');\n            originalFloat = target.css('float');\n            originalOffsetTop = target.css('top');\n\n            // Place the spacer right after the target element.\n            if (isUnfixed()) base.$el.after(spacer);\n\n            // Reset the target element offsets when the window is resized, then\n            // check to see if we need to fix or unfix the target element.\n            $(window).bind('resize.ScrollToFixed', windowResize);\n\n            // When the window scrolls, check to see if we need to fix or unfix\n            // the target element.\n            $(window).bind('scroll.ScrollToFixed', windowScroll);\n\n            // For touch devices, call checkScroll directlly rather than\n            // rAF wrapped windowScroll to animate the element\n            if ('ontouchmove' in window) {\n              $(window).bind('touchmove.ScrollToFixed', checkScroll);\n            }\n\n            if (base.options.preFixed) {\n                target.bind('preFixed.ScrollToFixed', base.options.preFixed);\n            }\n            if (base.options.postFixed) {\n                target.bind('postFixed.ScrollToFixed', base.options.postFixed);\n            }\n            if (base.options.preUnfixed) {\n                target.bind('preUnfixed.ScrollToFixed', base.options.preUnfixed);\n            }\n            if (base.options.postUnfixed) {\n                target.bind('postUnfixed.ScrollToFixed', base.options.postUnfixed);\n            }\n            if (base.options.preAbsolute) {\n                target.bind('preAbsolute.ScrollToFixed', base.options.preAbsolute);\n            }\n            if (base.options.postAbsolute) {\n                target.bind('postAbsolute.ScrollToFixed', base.options.postAbsolute);\n            }\n            if (base.options.fixed) {\n                target.bind('fixed.ScrollToFixed', base.options.fixed);\n            }\n            if (base.options.unfixed) {\n                target.bind('unfixed.ScrollToFixed', base.options.unfixed);\n            }\n\n            if (base.options.spacerClass) {\n                spacer.addClass(base.options.spacerClass);\n            }\n\n            target.bind('resize.ScrollToFixed', function() {\n                spacer.height(target.height());\n            });\n\n            target.bind('scroll.ScrollToFixed', function() {\n                target.trigger('preUnfixed.ScrollToFixed');\n                setUnfixed();\n                target.trigger('unfixed.ScrollToFixed');\n                checkScroll();\n            });\n\n            target.bind('detach.ScrollToFixed', function(ev) {\n                preventDefault(ev);\n\n                target.trigger('preUnfixed.ScrollToFixed');\n                setUnfixed();\n                target.trigger('unfixed.ScrollToFixed');\n\n                $(window).unbind('resize.ScrollToFixed', windowResize);\n                $(window).unbind('scroll.ScrollToFixed', windowScroll);\n\n                target.unbind('.ScrollToFixed');\n\n                //remove spacer from dom\n                spacer.remove();\n\n                base.$el.removeData('ScrollToFixed');\n            });\n\n            // Reset everything.\n            windowResize();\n        };\n\n        // Initialize the plugin.\n        base.init();\n    };\n\n    // Sets the option defaults.\n    $.ScrollToFixed.defaultOptions = {\n        marginTop : 0,\n        limit : 0,\n        bottom : -1,\n        zIndex : 1000,\n        baseClassName: 'scroll-to-fixed-fixed'\n    };\n\n    // Returns enhanced elements that will fix to the top of the page when the\n    // page is scrolled.\n    $.fn.scrollToFixed = function(options) {\n        return this.each(function() {\n            (new $.ScrollToFixed(this, options));\n        });\n    };\n})(jQuery);\n"},387:function(t,n,e){e(7)(e(388))},388:function(t,n){t.exports='/*! picturefill - v3.0.2 - 2016-02-12\n * https://scottjehl.github.io/picturefill/\n * Copyright (c) 2016 https://github.com/scottjehl/picturefill/blob/master/Authors.txt; Licensed MIT\n */\n!function(a){var b=navigator.userAgent;a.HTMLPictureElement&&/ecko/.test(b)&&b.match(/rv\\:(\\d+)/)&&RegExp.$1<45&&addEventListener("resize",function(){var b,c=document.createElement("source"),d=function(a){var b,d,e=a.parentNode;"PICTURE"===e.nodeName.toUpperCase()?(b=c.cloneNode(),e.insertBefore(b,e.firstElementChild),setTimeout(function(){e.removeChild(b)})):(!a._pfLastSize||a.offsetWidth>a._pfLastSize)&&(a._pfLastSize=a.offsetWidth,d=a.sizes,a.sizes+=",100vw",setTimeout(function(){a.sizes=d}))},e=function(){var a,b=document.querySelectorAll("picture > img, img[srcset][sizes]");for(a=0;a<b.length;a++)d(b[a])},f=function(){clearTimeout(b),b=setTimeout(e,99)},g=a.matchMedia&&matchMedia("(orientation: landscape)"),h=function(){f(),g&&g.addListener&&g.addListener(f)};return c.srcset="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",/^[c|i]|d$/.test(document.readyState||"")?h():document.addEventListener("DOMContentLoaded",h),f}())}(window),function(a,b,c){"use strict";function d(a){return" "===a||"\t"===a||"\\n"===a||"\\f"===a||"\\r"===a}function e(b,c){var d=new a.Image;return d.onerror=function(){A[b]=!1,ba()},d.onload=function(){A[b]=1===d.width,ba()},d.src=c,"pending"}function f(){M=!1,P=a.devicePixelRatio,N={},O={},s.DPR=P||1,Q.width=Math.max(a.innerWidth||0,z.clientWidth),Q.height=Math.max(a.innerHeight||0,z.clientHeight),Q.vw=Q.width/100,Q.vh=Q.height/100,r=[Q.height,Q.width,P].join("-"),Q.em=s.getEmValue(),Q.rem=Q.em}function g(a,b,c,d){var e,f,g,h;return"saveData"===B.algorithm?a>2.7?h=c+1:(f=b-c,e=Math.pow(a-.6,1.5),g=f*e,d&&(g+=.1*e),h=a+g):h=c>1?Math.sqrt(a*b):a,h>c}function h(a){var b,c=s.getSet(a),d=!1;"pending"!==c&&(d=r,c&&(b=s.setRes(c),s.applySetCandidate(b,a))),a[s.ns].evaled=d}function i(a,b){return a.res-b.res}function j(a,b,c){var d;return!c&&b&&(c=a[s.ns].sets,c=c&&c[c.length-1]),d=k(b,c),d&&(b=s.makeUrl(b),a[s.ns].curSrc=b,a[s.ns].curCan=d,d.res||aa(d,d.set.sizes)),d}function k(a,b){var c,d,e;if(a&&b)for(e=s.parseSet(b),a=s.makeUrl(a),c=0;c<e.length;c++)if(a===s.makeUrl(e[c].url)){d=e[c];break}return d}function l(a,b){var c,d,e,f,g=a.getElementsByTagName("source");for(c=0,d=g.length;d>c;c++)e=g[c],e[s.ns]=!0,f=e.getAttribute("srcset"),f&&b.push({srcset:f,media:e.getAttribute("media"),type:e.getAttribute("type"),sizes:e.getAttribute("sizes")})}function m(a,b){function c(b){var c,d=b.exec(a.substring(m));return d?(c=d[0],m+=c.length,c):void 0}function e(){var a,c,d,e,f,i,j,k,l,m=!1,o={};for(e=0;e<h.length;e++)f=h[e],i=f[f.length-1],j=f.substring(0,f.length-1),k=parseInt(j,10),l=parseFloat(j),X.test(j)&&"w"===i?((a||c)&&(m=!0),0===k?m=!0:a=k):Y.test(j)&&"x"===i?((a||c||d)&&(m=!0),0>l?m=!0:c=l):X.test(j)&&"h"===i?((d||c)&&(m=!0),0===k?m=!0:d=k):m=!0;m||(o.url=g,a&&(o.w=a),c&&(o.d=c),d&&(o.h=d),d||c||a||(o.d=1),1===o.d&&(b.has1x=!0),o.set=b,n.push(o))}function f(){for(c(T),i="",j="in descriptor";;){if(k=a.charAt(m),"in descriptor"===j)if(d(k))i&&(h.push(i),i="",j="after descriptor");else{if(","===k)return m+=1,i&&h.push(i),void e();if("("===k)i+=k,j="in parens";else{if(""===k)return i&&h.push(i),void e();i+=k}}else if("in parens"===j)if(")"===k)i+=k,j="in descriptor";else{if(""===k)return h.push(i),void e();i+=k}else if("after descriptor"===j)if(d(k));else{if(""===k)return void e();j="in descriptor",m-=1}m+=1}}for(var g,h,i,j,k,l=a.length,m=0,n=[];;){if(c(U),m>=l)return n;g=c(V),h=[],","===g.slice(-1)?(g=g.replace(W,""),e()):f()}}function n(a){function b(a){function b(){f&&(g.push(f),f="")}function c(){g[0]&&(h.push(g),g=[])}for(var e,f="",g=[],h=[],i=0,j=0,k=!1;;){if(e=a.charAt(j),""===e)return b(),c(),h;if(k){if("*"===e&&"/"===a[j+1]){k=!1,j+=2,b();continue}j+=1}else{if(d(e)){if(a.charAt(j-1)&&d(a.charAt(j-1))||!f){j+=1;continue}if(0===i){b(),j+=1;continue}e=" "}else if("("===e)i+=1;else if(")"===e)i-=1;else{if(","===e){b(),c(),j+=1;continue}if("/"===e&&"*"===a.charAt(j+1)){k=!0,j+=2;continue}}f+=e,j+=1}}}function c(a){return k.test(a)&&parseFloat(a)>=0?!0:l.test(a)?!0:"0"===a||"-0"===a||"+0"===a?!0:!1}var e,f,g,h,i,j,k=/^(?:[+-]?[0-9]+|[0-9]*\\.[0-9]+)(?:[eE][+-]?[0-9]+)?(?:ch|cm|em|ex|in|mm|pc|pt|px|rem|vh|vmin|vmax|vw)$/i,l=/^calc\\((?:[0-9a-z \\.\\+\\-\\*\\/\\(\\)]+)\\)$/i;for(f=b(a),g=f.length,e=0;g>e;e++)if(h=f[e],i=h[h.length-1],c(i)){if(j=i,h.pop(),0===h.length)return j;if(h=h.join(" "),s.matchesMedia(h))return j}return"100vw"}b.createElement("picture");var o,p,q,r,s={},t=!1,u=function(){},v=b.createElement("img"),w=v.getAttribute,x=v.setAttribute,y=v.removeAttribute,z=b.documentElement,A={},B={algorithm:""},C="data-pfsrc",D=C+"set",E=navigator.userAgent,F=/rident/.test(E)||/ecko/.test(E)&&E.match(/rv\\:(\\d+)/)&&RegExp.$1>35,G="currentSrc",H=/\\s+\\+?\\d+(e\\d+)?w/,I=/(\\([^)]+\\))?\\s*(.+)/,J=a.picturefillCFG,K="position:absolute;left:0;visibility:hidden;display:block;padding:0;border:none;font-size:1em;width:1em;overflow:hidden;clip:rect(0px, 0px, 0px, 0px)",L="font-size:100%!important;",M=!0,N={},O={},P=a.devicePixelRatio,Q={px:1,"in":96},R=b.createElement("a"),S=!1,T=/^[ \\t\\n\\r\\u000c]+/,U=/^[, \\t\\n\\r\\u000c]+/,V=/^[^ \\t\\n\\r\\u000c]+/,W=/[,]+$/,X=/^\\d+$/,Y=/^-?(?:[0-9]+|[0-9]*\\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/,Z=function(a,b,c,d){a.addEventListener?a.addEventListener(b,c,d||!1):a.attachEvent&&a.attachEvent("on"+b,c)},$=function(a){var b={};return function(c){return c in b||(b[c]=a(c)),b[c]}},_=function(){var a=/^([\\d\\.]+)(em|vw|px)$/,b=function(){for(var a=arguments,b=0,c=a[0];++b in a;)c=c.replace(a[b],a[++b]);return c},c=$(function(a){return"return "+b((a||"").toLowerCase(),/\\band\\b/g,"&&",/,/g,"||",/min-([a-z-\\s]+):/g,"e.$1>=",/max-([a-z-\\s]+):/g,"e.$1<=",/calc([^)]+)/g,"($1)",/(\\d+[\\.]*[\\d]*)([a-z]+)/g,"($1 * e.$2)",/^(?!(e.[a-z]|[0-9\\.&=|><\\+\\-\\*\\(\\)\\/])).*/gi,"")+";"});return function(b,d){var e;if(!(b in N))if(N[b]=!1,d&&(e=b.match(a)))N[b]=e[1]*Q[e[2]];else try{N[b]=new Function("e",c(b))(Q)}catch(f){}return N[b]}}(),aa=function(a,b){return a.w?(a.cWidth=s.calcListLength(b||"100vw"),a.res=a.w/a.cWidth):a.res=a.d,a},ba=function(a){if(t){var c,d,e,f=a||{};if(f.elements&&1===f.elements.nodeType&&("IMG"===f.elements.nodeName.toUpperCase()?f.elements=[f.elements]:(f.context=f.elements,f.elements=null)),c=f.elements||s.qsa(f.context||b,f.reevaluate||f.reselect?s.sel:s.selShort),e=c.length){for(s.setupRun(f),S=!0,d=0;e>d;d++)s.fillImg(c[d],f);s.teardownRun(f)}}};o=a.console&&console.warn?function(a){console.warn(a)}:u,G in v||(G="src"),A["image/jpeg"]=!0,A["image/gif"]=!0,A["image/png"]=!0,A["image/svg+xml"]=b.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Image","1.1"),s.ns=("pf"+(new Date).getTime()).substr(0,9),s.supSrcset="srcset"in v,s.supSizes="sizes"in v,s.supPicture=!!a.HTMLPictureElement,s.supSrcset&&s.supPicture&&!s.supSizes&&!function(a){v.srcset="data:,a",a.src="data:,a",s.supSrcset=v.complete===a.complete,s.supPicture=s.supSrcset&&s.supPicture}(b.createElement("img")),s.supSrcset&&!s.supSizes?!function(){var a="data:image/gif;base64,R0lGODlhAgABAPAAAP///wAAACH5BAAAAAAALAAAAAACAAEAAAICBAoAOw==",c="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",d=b.createElement("img"),e=function(){var a=d.width;2===a&&(s.supSizes=!0),q=s.supSrcset&&!s.supSizes,t=!0,setTimeout(ba)};d.onload=e,d.onerror=e,d.setAttribute("sizes","9px"),d.srcset=c+" 1w,"+a+" 9w",d.src=c}():t=!0,s.selShort="picture>img,img[srcset]",s.sel=s.selShort,s.cfg=B,s.DPR=P||1,s.u=Q,s.types=A,s.setSize=u,s.makeUrl=$(function(a){return R.href=a,R.href}),s.qsa=function(a,b){return"querySelector"in a?a.querySelectorAll(b):[]},s.matchesMedia=function(){return a.matchMedia&&(matchMedia("(min-width: 0.1em)")||{}).matches?s.matchesMedia=function(a){return!a||matchMedia(a).matches}:s.matchesMedia=s.mMQ,s.matchesMedia.apply(this,arguments)},s.mMQ=function(a){return a?_(a):!0},s.calcLength=function(a){var b=_(a,!0)||!1;return 0>b&&(b=!1),b},s.supportsType=function(a){return a?A[a]:!0},s.parseSize=$(function(a){var b=(a||"").match(I);return{media:b&&b[1],length:b&&b[2]}}),s.parseSet=function(a){return a.cands||(a.cands=m(a.srcset,a)),a.cands},s.getEmValue=function(){var a;if(!p&&(a=b.body)){var c=b.createElement("div"),d=z.style.cssText,e=a.style.cssText;c.style.cssText=K,z.style.cssText=L,a.style.cssText=L,a.appendChild(c),p=c.offsetWidth,a.removeChild(c),p=parseFloat(p,10),z.style.cssText=d,a.style.cssText=e}return p||16},s.calcListLength=function(a){if(!(a in O)||B.uT){var b=s.calcLength(n(a));O[a]=b?b:Q.width}return O[a]},s.setRes=function(a){var b;if(a){b=s.parseSet(a);for(var c=0,d=b.length;d>c;c++)aa(b[c],a.sizes)}return b},s.setRes.res=aa,s.applySetCandidate=function(a,b){if(a.length){var c,d,e,f,h,k,l,m,n,o=b[s.ns],p=s.DPR;if(k=o.curSrc||b[G],l=o.curCan||j(b,k,a[0].set),l&&l.set===a[0].set&&(n=F&&!b.complete&&l.res-.1>p,n||(l.cached=!0,l.res>=p&&(h=l))),!h)for(a.sort(i),f=a.length,h=a[f-1],d=0;f>d;d++)if(c=a[d],c.res>=p){e=d-1,h=a[e]&&(n||k!==s.makeUrl(c.url))&&g(a[e].res,c.res,p,a[e].cached)?a[e]:c;break}h&&(m=s.makeUrl(h.url),o.curSrc=m,o.curCan=h,m!==k&&s.setSrc(b,h),s.setSize(b))}},s.setSrc=function(a,b){var c;a.src=b.url,"image/svg+xml"===b.set.type&&(c=a.style.width,a.style.width=a.offsetWidth+1+"px",a.offsetWidth+1&&(a.style.width=c))},s.getSet=function(a){var b,c,d,e=!1,f=a[s.ns].sets;for(b=0;b<f.length&&!e;b++)if(c=f[b],c.srcset&&s.matchesMedia(c.media)&&(d=s.supportsType(c.type))){"pending"===d&&(c=d),e=c;break}return e},s.parseSets=function(a,b,d){var e,f,g,h,i=b&&"PICTURE"===b.nodeName.toUpperCase(),j=a[s.ns];(j.src===c||d.src)&&(j.src=w.call(a,"src"),j.src?x.call(a,C,j.src):y.call(a,C)),(j.srcset===c||d.srcset||!s.supSrcset||a.srcset)&&(e=w.call(a,"srcset"),j.srcset=e,h=!0),j.sets=[],i&&(j.pic=!0,l(b,j.sets)),j.srcset?(f={srcset:j.srcset,sizes:w.call(a,"sizes")},j.sets.push(f),g=(q||j.src)&&H.test(j.srcset||""),g||!j.src||k(j.src,f)||f.has1x||(f.srcset+=", "+j.src,f.cands.push({url:j.src,d:1,set:f}))):j.src&&j.sets.push({srcset:j.src,sizes:null}),j.curCan=null,j.curSrc=c,j.supported=!(i||f&&!s.supSrcset||g&&!s.supSizes),h&&s.supSrcset&&!j.supported&&(e?(x.call(a,D,e),a.srcset=""):y.call(a,D)),j.supported&&!j.srcset&&(!j.src&&a.src||a.src!==s.makeUrl(j.src))&&(null===j.src?a.removeAttribute("src"):a.src=j.src),j.parsed=!0},s.fillImg=function(a,b){var c,d=b.reselect||b.reevaluate;a[s.ns]||(a[s.ns]={}),c=a[s.ns],(d||c.evaled!==r)&&((!c.parsed||b.reevaluate)&&s.parseSets(a,a.parentNode,b),c.supported?c.evaled=r:h(a))},s.setupRun=function(){(!S||M||P!==a.devicePixelRatio)&&f()},s.supPicture?(ba=u,s.fillImg=u):!function(){var c,d=a.attachEvent?/d$|^c/:/d$|^c|^i/,e=function(){var a=b.readyState||"";f=setTimeout(e,"loading"===a?200:999),b.body&&(s.fillImgs(),c=c||d.test(a),c&&clearTimeout(f))},f=setTimeout(e,b.body?9:99),g=function(a,b){var c,d,e=function(){var f=new Date-d;b>f?c=setTimeout(e,b-f):(c=null,a())};return function(){d=new Date,c||(c=setTimeout(e,b))}},h=z.clientHeight,i=function(){M=Math.max(a.innerWidth||0,z.clientWidth)!==Q.width||z.clientHeight!==h,h=z.clientHeight,M&&s.fillImgs()};Z(a,"resize",g(i,99)),Z(b,"readystatechange",e)}(),s.picturefill=ba,s.fillImgs=ba,s.teardownRun=u,ba._=s,a.picturefillCFG={pf:s,push:function(a){var b=a.shift();"function"==typeof s[b]?s[b].apply(s,a):(B[b]=a[0],S&&s.fillImgs({reselect:!0}))}};for(;J&&J.length;)a.picturefillCFG.push(J.shift());a.picturefill=ba,"object"==typeof module&&"object"==typeof module.exports?module.exports=ba:"function"==typeof define&&define.amd&&define("picturefill",function(){return ba}),s.supPicture||(A["image/webp"]=e("image/webp","data:image/webp;base64,UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAABBxAR/Q9ERP8DAABWUDggGAAAADABAJ0BKgEAAQADADQlpAADcAD++/1QAA=="))}(window,document);\n'},389:function(t,n,e){e(7)(e(390))},390:function(t,n){t.exports="/********************************\n\n\tName: WordPress Accessible Responsive Navigation Menu\n\tUsage:\n\n\tTenUp.build_menu({\n\n\t\t'target'\t\t:\t'#primary-nav',      // the selector of the nav menu <ul>\n\t\t'toggle'\t\t:\t'#js-menu-toggle',   // the ID of the link you're using to open/close the small screen menu\n\t\t'sub_menu_open'\t:\t'hover'              // \"click\" is the other option\n\n\t}, function() {\n\n\t\tconsole.log('Amazing callback function!');\n\n\t});\n\n********************************/\n\n( function() {\n\n\t'use strict';\n\n\t// Define global TenUp object if it doesn't exist\n\tif ( 'object' !== typeof window.TenUp ) {\n\t\twindow.TenUp = {};\n\t}\n\n\t/*\n\t\tCache and define some variables\n\t*/\n\n\t// init function\n\n\tTenUp.navigation = function( options, callback ) {\n\n\t\tvar defaults = {\n\t\t\t'target'\t\t:\t'#primary-nav',\n\t\t\t'toggle'\t\t:\t'#js-menu-toggle',\n\t\t\t'sub_menu_open'\t:\t'hover'\n\t\t};\n\t\tvar opt;\n\n\t\t// Map all default settings to user defined options if they exist\n\t\tfor ( opt = 0; opt < defaults.length; opt = opt + 1 ) {\n\n\t\t\tif( typeof options[opt] === \"undefined\" ) {\n\t\t\t\toptions[opt] = defaults[opt];\n\t\t\t}\n\n\t\t}\n\n\t\tvar menu = document.querySelector( options.target );\n\n\t\t// Bail out if there's no menu\n\t\tif( !menu ) { return; }\n\n\t\tvar menu_id = menu.getAttribute( 'id' );\n\t\tvar menu_toggle = document.querySelector( options.toggle );\n\t\tvar menu_toggle_href = menu_toggle.getAttribute( 'href' );\n\t\tvar aria_controls = menu_toggle.getAttribute('aria-controls');\n\t\tvar menu_toggle_target = menu_toggle_href.split('#')[1];\n\t\tvar sub_menu_acion = options.sub_menu_open;\n\t\tvar current_menu_item = menu.querySelector('.current-menu-item');\n\t\tvar menu_items_with_children = menu.querySelectorAll('.menu-item-has-children');\n\t\tvar menu_items_with_children_count = menu_items_with_children.length;\n\t\tvar currentTarget;\n\t\tvar target;\n\t\tvar i;\n\n\t\t// Listener for the menu open/close action\n\t\tfunction listener_menu( e ) {\n\n\t\t\t// Stop links from firing\n\t\t\te.preventDefault();\n\n\t\t\tif( document.body.classList.contains('menu-is-open') ) {\n\n\t\t\t\t// Close the menu\n\t\t\t\tmenu.setAttribute('aria-hidden', 'true');\n\t\t\t\tmenu_toggle.setAttribute('aria-expanded', 'false');\n\n\t\t\t\t// Bubble to the document\n\t\t\t\tdocument.body.classList.remove('menu-is-open');\n\n\t\t\t} else {\n\n\t\t\t\t// Open the menu\n\t\t\t\tmenu.setAttribute('aria-hidden', 'false');\n\t\t\t\tmenu_toggle.setAttribute('aria-expanded', 'true');\n\n\t\t\t\t// Set focus to the first link\n\t\t\t\tmenu.querySelectorAll('a')[0].focus();\n\n\t\t\t\t// Bubble to the document\n\t\t\t\tdocument.body.classList.add('menu-is-open');\n\n\t\t\t}\n\n\t\t}; // listener_menu()\n\n\t\t// Listener for submenu on click\n\t\tfunction listener_submenu_click( e ) {\n\n\t\t\tcurrentTarget = e.currentTarget;\n\t\t\ttarget = e.target;\n\n\t\t\tif( target.getAttribute('aria-haspopup') ) {\n\n\t\t\t\t// Stop links from firing\n\t\t\t\te.preventDefault();\n\n\t\t\t\t// Stop events from bubbling up to parent elements\n\t\t\t\te.stopPropagation();\n\n\t\t\t\tvar parent_menu = target.parentNode;\n\t\t\t\tvar sub_menu = parent_menu.querySelector('.sub-menu');\n\t\t\t\tvar all_open_menus = menu.querySelectorAll('.child-has-focus');\n\t\t\t\tvar all_open_menus_count = all_open_menus.length;\n\t\t\t\tvar all_open_menu_triggers = menu.querySelectorAll( '.child-has-focus > a.submenu-is-open' );\n\t\t\t\tvar all_open_menu_triggers_count = all_open_menu_triggers.length;\n\t\t\t\tvar t;\n\n\t\t\t\tif( get_screen_size( 'medium' ) || get_screen_size( 'large' ) ) {\n\n\t\t\t\t\tif( all_open_menu_triggers_count > 0 ) {\n\n\t\t\t\t\t\t// Make sure only 1 menu item can be opened at a time\n\t\t\t\t\t\tfor( t = 0; t < all_open_menu_triggers_count; t = t + 1 ) {\n\n\t\t\t\t\t\t\t// Check if the open menu is top-level, if so, close it\n\t\t\t\t\t\t\tif( parent_menu.parentNode === menu ) {\n\t\t\t\t\t\t\t\tmenu_sub_close( all_open_menu_triggers[t] );\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} // for\n\n\t\t\t\t\t} // if\n\n\t\t\t\t} // if\n\n\t\t\t\tif( e.target.nodeName === 'A' && target.classList.contains( 'submenu-is-open' ) ) {\n\n\t\t\t\t\t// The menu is already open, so this should be a close action\n\t\t\t\t\tmenu_sub_close( target );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// The menu is closed, so this click should open it\n\t\t\t\t\tmenu_sub_open( target );\n\n\t\t\t\t\t// Reset the focus\n\t\t\t\t\tsub_menu.querySelectorAll('a')[0].focus();\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t}; // listener_submenu_click()\n\n\t\t// When \"hover\", this is how focus should act\n\t\tfunction listener_submenu_focus( e ) {\n\n\t\t\tvar currentTarget = e.currentTarget;\n\t\t\tvar target = e.target;\n\t\t\tvar parent_menu = target.parentNode;\n\t\t\tvar sub_menu = parent_menu.querySelector('.sub-menu');\n\t\t\tvar all_open_menu_triggers = menu.querySelectorAll( '.child-has-focus > a.submenu-is-open' );\n\t\t\tvar all_open_menu_triggers_count = all_open_menu_triggers.length;\n\t\t\tvar t;\n\n\t\t\tif( get_screen_size( 'medium' ) || get_screen_size( 'large' ) ) {\n\n\t\t\t\tif( all_open_menu_triggers_count > 0 ) {\n\n\t\t\t\t\t// Make sure only 1 menu item can be opened at a time\n\t\t\t\t\tfor( t = 0; t < all_open_menu_triggers_count; t = t + 1 ) {\n\n\t\t\t\t\t\t// Check if the open menu is top-level, if so, close it\n\t\t\t\t\t\tif( parent_menu.parentNode === menu ) {\n\t\t\t\t\t\t\tmenu_sub_close( all_open_menu_triggers[t] );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tmenu_sub_open( target );\n\n\t\t};\n\n\t\t// Listener for the window resize\n\t\tvar listener_window = debounce( function( e ) {\n\n\t\t\tif( get_screen_size( 'small' ) ) {\n\n\t\t\t\tmenu_create();\n\n\t\t\t} else {\n\n\t\t\t\tmenu_destroy();\n\n\t\t\t}\n\n\t\t}, 100 ); // listener_window()\n\n\t\t// Close the menu if you click somewhere else\n\t\tfunction listener_close_open_menus( e ) {\n\n\t\t\tvar open_menus = menu.querySelectorAll('.submenu-is-open');\n\t\t\tvar open_menus_count = open_menus.length;\n\t\t\tvar opn;\n\n\t\t\t// if the event is keyup and it was the ESC key\n\t\t\tif( e.type === 'keyup' && e.keyCode == 27 ) {\n\n\t\t\t\t// We were getting some errors, so let's add in a checkpoint\n\t\t\t\tif ( open_menus_count ) {\n\n\t\t\t\t\t// Loop through all the open menus and close them\n\t\t\t\t\tfor( opn = 0; opn < open_menus.length; opn = opn + 1 ) {\n\n\t\t\t\t\t\tmenu_sub_close( open_menus[opn] );\n\n\t\t\t\t\t} // for\n\n\t\t\t\t\t// Return focus to the first open menu\n\t\t\t\t\tif( sub_menu_acion === 'click' ) {\n\t\t\t\t\t\topen_menus[0].focus();\n\t\t\t\t\t}\n\n\t\t\t\t} // if\n\n\t\t\t// If the event was a mouseup\n\t\t\t} else if( e.type === 'mouseup' ) {\n\n\t\t\t\tif ( !menu.contains( e.target ) && menu.querySelector('.submenu-is-open') ) {\n\n\t\t\t\t\t// We were getting some error, so let's add in a second checkpoint\n\t\t\t\t\tif ( open_menus_count ) {\n\n\t\t\t\t\t\tfor( opn = 0; opn < open_menus.length; opn = opn + 1 ) {\n\n\t\t\t\t\t\t\tmenu_sub_close( open_menus[opn] );\n\n\t\t\t\t\t\t} // for\n\n\t\t\t\t\t}\n\n\t\t\t\t} // if\n\n\t\t\t}\n\n\t\t}; // listener_close_open_menus()\n\n\t\tfunction menu_sub_close( open_item ) {\n\n\t\t\topen_item.classList.remove('submenu-is-open');\n\t\t\topen_item.parentNode.classList.remove('child-has-focus');\n\n\t\t\tif( open_item.parentNode.querySelector('.sub-menu') ) {\n\t\t\t\topen_item.parentNode.querySelector('.sub-menu').setAttribute( 'aria-hidden', 'true');\n\t\t\t}\n\n\t\t}; // menu_sub_close()\n\n\t\tfunction menu_sub_open( closed_item ) {\n\n\t\t\tclosed_item.classList.add('submenu-is-open');\n\t\t\tclosed_item.parentNode.classList.add('child-has-focus');\n\n\t\t\tif( closed_item.parentNode.querySelector('.sub-menu') ) {\n\t\t\t\tclosed_item.parentNode.querySelector('.sub-menu').setAttribute( 'aria-hidden', 'false');\n\t\t\t}\n\n\t\t}; // menu_sub_open()\n\n\t\t// Method to create the small screen menu\n\t\tfunction menu_create() {\n\n\t\t\tif( !document.body.classList.contains( 'menu-created' ) ) {\n\n\t\t\t\tif( !document.body.classList.contains( 'menu-is-open' ) ) {\n\n\t\t\t\t\tmenu.setAttribute( 'aria-hidden', 'true' );\n\t\t\t\t\tmenu_toggle.setAttribute( 'aria-expanded', 'false' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmenu.setAttribute( 'aria-hidden', 'false' );\n\t\t\t\t\tmenu_toggle.setAttribute( 'aria-expanded', 'true' );\n\n\t\t\t\t}\n\n\t\t\t\t// Loop through all submenus and bind events when needed\n\t\t\t\tfor( i = 0; i < menu_items_with_children_count; i = i + 1 ) {\n\n\t\t\t\t\tif( sub_menu_acion !== 'click' ) {\n\n\t\t\t\t\t\tmenu_items_with_children[i].addEventListener( 'click', listener_submenu_click );\n\t\t\t\t\t\tmenu_items_with_children[i].removeEventListener( 'focusin', listener_submenu_focus );\n\t\t\t\t\t\tmenu.classList.add('uses-click');\n\n\t\t\t\t\t}\n\n\t\t\t\t} // for\n\n\t\t\t\t// Bind the event\n\t\t\t\tmenu_toggle.addEventListener( 'click', listener_menu );\n\n\t\t\t\t// Add the body class to prevent this from running again\n\t\t\t\tdocument.body.classList.add( 'menu-created' );\n\t\t\t\tdocument.body.classList.remove( 'menu-destroyed' );\n\n\t\t\t}\n\n\t\t}; // menu_create()\n\n\t\t// Method to destroy the small screen menu\n\t\tfunction menu_destroy() {\n\n\t\t\tvar tmp_open\n\t\t\tvar tmp_open_count\n\t\t\tvar t;\n\n\t\t\tif( !document.body.classList.contains( 'menu-destroyed' ) ) {\n\n\t\t\t\t// Remove aria-hidden, because we don't need it.\n\t\t\t\tmenu.removeAttribute( 'aria-hidden' );\n\n\t\t\t\t// Loop through all submenus and bind events when needed\n\t\t\t\tfor( i = 0; i < menu_items_with_children_count; i = i + 1 ) {\n\t\t\t\t\tif( sub_menu_acion !== 'click' ) {\n\t\t\t\t\t\tmenu_items_with_children[i].removeEventListener( 'click', listener_submenu_click );\n\t\t\t\t\t\tmenu_items_with_children[i].addEventListener( 'focusin', listener_submenu_focus );\n\t\t\t\t\t\tmenu.classList.remove('uses-click');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If we're not using click, the open menus need to be reset\n\t\t\t\tif( sub_menu_acion !== 'click' ) {\n\n\t\t\t\t\ttmp_open = document.querySelectorAll('.child-has-focus');\n\t\t\t\t\ttmp_open_count = tmp_open.length;\n\n\t\t\t\t\tfor( t = 0; t < tmp_open_count; t = t + 1 ) {\n\t\t\t\t\t\ttmp_open[t].classList.remove( 'child-has-focus' );\n\t\t\t\t\t\ttmp_open[t].querySelector('.submenu-is-open').classList.remove('submenu-is-open');\n\t\t\t\t\t\ttmp_open[t].querySelector('.sub-menu').setAttribute( 'aria-hidden', 'true');\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Unbind the event\n\t\t\t\tmenu_toggle.removeEventListener( 'click', listener_menu );\n\n\t\t\t\t// Add the body class to prevent this from running again\n\t\t\t\tdocument.body.classList.add( 'menu-destroyed' );\n\t\t\t\tdocument.body.classList.remove( 'menu-created' );\n\n\t\t\t}\n\n\t\t};\n\n\t\t// Check init menu state\n\t\tif( get_screen_size( 'small' ) ) {\n\t\t\tmenu_create();\n\t\t}\n\n\t\t// If aria-controls isn't set, set it\n\t\tif( !aria_controls ) {\n\t\t\tmenu_toggle.setAttribute( 'aria-controls', menu_id );\n\t\t}\n\n\t\t// If the menu ID and toggle href don't match, make them match (this seems to happen often to merit this check)\n\t\tif( menu_toggle_target !== menu_id ) {\n\t\t\tmenu_toggle.setAttribute( 'href', '#' + menu_id );\n\t\t}\n\n\t\tif ( current_menu_item ) {\n\t\t\tcurrent_menu_item.querySelector( 'a' ).setAttribute( 'aria-current', 'page' );\n\t\t}\n\n\n\t\t/*\n\t\t\tEvents\n\t\t*/\n\n\t\t// Debounced resize event to create and destroy the small screen menu options\n\t\twindow.addEventListener( 'resize', listener_window );\n\n\t\t// Close the submenus by clicking off of them or hitting ESC\n\t\tdocument.addEventListener('mouseup', listener_close_open_menus );\n\t\tdocument.addEventListener('keyup', listener_close_open_menus );\n\n\t\t/*\n\t\t\tHiding and showing submenus (click, focus, hover)\n\t\t*/\n\n\t\t// Loop through all items with sub menus and bind focus to them for tabbing\n\t\tfor( i = 0; i < menu_items_with_children_count; i = i + 1 ) {\n\n\t\t\t// Let a screen reader know this menu has a submenu by hooking into the first link\n\t\t\tmenu_items_with_children[i].querySelector('a').setAttribute( 'aria-haspopup', 'true' );\n\n\t\t\t// Hide and label each sub menu\n\t\t\tmenu_items_with_children[i].querySelector('.sub-menu').setAttribute( 'aria-hidden', 'true' );\n\t\t\tmenu_items_with_children[i].querySelector('.sub-menu').setAttribute( 'aria-label', 'Submenu' );\n\n\t\t\t// If the screen is small or the action is set to click\n\t\t\tif( get_screen_size( 'small' ) || sub_menu_acion === 'click' ) {\n\n\t\t\t\tmenu_items_with_children[i].addEventListener( 'click', listener_submenu_click );\n\t\t\t\tmenu.classList.add('uses-click');\n\n\t\t\t} else if ( sub_menu_acion !== 'click' ) {\n\n\t\t\t\tif( get_screen_size( 'medium' ) || get_screen_size( 'large' ) ) {\n\n\t\t\t\t\tmenu_items_with_children[i].addEventListener( 'focusin', listener_submenu_focus );\n\n\t\t\t\t} // if\n\n\t\t\t} // if\n\n\t\t} // for\n\n\t\t// Execute the callback function\n\t\tif( typeof callback === 'function' ) {\n\t\t\tcallback.call();\n\t\t}\n\n\t}; // build_menu()\n\n\t/*\n\t\tHelper functions\n\t*/\n\n\t// Get screen size from getComputedStyle (so we don't have to define each breakpoint twice) -- Values are set in CSS --\n\tfunction get_screen_size( sizeString ) {\n\n\t\tvar size = window.getComputedStyle( document.body,':before' ).getPropertyValue( 'content' );\n\n\t\tif( size && size.indexOf( sizeString ) !==-1 ) {\n\t\t\treturn true;\n\t\t}\n\n\t};\n\n\t// Debounce\n\tfunction debounce( func, wait, immediate ) {\n\n\t\tvar timeout;\n\t\treturn function() {\n\t\t\tvar context = this, args = arguments;\n\n\t\t\tvar later = function() {\n\t\t\t\ttimeout = null;\n\t\t\t\tif (!immediate) func.apply(context, args);\n\t\t\t};\n\n\t\t\tvar callNow = immediate && !timeout;\n\n\t\t\tclearTimeout( timeout );\n\t\t\ttimeout = setTimeout( later, wait );\n\t\t\tif (callNow) func.apply(context, args);\n\t\t};\n\n\t};\n\n} )();\n"},391:function(t,n,e){e(7)(e(392))},392:function(t,n){t.exports="/*\n     _ _      _       _\n ___| (_) ___| | __  (_)___\n/ __| | |/ __| |/ /  | / __|\n\\__ \\ | | (__|   < _ | \\__ \\\n|___/_|_|\\___|_|\\_(_)/ |___/\n                   |__/\n\n Version: 1.9.0\n  Author: Ken Wheeler\n Website: http://kenwheeler.github.io\n    Docs: http://kenwheeler.github.io/slick\n    Repo: http://github.com/kenwheeler/slick\n  Issues: http://github.com/kenwheeler/slick/issues\n\n */\n/* global window, document, define, jQuery, setInterval, clearInterval */\n;(function(factory) {\n    'use strict';\n    if (typeof define === 'function' && define.amd) {\n        define(['jquery'], factory);\n    } else if (typeof exports !== 'undefined') {\n        module.exports = factory(require('jquery'));\n    } else {\n        factory(jQuery);\n    }\n\n}(function($) {\n    'use strict';\n    var Slick = window.Slick || {};\n\n    Slick = (function() {\n\n        var instanceUid = 0;\n\n        function Slick(element, settings) {\n\n            var _ = this, dataSettings;\n\n            _.defaults = {\n                accessibility: true,\n                adaptiveHeight: false,\n                appendArrows: $(element),\n                appendDots: $(element),\n                arrows: true,\n                asNavFor: null,\n                prevArrow: '<button class=\"slick-prev\" aria-label=\"Previous\" type=\"button\">Previous</button>',\n                nextArrow: '<button class=\"slick-next\" aria-label=\"Next\" type=\"button\">Next</button>',\n                autoplay: false,\n                autoplaySpeed: 3000,\n                centerMode: false,\n                centerPadding: '50px',\n                cssEase: 'ease',\n                customPaging: function(slider, i) {\n                    return $('<button type=\"button\" />').text(i + 1);\n                },\n                dots: false,\n                dotsClass: 'slick-dots',\n                draggable: true,\n                easing: 'linear',\n                edgeFriction: 0.35,\n                fade: false,\n                focusOnSelect: false,\n                focusOnChange: false,\n                infinite: true,\n                initialSlide: 0,\n                lazyLoad: 'ondemand',\n                mobileFirst: false,\n                pauseOnHover: true,\n                pauseOnFocus: true,\n                pauseOnDotsHover: false,\n                respondTo: 'window',\n                responsive: null,\n                rows: 1,\n                rtl: false,\n                slide: '',\n                slidesPerRow: 1,\n                slidesToShow: 1,\n                slidesToScroll: 1,\n                speed: 500,\n                swipe: true,\n                swipeToSlide: false,\n                touchMove: true,\n                touchThreshold: 5,\n                useCSS: true,\n                useTransform: true,\n                variableWidth: false,\n                vertical: false,\n                verticalSwiping: false,\n                waitForAnimate: true,\n                zIndex: 1000\n            };\n\n            _.initials = {\n                animating: false,\n                dragging: false,\n                autoPlayTimer: null,\n                currentDirection: 0,\n                currentLeft: null,\n                currentSlide: 0,\n                direction: 1,\n                $dots: null,\n                listWidth: null,\n                listHeight: null,\n                loadIndex: 0,\n                $nextArrow: null,\n                $prevArrow: null,\n                scrolling: false,\n                slideCount: null,\n                slideWidth: null,\n                $slideTrack: null,\n                $slides: null,\n                sliding: false,\n                slideOffset: 0,\n                swipeLeft: null,\n                swiping: false,\n                $list: null,\n                touchObject: {},\n                transformsEnabled: false,\n                unslicked: false\n            };\n\n            $.extend(_, _.initials);\n\n            _.activeBreakpoint = null;\n            _.animType = null;\n            _.animProp = null;\n            _.breakpoints = [];\n            _.breakpointSettings = [];\n            _.cssTransitions = false;\n            _.focussed = false;\n            _.interrupted = false;\n            _.hidden = 'hidden';\n            _.paused = true;\n            _.positionProp = null;\n            _.respondTo = null;\n            _.rowCount = 1;\n            _.shouldClick = true;\n            _.$slider = $(element);\n            _.$slidesCache = null;\n            _.transformType = null;\n            _.transitionType = null;\n            _.visibilityChange = 'visibilitychange';\n            _.windowWidth = 0;\n            _.windowTimer = null;\n\n            dataSettings = $(element).data('slick') || {};\n\n            _.options = $.extend({}, _.defaults, settings, dataSettings);\n\n            _.currentSlide = _.options.initialSlide;\n\n            _.originalSettings = _.options;\n\n            if (typeof document.mozHidden !== 'undefined') {\n                _.hidden = 'mozHidden';\n                _.visibilityChange = 'mozvisibilitychange';\n            } else if (typeof document.webkitHidden !== 'undefined') {\n                _.hidden = 'webkitHidden';\n                _.visibilityChange = 'webkitvisibilitychange';\n            }\n\n            _.autoPlay = $.proxy(_.autoPlay, _);\n            _.autoPlayClear = $.proxy(_.autoPlayClear, _);\n            _.autoPlayIterator = $.proxy(_.autoPlayIterator, _);\n            _.changeSlide = $.proxy(_.changeSlide, _);\n            _.clickHandler = $.proxy(_.clickHandler, _);\n            _.selectHandler = $.proxy(_.selectHandler, _);\n            _.setPosition = $.proxy(_.setPosition, _);\n            _.swipeHandler = $.proxy(_.swipeHandler, _);\n            _.dragHandler = $.proxy(_.dragHandler, _);\n            _.keyHandler = $.proxy(_.keyHandler, _);\n\n            _.instanceUid = instanceUid++;\n\n            // A simple way to check for HTML strings\n            // Strict HTML recognition (must start with <)\n            // Extracted from jQuery v1.11 source\n            _.htmlExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*)$/;\n\n\n            _.registerBreakpoints();\n            _.init(true);\n\n        }\n\n        return Slick;\n\n    }());\n\n    Slick.prototype.activateADA = function() {\n        var _ = this;\n\n        _.$slideTrack.find('.slick-active').attr({\n            'aria-hidden': 'false'\n        }).find('a, input, button, select').attr({\n            'tabindex': '0'\n        });\n\n    };\n\n    Slick.prototype.addSlide = Slick.prototype.slickAdd = function(markup, index, addBefore) {\n\n        var _ = this;\n\n        if (typeof(index) === 'boolean') {\n            addBefore = index;\n            index = null;\n        } else if (index < 0 || (index >= _.slideCount)) {\n            return false;\n        }\n\n        _.unload();\n\n        if (typeof(index) === 'number') {\n            if (index === 0 && _.$slides.length === 0) {\n                $(markup).appendTo(_.$slideTrack);\n            } else if (addBefore) {\n                $(markup).insertBefore(_.$slides.eq(index));\n            } else {\n                $(markup).insertAfter(_.$slides.eq(index));\n            }\n        } else {\n            if (addBefore === true) {\n                $(markup).prependTo(_.$slideTrack);\n            } else {\n                $(markup).appendTo(_.$slideTrack);\n            }\n        }\n\n        _.$slides = _.$slideTrack.children(this.options.slide);\n\n        _.$slideTrack.children(this.options.slide).detach();\n\n        _.$slideTrack.append(_.$slides);\n\n        _.$slides.each(function(index, element) {\n            $(element).attr('data-slick-index', index);\n        });\n\n        _.$slidesCache = _.$slides;\n\n        _.reinit();\n\n    };\n\n    Slick.prototype.animateHeight = function() {\n        var _ = this;\n        if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {\n            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);\n            _.$list.animate({\n                height: targetHeight\n            }, _.options.speed);\n        }\n    };\n\n    Slick.prototype.animateSlide = function(targetLeft, callback) {\n\n        var animProps = {},\n            _ = this;\n\n        _.animateHeight();\n\n        if (_.options.rtl === true && _.options.vertical === false) {\n            targetLeft = -targetLeft;\n        }\n        if (_.transformsEnabled === false) {\n            if (_.options.vertical === false) {\n                _.$slideTrack.animate({\n                    left: targetLeft\n                }, _.options.speed, _.options.easing, callback);\n            } else {\n                _.$slideTrack.animate({\n                    top: targetLeft\n                }, _.options.speed, _.options.easing, callback);\n            }\n\n        } else {\n\n            if (_.cssTransitions === false) {\n                if (_.options.rtl === true) {\n                    _.currentLeft = -(_.currentLeft);\n                }\n                $({\n                    animStart: _.currentLeft\n                }).animate({\n                    animStart: targetLeft\n                }, {\n                    duration: _.options.speed,\n                    easing: _.options.easing,\n                    step: function(now) {\n                        now = Math.ceil(now);\n                        if (_.options.vertical === false) {\n                            animProps[_.animType] = 'translate(' +\n                                now + 'px, 0px)';\n                            _.$slideTrack.css(animProps);\n                        } else {\n                            animProps[_.animType] = 'translate(0px,' +\n                                now + 'px)';\n                            _.$slideTrack.css(animProps);\n                        }\n                    },\n                    complete: function() {\n                        if (callback) {\n                            callback.call();\n                        }\n                    }\n                });\n\n            } else {\n\n                _.applyTransition();\n                targetLeft = Math.ceil(targetLeft);\n\n                if (_.options.vertical === false) {\n                    animProps[_.animType] = 'translate3d(' + targetLeft + 'px, 0px, 0px)';\n                } else {\n                    animProps[_.animType] = 'translate3d(0px,' + targetLeft + 'px, 0px)';\n                }\n                _.$slideTrack.css(animProps);\n\n                if (callback) {\n                    setTimeout(function() {\n\n                        _.disableTransition();\n\n                        callback.call();\n                    }, _.options.speed);\n                }\n\n            }\n\n        }\n\n    };\n\n    Slick.prototype.getNavTarget = function() {\n\n        var _ = this,\n            asNavFor = _.options.asNavFor;\n\n        if ( asNavFor && asNavFor !== null ) {\n            asNavFor = $(asNavFor).not(_.$slider);\n        }\n\n        return asNavFor;\n\n    };\n\n    Slick.prototype.asNavFor = function(index) {\n\n        var _ = this,\n            asNavFor = _.getNavTarget();\n\n        if ( asNavFor !== null && typeof asNavFor === 'object' ) {\n            asNavFor.each(function() {\n                var target = $(this).slick('getSlick');\n                if(!target.unslicked) {\n                    target.slideHandler(index, true);\n                }\n            });\n        }\n\n    };\n\n    Slick.prototype.applyTransition = function(slide) {\n\n        var _ = this,\n            transition = {};\n\n        if (_.options.fade === false) {\n            transition[_.transitionType] = _.transformType + ' ' + _.options.speed + 'ms ' + _.options.cssEase;\n        } else {\n            transition[_.transitionType] = 'opacity ' + _.options.speed + 'ms ' + _.options.cssEase;\n        }\n\n        if (_.options.fade === false) {\n            _.$slideTrack.css(transition);\n        } else {\n            _.$slides.eq(slide).css(transition);\n        }\n\n    };\n\n    Slick.prototype.autoPlay = function() {\n\n        var _ = this;\n\n        _.autoPlayClear();\n\n        if ( _.slideCount > _.options.slidesToShow ) {\n            _.autoPlayTimer = setInterval( _.autoPlayIterator, _.options.autoplaySpeed );\n        }\n\n    };\n\n    Slick.prototype.autoPlayClear = function() {\n\n        var _ = this;\n\n        if (_.autoPlayTimer) {\n            clearInterval(_.autoPlayTimer);\n        }\n\n    };\n\n    Slick.prototype.autoPlayIterator = function() {\n\n        var _ = this,\n            slideTo = _.currentSlide + _.options.slidesToScroll;\n\n        if ( !_.paused && !_.interrupted && !_.focussed ) {\n\n            if ( _.options.infinite === false ) {\n\n                if ( _.direction === 1 && ( _.currentSlide + 1 ) === ( _.slideCount - 1 )) {\n                    _.direction = 0;\n                }\n\n                else if ( _.direction === 0 ) {\n\n                    slideTo = _.currentSlide - _.options.slidesToScroll;\n\n                    if ( _.currentSlide - 1 === 0 ) {\n                        _.direction = 1;\n                    }\n\n                }\n\n            }\n\n            _.slideHandler( slideTo );\n\n        }\n\n    };\n\n    Slick.prototype.buildArrows = function() {\n\n        var _ = this;\n\n        if (_.options.arrows === true ) {\n\n            _.$prevArrow = $(_.options.prevArrow).addClass('slick-arrow');\n            _.$nextArrow = $(_.options.nextArrow).addClass('slick-arrow');\n\n            if( _.slideCount > _.options.slidesToShow ) {\n\n                _.$prevArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');\n                _.$nextArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');\n\n                if (_.htmlExpr.test(_.options.prevArrow)) {\n                    _.$prevArrow.prependTo(_.options.appendArrows);\n                }\n\n                if (_.htmlExpr.test(_.options.nextArrow)) {\n                    _.$nextArrow.appendTo(_.options.appendArrows);\n                }\n\n                if (_.options.infinite !== true) {\n                    _.$prevArrow\n                        .addClass('slick-disabled')\n                        .attr('aria-disabled', 'true');\n                }\n\n            } else {\n\n                _.$prevArrow.add( _.$nextArrow )\n\n                    .addClass('slick-hidden')\n                    .attr({\n                        'aria-disabled': 'true',\n                        'tabindex': '-1'\n                    });\n\n            }\n\n        }\n\n    };\n\n    Slick.prototype.buildDots = function() {\n\n        var _ = this,\n            i, dot;\n\n        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {\n\n            _.$slider.addClass('slick-dotted');\n\n            dot = $('<ul />').addClass(_.options.dotsClass);\n\n            for (i = 0; i <= _.getDotCount(); i += 1) {\n                dot.append($('<li />').append(_.options.customPaging.call(this, _, i)));\n            }\n\n            _.$dots = dot.appendTo(_.options.appendDots);\n\n            _.$dots.find('li').first().addClass('slick-active');\n\n        }\n\n    };\n\n    Slick.prototype.buildOut = function() {\n\n        var _ = this;\n\n        _.$slides =\n            _.$slider\n                .children( _.options.slide + ':not(.slick-cloned)')\n                .addClass('slick-slide');\n\n        _.slideCount = _.$slides.length;\n\n        _.$slides.each(function(index, element) {\n            $(element)\n                .attr('data-slick-index', index)\n                .data('originalStyling', $(element).attr('style') || '');\n        });\n\n        _.$slider.addClass('slick-slider');\n\n        _.$slideTrack = (_.slideCount === 0) ?\n            $('<div class=\"slick-track\"/>').appendTo(_.$slider) :\n            _.$slides.wrapAll('<div class=\"slick-track\"/>').parent();\n\n        _.$list = _.$slideTrack.wrap(\n            '<div class=\"slick-list\"/>').parent();\n        _.$slideTrack.css('opacity', 0);\n\n        if (_.options.centerMode === true || _.options.swipeToSlide === true) {\n            _.options.slidesToScroll = 1;\n        }\n\n        $('img[data-lazy]', _.$slider).not('[src]').addClass('slick-loading');\n\n        _.setupInfinite();\n\n        _.buildArrows();\n\n        _.buildDots();\n\n        _.updateDots();\n\n\n        _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);\n\n        if (_.options.draggable === true) {\n            _.$list.addClass('draggable');\n        }\n\n    };\n\n    Slick.prototype.buildRows = function() {\n\n        var _ = this, a, b, c, newSlides, numOfSlides, originalSlides,slidesPerSection;\n\n        newSlides = document.createDocumentFragment();\n        originalSlides = _.$slider.children();\n\n        if(_.options.rows > 0) {\n\n            slidesPerSection = _.options.slidesPerRow * _.options.rows;\n            numOfSlides = Math.ceil(\n                originalSlides.length / slidesPerSection\n            );\n\n            for(a = 0; a < numOfSlides; a++){\n                var slide = document.createElement('div');\n                for(b = 0; b < _.options.rows; b++) {\n                    var row = document.createElement('div');\n                    for(c = 0; c < _.options.slidesPerRow; c++) {\n                        var target = (a * slidesPerSection + ((b * _.options.slidesPerRow) + c));\n                        if (originalSlides.get(target)) {\n                            row.appendChild(originalSlides.get(target));\n                        }\n                    }\n                    slide.appendChild(row);\n                }\n                newSlides.appendChild(slide);\n            }\n\n            _.$slider.empty().append(newSlides);\n            _.$slider.children().children().children()\n                .css({\n                    'width':(100 / _.options.slidesPerRow) + '%',\n                    'display': 'inline-block'\n                });\n\n        }\n\n    };\n\n    Slick.prototype.checkResponsive = function(initial, forceUpdate) {\n\n        var _ = this,\n            breakpoint, targetBreakpoint, respondToWidth, triggerBreakpoint = false;\n        var sliderWidth = _.$slider.width();\n        var windowWidth = window.innerWidth || $(window).width();\n\n        if (_.respondTo === 'window') {\n            respondToWidth = windowWidth;\n        } else if (_.respondTo === 'slider') {\n            respondToWidth = sliderWidth;\n        } else if (_.respondTo === 'min') {\n            respondToWidth = Math.min(windowWidth, sliderWidth);\n        }\n\n        if ( _.options.responsive &&\n            _.options.responsive.length &&\n            _.options.responsive !== null) {\n\n            targetBreakpoint = null;\n\n            for (breakpoint in _.breakpoints) {\n                if (_.breakpoints.hasOwnProperty(breakpoint)) {\n                    if (_.originalSettings.mobileFirst === false) {\n                        if (respondToWidth < _.breakpoints[breakpoint]) {\n                            targetBreakpoint = _.breakpoints[breakpoint];\n                        }\n                    } else {\n                        if (respondToWidth > _.breakpoints[breakpoint]) {\n                            targetBreakpoint = _.breakpoints[breakpoint];\n                        }\n                    }\n                }\n            }\n\n            if (targetBreakpoint !== null) {\n                if (_.activeBreakpoint !== null) {\n                    if (targetBreakpoint !== _.activeBreakpoint || forceUpdate) {\n                        _.activeBreakpoint =\n                            targetBreakpoint;\n                        if (_.breakpointSettings[targetBreakpoint] === 'unslick') {\n                            _.unslick(targetBreakpoint);\n                        } else {\n                            _.options = $.extend({}, _.originalSettings,\n                                _.breakpointSettings[\n                                    targetBreakpoint]);\n                            if (initial === true) {\n                                _.currentSlide = _.options.initialSlide;\n                            }\n                            _.refresh(initial);\n                        }\n                        triggerBreakpoint = targetBreakpoint;\n                    }\n                } else {\n                    _.activeBreakpoint = targetBreakpoint;\n                    if (_.breakpointSettings[targetBreakpoint] === 'unslick') {\n                        _.unslick(targetBreakpoint);\n                    } else {\n                        _.options = $.extend({}, _.originalSettings,\n                            _.breakpointSettings[\n                                targetBreakpoint]);\n                        if (initial === true) {\n                            _.currentSlide = _.options.initialSlide;\n                        }\n                        _.refresh(initial);\n                    }\n                    triggerBreakpoint = targetBreakpoint;\n                }\n            } else {\n                if (_.activeBreakpoint !== null) {\n                    _.activeBreakpoint = null;\n                    _.options = _.originalSettings;\n                    if (initial === true) {\n                        _.currentSlide = _.options.initialSlide;\n                    }\n                    _.refresh(initial);\n                    triggerBreakpoint = targetBreakpoint;\n                }\n            }\n\n            // only trigger breakpoints during an actual break. not on initialize.\n            if( !initial && triggerBreakpoint !== false ) {\n                _.$slider.trigger('breakpoint', [_, triggerBreakpoint]);\n            }\n        }\n\n    };\n\n    Slick.prototype.changeSlide = function(event, dontAnimate) {\n\n        var _ = this,\n            $target = $(event.currentTarget),\n            indexOffset, slideOffset, unevenOffset;\n\n        // If target is a link, prevent default action.\n        if($target.is('a')) {\n            event.preventDefault();\n        }\n\n        // If target is not the <li> element (ie: a child), find the <li>.\n        if(!$target.is('li')) {\n            $target = $target.closest('li');\n        }\n\n        unevenOffset = (_.slideCount % _.options.slidesToScroll !== 0);\n        indexOffset = unevenOffset ? 0 : (_.slideCount - _.currentSlide) % _.options.slidesToScroll;\n\n        switch (event.data.message) {\n\n            case 'previous':\n                slideOffset = indexOffset === 0 ? _.options.slidesToScroll : _.options.slidesToShow - indexOffset;\n                if (_.slideCount > _.options.slidesToShow) {\n                    _.slideHandler(_.currentSlide - slideOffset, false, dontAnimate);\n                }\n                break;\n\n            case 'next':\n                slideOffset = indexOffset === 0 ? _.options.slidesToScroll : indexOffset;\n                if (_.slideCount > _.options.slidesToShow) {\n                    _.slideHandler(_.currentSlide + slideOffset, false, dontAnimate);\n                }\n                break;\n\n            case 'index':\n                var index = event.data.index === 0 ? 0 :\n                    event.data.index || $target.index() * _.options.slidesToScroll;\n\n                _.slideHandler(_.checkNavigable(index), false, dontAnimate);\n                $target.children().trigger('focus');\n                break;\n\n            default:\n                return;\n        }\n\n    };\n\n    Slick.prototype.checkNavigable = function(index) {\n\n        var _ = this,\n            navigables, prevNavigable;\n\n        navigables = _.getNavigableIndexes();\n        prevNavigable = 0;\n        if (index > navigables[navigables.length - 1]) {\n            index = navigables[navigables.length - 1];\n        } else {\n            for (var n in navigables) {\n                if (index < navigables[n]) {\n                    index = prevNavigable;\n                    break;\n                }\n                prevNavigable = navigables[n];\n            }\n        }\n\n        return index;\n    };\n\n    Slick.prototype.cleanUpEvents = function() {\n\n        var _ = this;\n\n        if (_.options.dots && _.$dots !== null) {\n\n            $('li', _.$dots)\n                .off('click.slick', _.changeSlide)\n                .off('mouseenter.slick', $.proxy(_.interrupt, _, true))\n                .off('mouseleave.slick', $.proxy(_.interrupt, _, false));\n\n            if (_.options.accessibility === true) {\n                _.$dots.off('keydown.slick', _.keyHandler);\n            }\n        }\n\n        _.$slider.off('focus.slick blur.slick');\n\n        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {\n            _.$prevArrow && _.$prevArrow.off('click.slick', _.changeSlide);\n            _.$nextArrow && _.$nextArrow.off('click.slick', _.changeSlide);\n\n            if (_.options.accessibility === true) {\n                _.$prevArrow && _.$prevArrow.off('keydown.slick', _.keyHandler);\n                _.$nextArrow && _.$nextArrow.off('keydown.slick', _.keyHandler);\n            }\n        }\n\n        _.$list.off('touchstart.slick mousedown.slick', _.swipeHandler);\n        _.$list.off('touchmove.slick mousemove.slick', _.swipeHandler);\n        _.$list.off('touchend.slick mouseup.slick', _.swipeHandler);\n        _.$list.off('touchcancel.slick mouseleave.slick', _.swipeHandler);\n\n        _.$list.off('click.slick', _.clickHandler);\n\n        $(document).off(_.visibilityChange, _.visibility);\n\n        _.cleanUpSlideEvents();\n\n        if (_.options.accessibility === true) {\n            _.$list.off('keydown.slick', _.keyHandler);\n        }\n\n        if (_.options.focusOnSelect === true) {\n            $(_.$slideTrack).children().off('click.slick', _.selectHandler);\n        }\n\n        $(window).off('orientationchange.slick.slick-' + _.instanceUid, _.orientationChange);\n\n        $(window).off('resize.slick.slick-' + _.instanceUid, _.resize);\n\n        $('[draggable!=true]', _.$slideTrack).off('dragstart', _.preventDefault);\n\n        $(window).off('load.slick.slick-' + _.instanceUid, _.setPosition);\n\n    };\n\n    Slick.prototype.cleanUpSlideEvents = function() {\n\n        var _ = this;\n\n        _.$list.off('mouseenter.slick', $.proxy(_.interrupt, _, true));\n        _.$list.off('mouseleave.slick', $.proxy(_.interrupt, _, false));\n\n    };\n\n    Slick.prototype.cleanUpRows = function() {\n\n        var _ = this, originalSlides;\n\n        if(_.options.rows > 0) {\n            originalSlides = _.$slides.children().children();\n            originalSlides.removeAttr('style');\n            _.$slider.empty().append(originalSlides);\n        }\n\n    };\n\n    Slick.prototype.clickHandler = function(event) {\n\n        var _ = this;\n\n        if (_.shouldClick === false) {\n            event.stopImmediatePropagation();\n            event.stopPropagation();\n            event.preventDefault();\n        }\n\n    };\n\n    Slick.prototype.destroy = function(refresh) {\n\n        var _ = this;\n\n        _.autoPlayClear();\n\n        _.touchObject = {};\n\n        _.cleanUpEvents();\n\n        $('.slick-cloned', _.$slider).detach();\n\n        if (_.$dots) {\n            _.$dots.remove();\n        }\n\n        if ( _.$prevArrow && _.$prevArrow.length ) {\n\n            _.$prevArrow\n                .removeClass('slick-disabled slick-arrow slick-hidden')\n                .removeAttr('aria-hidden aria-disabled tabindex')\n                .css('display','');\n\n            if ( _.htmlExpr.test( _.options.prevArrow )) {\n                _.$prevArrow.remove();\n            }\n        }\n\n        if ( _.$nextArrow && _.$nextArrow.length ) {\n\n            _.$nextArrow\n                .removeClass('slick-disabled slick-arrow slick-hidden')\n                .removeAttr('aria-hidden aria-disabled tabindex')\n                .css('display','');\n\n            if ( _.htmlExpr.test( _.options.nextArrow )) {\n                _.$nextArrow.remove();\n            }\n        }\n\n\n        if (_.$slides) {\n\n            _.$slides\n                .removeClass('slick-slide slick-active slick-center slick-visible slick-current')\n                .removeAttr('aria-hidden')\n                .removeAttr('data-slick-index')\n                .each(function(){\n                    $(this).attr('style', $(this).data('originalStyling'));\n                });\n\n            _.$slideTrack.children(this.options.slide).detach();\n\n            _.$slideTrack.detach();\n\n            _.$list.detach();\n\n            _.$slider.append(_.$slides);\n        }\n\n        _.cleanUpRows();\n\n        _.$slider.removeClass('slick-slider');\n        _.$slider.removeClass('slick-initialized');\n        _.$slider.removeClass('slick-dotted');\n\n        _.unslicked = true;\n\n        if(!refresh) {\n            _.$slider.trigger('destroy', [_]);\n        }\n\n    };\n\n    Slick.prototype.disableTransition = function(slide) {\n\n        var _ = this,\n            transition = {};\n\n        transition[_.transitionType] = '';\n\n        if (_.options.fade === false) {\n            _.$slideTrack.css(transition);\n        } else {\n            _.$slides.eq(slide).css(transition);\n        }\n\n    };\n\n    Slick.prototype.fadeSlide = function(slideIndex, callback) {\n\n        var _ = this;\n\n        if (_.cssTransitions === false) {\n\n            _.$slides.eq(slideIndex).css({\n                zIndex: _.options.zIndex\n            });\n\n            _.$slides.eq(slideIndex).animate({\n                opacity: 1\n            }, _.options.speed, _.options.easing, callback);\n\n        } else {\n\n            _.applyTransition(slideIndex);\n\n            _.$slides.eq(slideIndex).css({\n                opacity: 1,\n                zIndex: _.options.zIndex\n            });\n\n            if (callback) {\n                setTimeout(function() {\n\n                    _.disableTransition(slideIndex);\n\n                    callback.call();\n                }, _.options.speed);\n            }\n\n        }\n\n    };\n\n    Slick.prototype.fadeSlideOut = function(slideIndex) {\n\n        var _ = this;\n\n        if (_.cssTransitions === false) {\n\n            _.$slides.eq(slideIndex).animate({\n                opacity: 0,\n                zIndex: _.options.zIndex - 2\n            }, _.options.speed, _.options.easing);\n\n        } else {\n\n            _.applyTransition(slideIndex);\n\n            _.$slides.eq(slideIndex).css({\n                opacity: 0,\n                zIndex: _.options.zIndex - 2\n            });\n\n        }\n\n    };\n\n    Slick.prototype.filterSlides = Slick.prototype.slickFilter = function(filter) {\n\n        var _ = this;\n\n        if (filter !== null) {\n\n            _.$slidesCache = _.$slides;\n\n            _.unload();\n\n            _.$slideTrack.children(this.options.slide).detach();\n\n            _.$slidesCache.filter(filter).appendTo(_.$slideTrack);\n\n            _.reinit();\n\n        }\n\n    };\n\n    Slick.prototype.focusHandler = function() {\n\n        var _ = this;\n\n        // If any child element receives focus within the slider we need to pause the autoplay\n        _.$slider\n            .off('focus.slick blur.slick')\n            .on(\n                'focus.slick',\n                '*',\n                function(event) {\n                    var $sf = $(this);\n\n                    setTimeout(function() {\n                        if( _.options.pauseOnFocus ) {\n                            if ($sf.is(':focus')) {\n                                _.focussed = true;\n                                _.autoPlay();\n                            }\n                        }\n                    }, 0);\n                }\n            ).on(\n                'blur.slick',\n                '*',\n                function(event) {\n                    var $sf = $(this);\n\n                    // When a blur occurs on any elements within the slider we become unfocused\n                    if( _.options.pauseOnFocus ) {\n                        _.focussed = false;\n                        _.autoPlay();\n                    }\n                }\n            );\n    };\n\n    Slick.prototype.getCurrent = Slick.prototype.slickCurrentSlide = function() {\n\n        var _ = this;\n        return _.currentSlide;\n\n    };\n\n    Slick.prototype.getDotCount = function() {\n\n        var _ = this;\n\n        var breakPoint = 0;\n        var counter = 0;\n        var pagerQty = 0;\n\n        if (_.options.infinite === true) {\n            if (_.slideCount <= _.options.slidesToShow) {\n                 ++pagerQty;\n            } else {\n                while (breakPoint < _.slideCount) {\n                    ++pagerQty;\n                    breakPoint = counter + _.options.slidesToScroll;\n                    counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;\n                }\n            }\n        } else if (_.options.centerMode === true) {\n            pagerQty = _.slideCount;\n        } else if(!_.options.asNavFor) {\n            pagerQty = 1 + Math.ceil((_.slideCount - _.options.slidesToShow) / _.options.slidesToScroll);\n        }else {\n            while (breakPoint < _.slideCount) {\n                ++pagerQty;\n                breakPoint = counter + _.options.slidesToScroll;\n                counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;\n            }\n        }\n\n        return pagerQty - 1;\n\n    };\n\n    Slick.prototype.getLeft = function(slideIndex) {\n\n        var _ = this,\n            targetLeft,\n            verticalHeight,\n            verticalOffset = 0,\n            targetSlide,\n            coef;\n\n        _.slideOffset = 0;\n        verticalHeight = _.$slides.first().outerHeight(true);\n\n        if (_.options.infinite === true) {\n            if (_.slideCount > _.options.slidesToShow) {\n                _.slideOffset = (_.slideWidth * _.options.slidesToShow) * -1;\n                coef = -1\n\n                if (_.options.vertical === true && _.options.centerMode === true) {\n                    if (_.options.slidesToShow === 2) {\n                        coef = -1.5;\n                    } else if (_.options.slidesToShow === 1) {\n                        coef = -2\n                    }\n                }\n                verticalOffset = (verticalHeight * _.options.slidesToShow) * coef;\n            }\n            if (_.slideCount % _.options.slidesToScroll !== 0) {\n                if (slideIndex + _.options.slidesToScroll > _.slideCount && _.slideCount > _.options.slidesToShow) {\n                    if (slideIndex > _.slideCount) {\n                        _.slideOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * _.slideWidth) * -1;\n                        verticalOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * verticalHeight) * -1;\n                    } else {\n                        _.slideOffset = ((_.slideCount % _.options.slidesToScroll) * _.slideWidth) * -1;\n                        verticalOffset = ((_.slideCount % _.options.slidesToScroll) * verticalHeight) * -1;\n                    }\n                }\n            }\n        } else {\n            if (slideIndex + _.options.slidesToShow > _.slideCount) {\n                _.slideOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * _.slideWidth;\n                verticalOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * verticalHeight;\n            }\n        }\n\n        if (_.slideCount <= _.options.slidesToShow) {\n            _.slideOffset = 0;\n            verticalOffset = 0;\n        }\n\n        if (_.options.centerMode === true && _.slideCount <= _.options.slidesToShow) {\n            _.slideOffset = ((_.slideWidth * Math.floor(_.options.slidesToShow)) / 2) - ((_.slideWidth * _.slideCount) / 2);\n        } else if (_.options.centerMode === true && _.options.infinite === true) {\n            _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2) - _.slideWidth;\n        } else if (_.options.centerMode === true) {\n            _.slideOffset = 0;\n            _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2);\n        }\n\n        if (_.options.vertical === false) {\n            targetLeft = ((slideIndex * _.slideWidth) * -1) + _.slideOffset;\n        } else {\n            targetLeft = ((slideIndex * verticalHeight) * -1) + verticalOffset;\n        }\n\n        if (_.options.variableWidth === true) {\n\n            if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {\n                targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);\n            } else {\n                targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow);\n            }\n\n            if (_.options.rtl === true) {\n                if (targetSlide[0]) {\n                    targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;\n                } else {\n                    targetLeft =  0;\n                }\n            } else {\n                targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;\n            }\n\n            if (_.options.centerMode === true) {\n                if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {\n                    targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);\n                } else {\n                    targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow + 1);\n                }\n\n                if (_.options.rtl === true) {\n                    if (targetSlide[0]) {\n                        targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;\n                    } else {\n                        targetLeft =  0;\n                    }\n                } else {\n                    targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;\n                }\n\n                targetLeft += (_.$list.width() - targetSlide.outerWidth()) / 2;\n            }\n        }\n\n        return targetLeft;\n\n    };\n\n    Slick.prototype.getOption = Slick.prototype.slickGetOption = function(option) {\n\n        var _ = this;\n\n        return _.options[option];\n\n    };\n\n    Slick.prototype.getNavigableIndexes = function() {\n\n        var _ = this,\n            breakPoint = 0,\n            counter = 0,\n            indexes = [],\n            max;\n\n        if (_.options.infinite === false) {\n            max = _.slideCount;\n        } else {\n            breakPoint = _.options.slidesToScroll * -1;\n            counter = _.options.slidesToScroll * -1;\n            max = _.slideCount * 2;\n        }\n\n        while (breakPoint < max) {\n            indexes.push(breakPoint);\n            breakPoint = counter + _.options.slidesToScroll;\n            counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;\n        }\n\n        return indexes;\n\n    };\n\n    Slick.prototype.getSlick = function() {\n\n        return this;\n\n    };\n\n    Slick.prototype.getSlideCount = function() {\n\n        var _ = this,\n            slidesTraversed, swipedSlide, swipeTarget, centerOffset;\n\n        centerOffset = _.options.centerMode === true ? Math.floor(_.$list.width() / 2) : 0;\n        swipeTarget = (_.swipeLeft * -1) + centerOffset;\n\n        if (_.options.swipeToSlide === true) {\n\n            _.$slideTrack.find('.slick-slide').each(function(index, slide) {\n\n                var slideOuterWidth, slideOffset, slideRightBoundary;\n                slideOuterWidth = $(slide).outerWidth();\n                slideOffset = slide.offsetLeft;\n                if (_.options.centerMode !== true) {\n                    slideOffset += (slideOuterWidth / 2);\n                }\n\n                slideRightBoundary = slideOffset + (slideOuterWidth);\n\n                if (swipeTarget < slideRightBoundary) {\n                    swipedSlide = slide;\n                    return false;\n                }\n            });\n\n            slidesTraversed = Math.abs($(swipedSlide).attr('data-slick-index') - _.currentSlide) || 1;\n\n            return slidesTraversed;\n\n        } else {\n            return _.options.slidesToScroll;\n        }\n\n    };\n\n    Slick.prototype.goTo = Slick.prototype.slickGoTo = function(slide, dontAnimate) {\n\n        var _ = this;\n\n        _.changeSlide({\n            data: {\n                message: 'index',\n                index: parseInt(slide)\n            }\n        }, dontAnimate);\n\n    };\n\n    Slick.prototype.init = function(creation) {\n\n        var _ = this;\n\n        if (!$(_.$slider).hasClass('slick-initialized')) {\n\n            $(_.$slider).addClass('slick-initialized');\n\n            _.buildRows();\n            _.buildOut();\n            _.setProps();\n            _.startLoad();\n            _.loadSlider();\n            _.initializeEvents();\n            _.updateArrows();\n            _.updateDots();\n            _.checkResponsive(true);\n            _.focusHandler();\n\n        }\n\n        if (creation) {\n            _.$slider.trigger('init', [_]);\n        }\n\n        if (_.options.accessibility === true) {\n            _.initADA();\n        }\n\n        if ( _.options.autoplay ) {\n\n            _.paused = false;\n            _.autoPlay();\n\n        }\n\n    };\n\n    Slick.prototype.initADA = function() {\n        var _ = this,\n                numDotGroups = Math.ceil(_.slideCount / _.options.slidesToShow),\n                tabControlIndexes = _.getNavigableIndexes().filter(function(val) {\n                    return (val >= 0) && (val < _.slideCount);\n                });\n\n        _.$slides.add(_.$slideTrack.find('.slick-cloned')).attr({\n            'aria-hidden': 'true',\n            'tabindex': '-1'\n        }).find('a, input, button, select').attr({\n            'tabindex': '-1'\n        });\n\n        if (_.$dots !== null) {\n            _.$slides.not(_.$slideTrack.find('.slick-cloned')).each(function(i) {\n                var slideControlIndex = tabControlIndexes.indexOf(i);\n\n                $(this).attr({\n                    'role': 'tabpanel',\n                    'id': 'slick-slide' + _.instanceUid + i,\n                    'tabindex': -1\n                });\n\n                if (slideControlIndex !== -1) {\n                   var ariaButtonControl = 'slick-slide-control' + _.instanceUid + slideControlIndex\n                   if ($('#' + ariaButtonControl).length) {\n                     $(this).attr({\n                         'aria-describedby': ariaButtonControl\n                     });\n                   }\n                }\n            });\n\n            _.$dots.attr('role', 'tablist').find('li').each(function(i) {\n                var mappedSlideIndex = tabControlIndexes[i];\n\n                $(this).attr({\n                    'role': 'presentation'\n                });\n\n                $(this).find('button').first().attr({\n                    'role': 'tab',\n                    'id': 'slick-slide-control' + _.instanceUid + i,\n                    'aria-controls': 'slick-slide' + _.instanceUid + mappedSlideIndex,\n                    'aria-label': (i + 1) + ' of ' + numDotGroups,\n                    'aria-selected': null,\n                    'tabindex': '-1'\n                });\n\n            }).eq(_.currentSlide).find('button').attr({\n                'aria-selected': 'true',\n                'tabindex': '0'\n            }).end();\n        }\n\n        for (var i=_.currentSlide, max=i+_.options.slidesToShow; i < max; i++) {\n          if (_.options.focusOnChange) {\n            _.$slides.eq(i).attr({'tabindex': '0'});\n          } else {\n            _.$slides.eq(i).removeAttr('tabindex');\n          }\n        }\n\n        _.activateADA();\n\n    };\n\n    Slick.prototype.initArrowEvents = function() {\n\n        var _ = this;\n\n        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {\n            _.$prevArrow\n               .off('click.slick')\n               .on('click.slick', {\n                    message: 'previous'\n               }, _.changeSlide);\n            _.$nextArrow\n               .off('click.slick')\n               .on('click.slick', {\n                    message: 'next'\n               }, _.changeSlide);\n\n            if (_.options.accessibility === true) {\n                _.$prevArrow.on('keydown.slick', _.keyHandler);\n                _.$nextArrow.on('keydown.slick', _.keyHandler);\n            }\n        }\n\n    };\n\n    Slick.prototype.initDotEvents = function() {\n\n        var _ = this;\n\n        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {\n            $('li', _.$dots).on('click.slick', {\n                message: 'index'\n            }, _.changeSlide);\n\n            if (_.options.accessibility === true) {\n                _.$dots.on('keydown.slick', _.keyHandler);\n            }\n        }\n\n        if (_.options.dots === true && _.options.pauseOnDotsHover === true && _.slideCount > _.options.slidesToShow) {\n\n            $('li', _.$dots)\n                .on('mouseenter.slick', $.proxy(_.interrupt, _, true))\n                .on('mouseleave.slick', $.proxy(_.interrupt, _, false));\n\n        }\n\n    };\n\n    Slick.prototype.initSlideEvents = function() {\n\n        var _ = this;\n\n        if ( _.options.pauseOnHover ) {\n\n            _.$list.on('mouseenter.slick', $.proxy(_.interrupt, _, true));\n            _.$list.on('mouseleave.slick', $.proxy(_.interrupt, _, false));\n\n        }\n\n    };\n\n    Slick.prototype.initializeEvents = function() {\n\n        var _ = this;\n\n        _.initArrowEvents();\n\n        _.initDotEvents();\n        _.initSlideEvents();\n\n        _.$list.on('touchstart.slick mousedown.slick', {\n            action: 'start'\n        }, _.swipeHandler);\n        _.$list.on('touchmove.slick mousemove.slick', {\n            action: 'move'\n        }, _.swipeHandler);\n        _.$list.on('touchend.slick mouseup.slick', {\n            action: 'end'\n        }, _.swipeHandler);\n        _.$list.on('touchcancel.slick mouseleave.slick', {\n            action: 'end'\n        }, _.swipeHandler);\n\n        _.$list.on('click.slick', _.clickHandler);\n\n        $(document).on(_.visibilityChange, $.proxy(_.visibility, _));\n\n        if (_.options.accessibility === true) {\n            _.$list.on('keydown.slick', _.keyHandler);\n        }\n\n        if (_.options.focusOnSelect === true) {\n            $(_.$slideTrack).children().on('click.slick', _.selectHandler);\n        }\n\n        $(window).on('orientationchange.slick.slick-' + _.instanceUid, $.proxy(_.orientationChange, _));\n\n        $(window).on('resize.slick.slick-' + _.instanceUid, $.proxy(_.resize, _));\n\n        $('[draggable!=true]', _.$slideTrack).on('dragstart', _.preventDefault);\n\n        $(window).on('load.slick.slick-' + _.instanceUid, _.setPosition);\n        $(_.setPosition);\n\n    };\n\n    Slick.prototype.initUI = function() {\n\n        var _ = this;\n\n        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {\n\n            _.$prevArrow.show();\n            _.$nextArrow.show();\n\n        }\n\n        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {\n\n            _.$dots.show();\n\n        }\n\n    };\n\n    Slick.prototype.keyHandler = function(event) {\n\n        var _ = this;\n         //Dont slide if the cursor is inside the form fields and arrow keys are pressed\n        if(!event.target.tagName.match('TEXTAREA|INPUT|SELECT')) {\n            if (event.keyCode === 37 && _.options.accessibility === true) {\n                _.changeSlide({\n                    data: {\n                        message: _.options.rtl === true ? 'next' :  'previous'\n                    }\n                });\n            } else if (event.keyCode === 39 && _.options.accessibility === true) {\n                _.changeSlide({\n                    data: {\n                        message: _.options.rtl === true ? 'previous' : 'next'\n                    }\n                });\n            }\n        }\n\n    };\n\n    Slick.prototype.lazyLoad = function() {\n\n        var _ = this,\n            loadRange, cloneRange, rangeStart, rangeEnd;\n\n        function loadImages(imagesScope) {\n\n            $('img[data-lazy]', imagesScope).each(function() {\n\n                var image = $(this),\n                    imageSource = $(this).attr('data-lazy'),\n                    imageSrcSet = $(this).attr('data-srcset'),\n                    imageSizes  = $(this).attr('data-sizes') || _.$slider.attr('data-sizes'),\n                    imageToLoad = document.createElement('img');\n\n                imageToLoad.onload = function() {\n\n                    image\n                        .animate({ opacity: 0 }, 100, function() {\n\n                            if (imageSrcSet) {\n                                image\n                                    .attr('srcset', imageSrcSet );\n\n                                if (imageSizes) {\n                                    image\n                                        .attr('sizes', imageSizes );\n                                }\n                            }\n\n                            image\n                                .attr('src', imageSource)\n                                .animate({ opacity: 1 }, 200, function() {\n                                    image\n                                        .removeAttr('data-lazy data-srcset data-sizes')\n                                        .removeClass('slick-loading');\n                                });\n                            _.$slider.trigger('lazyLoaded', [_, image, imageSource]);\n                        });\n\n                };\n\n                imageToLoad.onerror = function() {\n\n                    image\n                        .removeAttr( 'data-lazy' )\n                        .removeClass( 'slick-loading' )\n                        .addClass( 'slick-lazyload-error' );\n\n                    _.$slider.trigger('lazyLoadError', [ _, image, imageSource ]);\n\n                };\n\n                imageToLoad.src = imageSource;\n\n            });\n\n        }\n\n        if (_.options.centerMode === true) {\n            if (_.options.infinite === true) {\n                rangeStart = _.currentSlide + (_.options.slidesToShow / 2 + 1);\n                rangeEnd = rangeStart + _.options.slidesToShow + 2;\n            } else {\n                rangeStart = Math.max(0, _.currentSlide - (_.options.slidesToShow / 2 + 1));\n                rangeEnd = 2 + (_.options.slidesToShow / 2 + 1) + _.currentSlide;\n            }\n        } else {\n            rangeStart = _.options.infinite ? _.options.slidesToShow + _.currentSlide : _.currentSlide;\n            rangeEnd = Math.ceil(rangeStart + _.options.slidesToShow);\n            if (_.options.fade === true) {\n                if (rangeStart > 0) rangeStart--;\n                if (rangeEnd <= _.slideCount) rangeEnd++;\n            }\n        }\n\n        loadRange = _.$slider.find('.slick-slide').slice(rangeStart, rangeEnd);\n\n        if (_.options.lazyLoad === 'anticipated') {\n            var prevSlide = rangeStart - 1,\n                nextSlide = rangeEnd,\n                $slides = _.$slider.find('.slick-slide');\n\n            for (var i = 0; i < _.options.slidesToScroll; i++) {\n                if (prevSlide < 0) prevSlide = _.slideCount - 1;\n                loadRange = loadRange.add($slides.eq(prevSlide));\n                loadRange = loadRange.add($slides.eq(nextSlide));\n                prevSlide--;\n                nextSlide++;\n            }\n        }\n\n        loadImages(loadRange);\n\n        if (_.slideCount <= _.options.slidesToShow) {\n            cloneRange = _.$slider.find('.slick-slide');\n            loadImages(cloneRange);\n        } else\n        if (_.currentSlide >= _.slideCount - _.options.slidesToShow) {\n            cloneRange = _.$slider.find('.slick-cloned').slice(0, _.options.slidesToShow);\n            loadImages(cloneRange);\n        } else if (_.currentSlide === 0) {\n            cloneRange = _.$slider.find('.slick-cloned').slice(_.options.slidesToShow * -1);\n            loadImages(cloneRange);\n        }\n\n    };\n\n    Slick.prototype.loadSlider = function() {\n\n        var _ = this;\n\n        _.setPosition();\n\n        _.$slideTrack.css({\n            opacity: 1\n        });\n\n        _.$slider.removeClass('slick-loading');\n\n        _.initUI();\n\n        if (_.options.lazyLoad === 'progressive') {\n            _.progressiveLazyLoad();\n        }\n\n    };\n\n    Slick.prototype.next = Slick.prototype.slickNext = function() {\n\n        var _ = this;\n\n        _.changeSlide({\n            data: {\n                message: 'next'\n            }\n        });\n\n    };\n\n    Slick.prototype.orientationChange = function() {\n\n        var _ = this;\n\n        _.checkResponsive();\n        _.setPosition();\n\n    };\n\n    Slick.prototype.pause = Slick.prototype.slickPause = function() {\n\n        var _ = this;\n\n        _.autoPlayClear();\n        _.paused = true;\n\n    };\n\n    Slick.prototype.play = Slick.prototype.slickPlay = function() {\n\n        var _ = this;\n\n        _.autoPlay();\n        _.options.autoplay = true;\n        _.paused = false;\n        _.focussed = false;\n        _.interrupted = false;\n\n    };\n\n    Slick.prototype.postSlide = function(index) {\n\n        var _ = this;\n\n        if( !_.unslicked ) {\n\n            _.$slider.trigger('afterChange', [_, index]);\n\n            _.animating = false;\n\n            if (_.slideCount > _.options.slidesToShow) {\n                _.setPosition();\n            }\n\n            _.swipeLeft = null;\n\n            if ( _.options.autoplay ) {\n                _.autoPlay();\n            }\n\n            if (_.options.accessibility === true) {\n                _.initADA();\n\n                if (_.options.focusOnChange) {\n                    var $currentSlide = $(_.$slides.get(_.currentSlide));\n                    $currentSlide.attr('tabindex', 0).focus();\n                }\n            }\n\n        }\n\n    };\n\n    Slick.prototype.prev = Slick.prototype.slickPrev = function() {\n\n        var _ = this;\n\n        _.changeSlide({\n            data: {\n                message: 'previous'\n            }\n        });\n\n    };\n\n    Slick.prototype.preventDefault = function(event) {\n\n        event.preventDefault();\n\n    };\n\n    Slick.prototype.progressiveLazyLoad = function( tryCount ) {\n\n        tryCount = tryCount || 1;\n\n        var _ = this,\n            $imgsToLoad = $( 'img[data-lazy]', _.$slider ),\n            image,\n            imageSource,\n            imageSrcSet,\n            imageSizes,\n            imageToLoad;\n\n        if ( $imgsToLoad.length ) {\n\n            image = $imgsToLoad.first();\n            imageSource = image.attr('data-lazy');\n            imageSrcSet = image.attr('data-srcset');\n            imageSizes  = image.attr('data-sizes') || _.$slider.attr('data-sizes');\n            imageToLoad = document.createElement('img');\n\n            imageToLoad.onload = function() {\n\n                if (imageSrcSet) {\n                    image\n                        .attr('srcset', imageSrcSet );\n\n                    if (imageSizes) {\n                        image\n                            .attr('sizes', imageSizes );\n                    }\n                }\n\n                image\n                    .attr( 'src', imageSource )\n                    .removeAttr('data-lazy data-srcset data-sizes')\n                    .removeClass('slick-loading');\n\n                if ( _.options.adaptiveHeight === true ) {\n                    _.setPosition();\n                }\n\n                _.$slider.trigger('lazyLoaded', [ _, image, imageSource ]);\n                _.progressiveLazyLoad();\n\n            };\n\n            imageToLoad.onerror = function() {\n\n                if ( tryCount < 3 ) {\n\n                    /**\n                     * try to load the image 3 times,\n                     * leave a slight delay so we don't get\n                     * servers blocking the request.\n                     */\n                    setTimeout( function() {\n                        _.progressiveLazyLoad( tryCount + 1 );\n                    }, 500 );\n\n                } else {\n\n                    image\n                        .removeAttr( 'data-lazy' )\n                        .removeClass( 'slick-loading' )\n                        .addClass( 'slick-lazyload-error' );\n\n                    _.$slider.trigger('lazyLoadError', [ _, image, imageSource ]);\n\n                    _.progressiveLazyLoad();\n\n                }\n\n            };\n\n            imageToLoad.src = imageSource;\n\n        } else {\n\n            _.$slider.trigger('allImagesLoaded', [ _ ]);\n\n        }\n\n    };\n\n    Slick.prototype.refresh = function( initializing ) {\n\n        var _ = this, currentSlide, lastVisibleIndex;\n\n        lastVisibleIndex = _.slideCount - _.options.slidesToShow;\n\n        // in non-infinite sliders, we don't want to go past the\n        // last visible index.\n        if( !_.options.infinite && ( _.currentSlide > lastVisibleIndex )) {\n            _.currentSlide = lastVisibleIndex;\n        }\n\n        // if less slides than to show, go to start.\n        if ( _.slideCount <= _.options.slidesToShow ) {\n            _.currentSlide = 0;\n\n        }\n\n        currentSlide = _.currentSlide;\n\n        _.destroy(true);\n\n        $.extend(_, _.initials, { currentSlide: currentSlide });\n\n        _.init();\n\n        if( !initializing ) {\n\n            _.changeSlide({\n                data: {\n                    message: 'index',\n                    index: currentSlide\n                }\n            }, false);\n\n        }\n\n    };\n\n    Slick.prototype.registerBreakpoints = function() {\n\n        var _ = this, breakpoint, currentBreakpoint, l,\n            responsiveSettings = _.options.responsive || null;\n\n        if ( $.type(responsiveSettings) === 'array' && responsiveSettings.length ) {\n\n            _.respondTo = _.options.respondTo || 'window';\n\n            for ( breakpoint in responsiveSettings ) {\n\n                l = _.breakpoints.length-1;\n\n                if (responsiveSettings.hasOwnProperty(breakpoint)) {\n                    currentBreakpoint = responsiveSettings[breakpoint].breakpoint;\n\n                    // loop through the breakpoints and cut out any existing\n                    // ones with the same breakpoint number, we don't want dupes.\n                    while( l >= 0 ) {\n                        if( _.breakpoints[l] && _.breakpoints[l] === currentBreakpoint ) {\n                            _.breakpoints.splice(l,1);\n                        }\n                        l--;\n                    }\n\n                    _.breakpoints.push(currentBreakpoint);\n                    _.breakpointSettings[currentBreakpoint] = responsiveSettings[breakpoint].settings;\n\n                }\n\n            }\n\n            _.breakpoints.sort(function(a, b) {\n                return ( _.options.mobileFirst ) ? a-b : b-a;\n            });\n\n        }\n\n    };\n\n    Slick.prototype.reinit = function() {\n\n        var _ = this;\n\n        _.$slides =\n            _.$slideTrack\n                .children(_.options.slide)\n                .addClass('slick-slide');\n\n        _.slideCount = _.$slides.length;\n\n        if (_.currentSlide >= _.slideCount && _.currentSlide !== 0) {\n            _.currentSlide = _.currentSlide - _.options.slidesToScroll;\n        }\n\n        if (_.slideCount <= _.options.slidesToShow) {\n            _.currentSlide = 0;\n        }\n\n        _.registerBreakpoints();\n\n        _.setProps();\n        _.setupInfinite();\n        _.buildArrows();\n        _.updateArrows();\n        _.initArrowEvents();\n        _.buildDots();\n        _.updateDots();\n        _.initDotEvents();\n        _.cleanUpSlideEvents();\n        _.initSlideEvents();\n\n        _.checkResponsive(false, true);\n\n        if (_.options.focusOnSelect === true) {\n            $(_.$slideTrack).children().on('click.slick', _.selectHandler);\n        }\n\n        _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);\n\n        _.setPosition();\n        _.focusHandler();\n\n        _.paused = !_.options.autoplay;\n        _.autoPlay();\n\n        _.$slider.trigger('reInit', [_]);\n\n    };\n\n    Slick.prototype.resize = function() {\n\n        var _ = this;\n\n        if ($(window).width() !== _.windowWidth) {\n            clearTimeout(_.windowDelay);\n            _.windowDelay = window.setTimeout(function() {\n                _.windowWidth = $(window).width();\n                _.checkResponsive();\n                if( !_.unslicked ) { _.setPosition(); }\n            }, 50);\n        }\n    };\n\n    Slick.prototype.removeSlide = Slick.prototype.slickRemove = function(index, removeBefore, removeAll) {\n\n        var _ = this;\n\n        if (typeof(index) === 'boolean') {\n            removeBefore = index;\n            index = removeBefore === true ? 0 : _.slideCount - 1;\n        } else {\n            index = removeBefore === true ? --index : index;\n        }\n\n        if (_.slideCount < 1 || index < 0 || index > _.slideCount - 1) {\n            return false;\n        }\n\n        _.unload();\n\n        if (removeAll === true) {\n            _.$slideTrack.children().remove();\n        } else {\n            _.$slideTrack.children(this.options.slide).eq(index).remove();\n        }\n\n        _.$slides = _.$slideTrack.children(this.options.slide);\n\n        _.$slideTrack.children(this.options.slide).detach();\n\n        _.$slideTrack.append(_.$slides);\n\n        _.$slidesCache = _.$slides;\n\n        _.reinit();\n\n    };\n\n    Slick.prototype.setCSS = function(position) {\n\n        var _ = this,\n            positionProps = {},\n            x, y;\n\n        if (_.options.rtl === true) {\n            position = -position;\n        }\n        x = _.positionProp == 'left' ? Math.ceil(position) + 'px' : '0px';\n        y = _.positionProp == 'top' ? Math.ceil(position) + 'px' : '0px';\n\n        positionProps[_.positionProp] = position;\n\n        if (_.transformsEnabled === false) {\n            _.$slideTrack.css(positionProps);\n        } else {\n            positionProps = {};\n            if (_.cssTransitions === false) {\n                positionProps[_.animType] = 'translate(' + x + ', ' + y + ')';\n                _.$slideTrack.css(positionProps);\n            } else {\n                positionProps[_.animType] = 'translate3d(' + x + ', ' + y + ', 0px)';\n                _.$slideTrack.css(positionProps);\n            }\n        }\n\n    };\n\n    Slick.prototype.setDimensions = function() {\n\n        var _ = this;\n\n        if (_.options.vertical === false) {\n            if (_.options.centerMode === true) {\n                _.$list.css({\n                    padding: ('0px ' + _.options.centerPadding)\n                });\n            }\n        } else {\n            _.$list.height(_.$slides.first().outerHeight(true) * _.options.slidesToShow);\n            if (_.options.centerMode === true) {\n                _.$list.css({\n                    padding: (_.options.centerPadding + ' 0px')\n                });\n            }\n        }\n\n        _.listWidth = _.$list.width();\n        _.listHeight = _.$list.height();\n\n\n        if (_.options.vertical === false && _.options.variableWidth === false) {\n            _.slideWidth = Math.ceil(_.listWidth / _.options.slidesToShow);\n            _.$slideTrack.width(Math.ceil((_.slideWidth * _.$slideTrack.children('.slick-slide').length)));\n\n        } else if (_.options.variableWidth === true) {\n            _.$slideTrack.width(5000 * _.slideCount);\n        } else {\n            _.slideWidth = Math.ceil(_.listWidth);\n            _.$slideTrack.height(Math.ceil((_.$slides.first().outerHeight(true) * _.$slideTrack.children('.slick-slide').length)));\n        }\n\n        var offset = _.$slides.first().outerWidth(true) - _.$slides.first().width();\n        if (_.options.variableWidth === false) _.$slideTrack.children('.slick-slide').width(_.slideWidth - offset);\n\n    };\n\n    Slick.prototype.setFade = function() {\n\n        var _ = this,\n            targetLeft;\n\n        _.$slides.each(function(index, element) {\n            targetLeft = (_.slideWidth * index) * -1;\n            if (_.options.rtl === true) {\n                $(element).css({\n                    position: 'relative',\n                    right: targetLeft,\n                    top: 0,\n                    zIndex: _.options.zIndex - 2,\n                    opacity: 0\n                });\n            } else {\n                $(element).css({\n                    position: 'relative',\n                    left: targetLeft,\n                    top: 0,\n                    zIndex: _.options.zIndex - 2,\n                    opacity: 0\n                });\n            }\n        });\n\n        _.$slides.eq(_.currentSlide).css({\n            zIndex: _.options.zIndex - 1,\n            opacity: 1\n        });\n\n    };\n\n    Slick.prototype.setHeight = function() {\n\n        var _ = this;\n\n        if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {\n            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);\n            _.$list.css('height', targetHeight);\n        }\n\n    };\n\n    Slick.prototype.setOption =\n    Slick.prototype.slickSetOption = function() {\n\n        /**\n         * accepts arguments in format of:\n         *\n         *  - for changing a single option's value:\n         *     .slick(\"setOption\", option, value, refresh )\n         *\n         *  - for changing a set of responsive options:\n         *     .slick(\"setOption\", 'responsive', [{}, ...], refresh )\n         *\n         *  - for updating multiple values at once (not responsive)\n         *     .slick(\"setOption\", { 'option': value, ... }, refresh )\n         */\n\n        var _ = this, l, item, option, value, refresh = false, type;\n\n        if( $.type( arguments[0] ) === 'object' ) {\n\n            option =  arguments[0];\n            refresh = arguments[1];\n            type = 'multiple';\n\n        } else if ( $.type( arguments[0] ) === 'string' ) {\n\n            option =  arguments[0];\n            value = arguments[1];\n            refresh = arguments[2];\n\n            if ( arguments[0] === 'responsive' && $.type( arguments[1] ) === 'array' ) {\n\n                type = 'responsive';\n\n            } else if ( typeof arguments[1] !== 'undefined' ) {\n\n                type = 'single';\n\n            }\n\n        }\n\n        if ( type === 'single' ) {\n\n            _.options[option] = value;\n\n\n        } else if ( type === 'multiple' ) {\n\n            $.each( option , function( opt, val ) {\n\n                _.options[opt] = val;\n\n            });\n\n\n        } else if ( type === 'responsive' ) {\n\n            for ( item in value ) {\n\n                if( $.type( _.options.responsive ) !== 'array' ) {\n\n                    _.options.responsive = [ value[item] ];\n\n                } else {\n\n                    l = _.options.responsive.length-1;\n\n                    // loop through the responsive object and splice out duplicates.\n                    while( l >= 0 ) {\n\n                        if( _.options.responsive[l].breakpoint === value[item].breakpoint ) {\n\n                            _.options.responsive.splice(l,1);\n\n                        }\n\n                        l--;\n\n                    }\n\n                    _.options.responsive.push( value[item] );\n\n                }\n\n            }\n\n        }\n\n        if ( refresh ) {\n\n            _.unload();\n            _.reinit();\n\n        }\n\n    };\n\n    Slick.prototype.setPosition = function() {\n\n        var _ = this;\n\n        _.setDimensions();\n\n        _.setHeight();\n\n        if (_.options.fade === false) {\n            _.setCSS(_.getLeft(_.currentSlide));\n        } else {\n            _.setFade();\n        }\n\n        _.$slider.trigger('setPosition', [_]);\n\n    };\n\n    Slick.prototype.setProps = function() {\n\n        var _ = this,\n            bodyStyle = document.body.style;\n\n        _.positionProp = _.options.vertical === true ? 'top' : 'left';\n\n        if (_.positionProp === 'top') {\n            _.$slider.addClass('slick-vertical');\n        } else {\n            _.$slider.removeClass('slick-vertical');\n        }\n\n        if (bodyStyle.WebkitTransition !== undefined ||\n            bodyStyle.MozTransition !== undefined ||\n            bodyStyle.msTransition !== undefined) {\n            if (_.options.useCSS === true) {\n                _.cssTransitions = true;\n            }\n        }\n\n        if ( _.options.fade ) {\n            if ( typeof _.options.zIndex === 'number' ) {\n                if( _.options.zIndex < 3 ) {\n                    _.options.zIndex = 3;\n                }\n            } else {\n                _.options.zIndex = _.defaults.zIndex;\n            }\n        }\n\n        if (bodyStyle.OTransform !== undefined) {\n            _.animType = 'OTransform';\n            _.transformType = '-o-transform';\n            _.transitionType = 'OTransition';\n            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;\n        }\n        if (bodyStyle.MozTransform !== undefined) {\n            _.animType = 'MozTransform';\n            _.transformType = '-moz-transform';\n            _.transitionType = 'MozTransition';\n            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.MozPerspective === undefined) _.animType = false;\n        }\n        if (bodyStyle.webkitTransform !== undefined) {\n            _.animType = 'webkitTransform';\n            _.transformType = '-webkit-transform';\n            _.transitionType = 'webkitTransition';\n            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;\n        }\n        if (bodyStyle.msTransform !== undefined) {\n            _.animType = 'msTransform';\n            _.transformType = '-ms-transform';\n            _.transitionType = 'msTransition';\n            if (bodyStyle.msTransform === undefined) _.animType = false;\n        }\n        if (bodyStyle.transform !== undefined && _.animType !== false) {\n            _.animType = 'transform';\n            _.transformType = 'transform';\n            _.transitionType = 'transition';\n        }\n        _.transformsEnabled = _.options.useTransform && (_.animType !== null && _.animType !== false);\n    };\n\n\n    Slick.prototype.setSlideClasses = function(index) {\n\n        var _ = this,\n            centerOffset, allSlides, indexOffset, remainder;\n\n        allSlides = _.$slider\n            .find('.slick-slide')\n            .removeClass('slick-active slick-center slick-current')\n            .attr('aria-hidden', 'true');\n\n        _.$slides\n            .eq(index)\n            .addClass('slick-current');\n\n        if (_.options.centerMode === true) {\n\n            var evenCoef = _.options.slidesToShow % 2 === 0 ? 1 : 0;\n\n            centerOffset = Math.floor(_.options.slidesToShow / 2);\n\n            if (_.options.infinite === true) {\n\n                if (index >= centerOffset && index <= (_.slideCount - 1) - centerOffset) {\n                    _.$slides\n                        .slice(index - centerOffset + evenCoef, index + centerOffset + 1)\n                        .addClass('slick-active')\n                        .attr('aria-hidden', 'false');\n\n                } else {\n\n                    indexOffset = _.options.slidesToShow + index;\n                    allSlides\n                        .slice(indexOffset - centerOffset + 1 + evenCoef, indexOffset + centerOffset + 2)\n                        .addClass('slick-active')\n                        .attr('aria-hidden', 'false');\n\n                }\n\n                if (index === 0) {\n\n                    allSlides\n                        .eq(allSlides.length - 1 - _.options.slidesToShow)\n                        .addClass('slick-center');\n\n                } else if (index === _.slideCount - 1) {\n\n                    allSlides\n                        .eq(_.options.slidesToShow)\n                        .addClass('slick-center');\n\n                }\n\n            }\n\n            _.$slides\n                .eq(index)\n                .addClass('slick-center');\n\n        } else {\n\n            if (index >= 0 && index <= (_.slideCount - _.options.slidesToShow)) {\n\n                _.$slides\n                    .slice(index, index + _.options.slidesToShow)\n                    .addClass('slick-active')\n                    .attr('aria-hidden', 'false');\n\n            } else if (allSlides.length <= _.options.slidesToShow) {\n\n                allSlides\n                    .addClass('slick-active')\n                    .attr('aria-hidden', 'false');\n\n            } else {\n\n                remainder = _.slideCount % _.options.slidesToShow;\n                indexOffset = _.options.infinite === true ? _.options.slidesToShow + index : index;\n\n                if (_.options.slidesToShow == _.options.slidesToScroll && (_.slideCount - index) < _.options.slidesToShow) {\n\n                    allSlides\n                        .slice(indexOffset - (_.options.slidesToShow - remainder), indexOffset + remainder)\n                        .addClass('slick-active')\n                        .attr('aria-hidden', 'false');\n\n                } else {\n\n                    allSlides\n                        .slice(indexOffset, indexOffset + _.options.slidesToShow)\n                        .addClass('slick-active')\n                        .attr('aria-hidden', 'false');\n\n                }\n\n            }\n\n        }\n\n        if (_.options.lazyLoad === 'ondemand' || _.options.lazyLoad === 'anticipated') {\n            _.lazyLoad();\n        }\n    };\n\n    Slick.prototype.setupInfinite = function() {\n\n        var _ = this,\n            i, slideIndex, infiniteCount;\n\n        if (_.options.fade === true) {\n            _.options.centerMode = false;\n        }\n\n        if (_.options.infinite === true && _.options.fade === false) {\n\n            slideIndex = null;\n\n            if (_.slideCount > _.options.slidesToShow) {\n\n                if (_.options.centerMode === true) {\n                    infiniteCount = _.options.slidesToShow + 1;\n                } else {\n                    infiniteCount = _.options.slidesToShow;\n                }\n\n                for (i = _.slideCount; i > (_.slideCount -\n                        infiniteCount); i -= 1) {\n                    slideIndex = i - 1;\n                    $(_.$slides[slideIndex]).clone(true).attr('id', '')\n                        .attr('data-slick-index', slideIndex - _.slideCount)\n                        .prependTo(_.$slideTrack).addClass('slick-cloned');\n                }\n                for (i = 0; i < infiniteCount  + _.slideCount; i += 1) {\n                    slideIndex = i;\n                    $(_.$slides[slideIndex]).clone(true).attr('id', '')\n                        .attr('data-slick-index', slideIndex + _.slideCount)\n                        .appendTo(_.$slideTrack).addClass('slick-cloned');\n                }\n                _.$slideTrack.find('.slick-cloned').find('[id]').each(function() {\n                    $(this).attr('id', '');\n                });\n\n            }\n\n        }\n\n    };\n\n    Slick.prototype.interrupt = function( toggle ) {\n\n        var _ = this;\n\n        if( !toggle ) {\n            _.autoPlay();\n        }\n        _.interrupted = toggle;\n\n    };\n\n    Slick.prototype.selectHandler = function(event) {\n\n        var _ = this;\n\n        var targetElement =\n            $(event.target).is('.slick-slide') ?\n                $(event.target) :\n                $(event.target).parents('.slick-slide');\n\n        var index = parseInt(targetElement.attr('data-slick-index'));\n\n        if (!index) index = 0;\n\n        if (_.slideCount <= _.options.slidesToShow) {\n\n            _.slideHandler(index, false, true);\n            return;\n\n        }\n\n        _.slideHandler(index);\n\n    };\n\n    Slick.prototype.slideHandler = function(index, sync, dontAnimate) {\n\n        var targetSlide, animSlide, oldSlide, slideLeft, targetLeft = null,\n            _ = this, navTarget;\n\n        sync = sync || false;\n\n        if (_.animating === true && _.options.waitForAnimate === true) {\n            return;\n        }\n\n        if (_.options.fade === true && _.currentSlide === index) {\n            return;\n        }\n\n        if (sync === false) {\n            _.asNavFor(index);\n        }\n\n        targetSlide = index;\n        targetLeft = _.getLeft(targetSlide);\n        slideLeft = _.getLeft(_.currentSlide);\n\n        _.currentLeft = _.swipeLeft === null ? slideLeft : _.swipeLeft;\n\n        if (_.options.infinite === false && _.options.centerMode === false && (index < 0 || index > _.getDotCount() * _.options.slidesToScroll)) {\n            if (_.options.fade === false) {\n                targetSlide = _.currentSlide;\n                if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {\n                    _.animateSlide(slideLeft, function() {\n                        _.postSlide(targetSlide);\n                    });\n                } else {\n                    _.postSlide(targetSlide);\n                }\n            }\n            return;\n        } else if (_.options.infinite === false && _.options.centerMode === true && (index < 0 || index > (_.slideCount - _.options.slidesToScroll))) {\n            if (_.options.fade === false) {\n                targetSlide = _.currentSlide;\n                if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {\n                    _.animateSlide(slideLeft, function() {\n                        _.postSlide(targetSlide);\n                    });\n                } else {\n                    _.postSlide(targetSlide);\n                }\n            }\n            return;\n        }\n\n        if ( _.options.autoplay ) {\n            clearInterval(_.autoPlayTimer);\n        }\n\n        if (targetSlide < 0) {\n            if (_.slideCount % _.options.slidesToScroll !== 0) {\n                animSlide = _.slideCount - (_.slideCount % _.options.slidesToScroll);\n            } else {\n                animSlide = _.slideCount + targetSlide;\n            }\n        } else if (targetSlide >= _.slideCount) {\n            if (_.slideCount % _.options.slidesToScroll !== 0) {\n                animSlide = 0;\n            } else {\n                animSlide = targetSlide - _.slideCount;\n            }\n        } else {\n            animSlide = targetSlide;\n        }\n\n        _.animating = true;\n\n        _.$slider.trigger('beforeChange', [_, _.currentSlide, animSlide]);\n\n        oldSlide = _.currentSlide;\n        _.currentSlide = animSlide;\n\n        _.setSlideClasses(_.currentSlide);\n\n        if ( _.options.asNavFor ) {\n\n            navTarget = _.getNavTarget();\n            navTarget = navTarget.slick('getSlick');\n\n            if ( navTarget.slideCount <= navTarget.options.slidesToShow ) {\n                navTarget.setSlideClasses(_.currentSlide);\n            }\n\n        }\n\n        _.updateDots();\n        _.updateArrows();\n\n        if (_.options.fade === true) {\n            if (dontAnimate !== true) {\n\n                _.fadeSlideOut(oldSlide);\n\n                _.fadeSlide(animSlide, function() {\n                    _.postSlide(animSlide);\n                });\n\n            } else {\n                _.postSlide(animSlide);\n            }\n            _.animateHeight();\n            return;\n        }\n\n        if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {\n            _.animateSlide(targetLeft, function() {\n                _.postSlide(animSlide);\n            });\n        } else {\n            _.postSlide(animSlide);\n        }\n\n    };\n\n    Slick.prototype.startLoad = function() {\n\n        var _ = this;\n\n        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {\n\n            _.$prevArrow.hide();\n            _.$nextArrow.hide();\n\n        }\n\n        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {\n\n            _.$dots.hide();\n\n        }\n\n        _.$slider.addClass('slick-loading');\n\n    };\n\n    Slick.prototype.swipeDirection = function() {\n\n        var xDist, yDist, r, swipeAngle, _ = this;\n\n        xDist = _.touchObject.startX - _.touchObject.curX;\n        yDist = _.touchObject.startY - _.touchObject.curY;\n        r = Math.atan2(yDist, xDist);\n\n        swipeAngle = Math.round(r * 180 / Math.PI);\n        if (swipeAngle < 0) {\n            swipeAngle = 360 - Math.abs(swipeAngle);\n        }\n\n        if ((swipeAngle <= 45) && (swipeAngle >= 0)) {\n            return (_.options.rtl === false ? 'left' : 'right');\n        }\n        if ((swipeAngle <= 360) && (swipeAngle >= 315)) {\n            return (_.options.rtl === false ? 'left' : 'right');\n        }\n        if ((swipeAngle >= 135) && (swipeAngle <= 225)) {\n            return (_.options.rtl === false ? 'right' : 'left');\n        }\n        if (_.options.verticalSwiping === true) {\n            if ((swipeAngle >= 35) && (swipeAngle <= 135)) {\n                return 'down';\n            } else {\n                return 'up';\n            }\n        }\n\n        return 'vertical';\n\n    };\n\n    Slick.prototype.swipeEnd = function(event) {\n\n        var _ = this,\n            slideCount,\n            direction;\n\n        _.dragging = false;\n        _.swiping = false;\n\n        if (_.scrolling) {\n            _.scrolling = false;\n            return false;\n        }\n\n        _.interrupted = false;\n        _.shouldClick = ( _.touchObject.swipeLength > 10 ) ? false : true;\n\n        if ( _.touchObject.curX === undefined ) {\n            return false;\n        }\n\n        if ( _.touchObject.edgeHit === true ) {\n            _.$slider.trigger('edge', [_, _.swipeDirection() ]);\n        }\n\n        if ( _.touchObject.swipeLength >= _.touchObject.minSwipe ) {\n\n            direction = _.swipeDirection();\n\n            switch ( direction ) {\n\n                case 'left':\n                case 'down':\n\n                    slideCount =\n                        _.options.swipeToSlide ?\n                            _.checkNavigable( _.currentSlide + _.getSlideCount() ) :\n                            _.currentSlide + _.getSlideCount();\n\n                    _.currentDirection = 0;\n\n                    break;\n\n                case 'right':\n                case 'up':\n\n                    slideCount =\n                        _.options.swipeToSlide ?\n                            _.checkNavigable( _.currentSlide - _.getSlideCount() ) :\n                            _.currentSlide - _.getSlideCount();\n\n                    _.currentDirection = 1;\n\n                    break;\n\n                default:\n\n\n            }\n\n            if( direction != 'vertical' ) {\n\n                _.slideHandler( slideCount );\n                _.touchObject = {};\n                _.$slider.trigger('swipe', [_, direction ]);\n\n            }\n\n        } else {\n\n            if ( _.touchObject.startX !== _.touchObject.curX ) {\n\n                _.slideHandler( _.currentSlide );\n                _.touchObject = {};\n\n            }\n\n        }\n\n    };\n\n    Slick.prototype.swipeHandler = function(event) {\n\n        var _ = this;\n\n        if ((_.options.swipe === false) || ('ontouchend' in document && _.options.swipe === false)) {\n            return;\n        } else if (_.options.draggable === false && event.type.indexOf('mouse') !== -1) {\n            return;\n        }\n\n        _.touchObject.fingerCount = event.originalEvent && event.originalEvent.touches !== undefined ?\n            event.originalEvent.touches.length : 1;\n\n        _.touchObject.minSwipe = _.listWidth / _.options\n            .touchThreshold;\n\n        if (_.options.verticalSwiping === true) {\n            _.touchObject.minSwipe = _.listHeight / _.options\n                .touchThreshold;\n        }\n\n        switch (event.data.action) {\n\n            case 'start':\n                _.swipeStart(event);\n                break;\n\n            case 'move':\n                _.swipeMove(event);\n                break;\n\n            case 'end':\n                _.swipeEnd(event);\n                break;\n\n        }\n\n    };\n\n    Slick.prototype.swipeMove = function(event) {\n\n        var _ = this,\n            edgeWasHit = false,\n            curLeft, swipeDirection, swipeLength, positionOffset, touches, verticalSwipeLength;\n\n        touches = event.originalEvent !== undefined ? event.originalEvent.touches : null;\n\n        if (!_.dragging || _.scrolling || touches && touches.length !== 1) {\n            return false;\n        }\n\n        curLeft = _.getLeft(_.currentSlide);\n\n        _.touchObject.curX = touches !== undefined ? touches[0].pageX : event.clientX;\n        _.touchObject.curY = touches !== undefined ? touches[0].pageY : event.clientY;\n\n        _.touchObject.swipeLength = Math.round(Math.sqrt(\n            Math.pow(_.touchObject.curX - _.touchObject.startX, 2)));\n\n        verticalSwipeLength = Math.round(Math.sqrt(\n            Math.pow(_.touchObject.curY - _.touchObject.startY, 2)));\n\n        if (!_.options.verticalSwiping && !_.swiping && verticalSwipeLength > 4) {\n            _.scrolling = true;\n            return false;\n        }\n\n        if (_.options.verticalSwiping === true) {\n            _.touchObject.swipeLength = verticalSwipeLength;\n        }\n\n        swipeDirection = _.swipeDirection();\n\n        if (event.originalEvent !== undefined && _.touchObject.swipeLength > 4) {\n            _.swiping = true;\n            event.preventDefault();\n        }\n\n        positionOffset = (_.options.rtl === false ? 1 : -1) * (_.touchObject.curX > _.touchObject.startX ? 1 : -1);\n        if (_.options.verticalSwiping === true) {\n            positionOffset = _.touchObject.curY > _.touchObject.startY ? 1 : -1;\n        }\n\n\n        swipeLength = _.touchObject.swipeLength;\n\n        _.touchObject.edgeHit = false;\n\n        if (_.options.infinite === false) {\n            if ((_.currentSlide === 0 && swipeDirection === 'right') || (_.currentSlide >= _.getDotCount() && swipeDirection === 'left')) {\n                swipeLength = _.touchObject.swipeLength * _.options.edgeFriction;\n                _.touchObject.edgeHit = true;\n            }\n        }\n\n        if (_.options.vertical === false) {\n            _.swipeLeft = curLeft + swipeLength * positionOffset;\n        } else {\n            _.swipeLeft = curLeft + (swipeLength * (_.$list.height() / _.listWidth)) * positionOffset;\n        }\n        if (_.options.verticalSwiping === true) {\n            _.swipeLeft = curLeft + swipeLength * positionOffset;\n        }\n\n        if (_.options.fade === true || _.options.touchMove === false) {\n            return false;\n        }\n\n        if (_.animating === true) {\n            _.swipeLeft = null;\n            return false;\n        }\n\n        _.setCSS(_.swipeLeft);\n\n    };\n\n    Slick.prototype.swipeStart = function(event) {\n\n        var _ = this,\n            touches;\n\n        _.interrupted = true;\n\n        if (_.touchObject.fingerCount !== 1 || _.slideCount <= _.options.slidesToShow) {\n            _.touchObject = {};\n            return false;\n        }\n\n        if (event.originalEvent !== undefined && event.originalEvent.touches !== undefined) {\n            touches = event.originalEvent.touches[0];\n        }\n\n        _.touchObject.startX = _.touchObject.curX = touches !== undefined ? touches.pageX : event.clientX;\n        _.touchObject.startY = _.touchObject.curY = touches !== undefined ? touches.pageY : event.clientY;\n\n        _.dragging = true;\n\n    };\n\n    Slick.prototype.unfilterSlides = Slick.prototype.slickUnfilter = function() {\n\n        var _ = this;\n\n        if (_.$slidesCache !== null) {\n\n            _.unload();\n\n            _.$slideTrack.children(this.options.slide).detach();\n\n            _.$slidesCache.appendTo(_.$slideTrack);\n\n            _.reinit();\n\n        }\n\n    };\n\n    Slick.prototype.unload = function() {\n\n        var _ = this;\n\n        $('.slick-cloned', _.$slider).remove();\n\n        if (_.$dots) {\n            _.$dots.remove();\n        }\n\n        if (_.$prevArrow && _.htmlExpr.test(_.options.prevArrow)) {\n            _.$prevArrow.remove();\n        }\n\n        if (_.$nextArrow && _.htmlExpr.test(_.options.nextArrow)) {\n            _.$nextArrow.remove();\n        }\n\n        _.$slides\n            .removeClass('slick-slide slick-active slick-visible slick-current')\n            .attr('aria-hidden', 'true')\n            .css('width', '');\n\n    };\n\n    Slick.prototype.unslick = function(fromBreakpoint) {\n\n        var _ = this;\n        _.$slider.trigger('unslick', [_, fromBreakpoint]);\n        _.destroy();\n\n    };\n\n    Slick.prototype.updateArrows = function() {\n\n        var _ = this,\n            centerOffset;\n\n        centerOffset = Math.floor(_.options.slidesToShow / 2);\n\n        if ( _.options.arrows === true &&\n            _.slideCount > _.options.slidesToShow &&\n            !_.options.infinite ) {\n\n            _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');\n            _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');\n\n            if (_.currentSlide === 0) {\n\n                _.$prevArrow.addClass('slick-disabled').attr('aria-disabled', 'true');\n                _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');\n\n            } else if (_.currentSlide >= _.slideCount - _.options.slidesToShow && _.options.centerMode === false) {\n\n                _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');\n                _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');\n\n            } else if (_.currentSlide >= _.slideCount - 1 && _.options.centerMode === true) {\n\n                _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');\n                _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');\n\n            }\n\n        }\n\n    };\n\n    Slick.prototype.updateDots = function() {\n\n        var _ = this;\n\n        if (_.$dots !== null) {\n\n            _.$dots\n                .find('li')\n                    .removeClass('slick-active')\n                    .end();\n\n            _.$dots\n                .find('li')\n                .eq(Math.floor(_.currentSlide / _.options.slidesToScroll))\n                .addClass('slick-active');\n\n        }\n\n    };\n\n    Slick.prototype.visibility = function() {\n\n        var _ = this;\n\n        if ( _.options.autoplay ) {\n\n            if ( document[_.hidden] ) {\n\n                _.interrupted = true;\n\n            } else {\n\n                _.interrupted = false;\n\n            }\n\n        }\n\n    };\n\n    $.fn.slick = function() {\n        var _ = this,\n            opt = arguments[0],\n            args = Array.prototype.slice.call(arguments, 1),\n            l = _.length,\n            i,\n            ret;\n        for (i = 0; i < l; i++) {\n            if (typeof opt == 'object' || typeof opt == 'undefined')\n                _[i].slick = new Slick(_[i], opt);\n            else\n                ret = _[i].slick[opt].apply(_[i].slick, args);\n            if (typeof ret != 'undefined') return ret;\n        }\n        return _;\n    };\n\n}));"},393:function(t,n,e){e(7)(e(394))},394:function(t,n){t.exports='/*!\n * @copyright Copyright (c) 2017 IcoMoon.io\n * @license   Licensed under MIT license\n *            See https://github.com/Keyamoon/svgxuse\n * @version   1.2.2\n */\n/*jslint browser: true */\n/*global XDomainRequest, MutationObserver, window */\n(function () {\n    "use strict";\n    if (window && window.addEventListener) {\n        var cache = Object.create(null); // holds xhr objects to prevent multiple requests\n        var checkUseElems;\n        var tid; // timeout id\n        var debouncedCheck = function () {\n            clearTimeout(tid);\n            tid = setTimeout(checkUseElems, 100);\n        };\n        var unobserveChanges = function () {\n            return;\n        };\n        var observeChanges = function () {\n            var observer;\n            window.addEventListener("resize", debouncedCheck, false);\n            window.addEventListener("orientationchange", debouncedCheck, false);\n            if (window.MutationObserver) {\n                observer = new MutationObserver(debouncedCheck);\n                observer.observe(document.documentElement, {\n                    childList: true,\n                    subtree: true,\n                    attributes: true\n                });\n                unobserveChanges = function () {\n                    try {\n                        observer.disconnect();\n                        window.removeEventListener("resize", debouncedCheck, false);\n                        window.removeEventListener("orientationchange", debouncedCheck, false);\n                    } catch (ignore) {}\n                };\n            } else {\n                document.documentElement.addEventListener("DOMSubtreeModified", debouncedCheck, false);\n                unobserveChanges = function () {\n                    document.documentElement.removeEventListener("DOMSubtreeModified", debouncedCheck, false);\n                    window.removeEventListener("resize", debouncedCheck, false);\n                    window.removeEventListener("orientationchange", debouncedCheck, false);\n                };\n            }\n        };\n        var createRequest = function (url) {\n            // In IE 9, cross origin requests can only be sent using XDomainRequest.\n            // XDomainRequest would fail if CORS headers are not set.\n            // Therefore, XDomainRequest should only be used with cross origin requests.\n            function getOrigin(loc) {\n                var a;\n                if (loc.protocol !== undefined) {\n                    a = loc;\n                } else {\n                    a = document.createElement("a");\n                    a.href = loc;\n                }\n                return a.protocol.replace(/:/g, "") + a.host;\n            }\n            var Request;\n            var origin;\n            var origin2;\n            if (window.XMLHttpRequest) {\n                Request = new XMLHttpRequest();\n                origin = getOrigin(location);\n                origin2 = getOrigin(url);\n                if (Request.withCredentials === undefined && origin2 !== "" && origin2 !== origin) {\n                    Request = XDomainRequest || undefined;\n                } else {\n                    Request = XMLHttpRequest;\n                }\n            }\n            return Request;\n        };\n        var xlinkNS = "http://www.w3.org/1999/xlink";\n        checkUseElems = function () {\n            var base;\n            var bcr;\n            var fallback = ""; // optional fallback URL in case no base path to SVG file was given and no symbol definition was found.\n            var hash;\n            var href;\n            var i;\n            var inProgressCount = 0;\n            var isHidden;\n            var isXlink = false;\n            var Request;\n            var url;\n            var uses;\n            var xhr;\n            function observeIfDone() {\n                // If done with making changes, start watching for chagnes in DOM again\n                inProgressCount -= 1;\n                if (inProgressCount === 0) { // if all xhrs were resolved\n                    unobserveChanges(); // make sure to remove old handlers\n                    observeChanges(); // watch for changes to DOM\n                }\n            }\n            function attrUpdateFunc(spec) {\n                return function () {\n                    if (cache[spec.base] !== true) {\n                        if (spec.isXlink) {\n                            spec.useEl.setAttributeNS(xlinkNS, "xlink:href", "#" + spec.hash);\n                        } else {\n                            spec.useEl.setAttribute("href", "#" + spec.hash);\n                        }\n                    }\n                };\n            }\n            function onloadFunc(xhr) {\n                return function () {\n                    var body = document.body;\n                    var x = document.createElement("x");\n                    var svg;\n                    xhr.onload = null;\n                    x.innerHTML = xhr.responseText;\n                    svg = x.getElementsByTagName("svg")[0];\n                    if (svg) {\n                        svg.setAttribute("aria-hidden", "true");\n                        svg.style.position = "absolute";\n                        svg.style.width = 0;\n                        svg.style.height = 0;\n                        svg.style.overflow = "hidden";\n                        body.insertBefore(svg, body.firstChild);\n                    }\n                    observeIfDone();\n                };\n            }\n            function onErrorTimeout(xhr) {\n                return function () {\n                    xhr.onerror = null;\n                    xhr.ontimeout = null;\n                    observeIfDone();\n                };\n            }\n            unobserveChanges(); // stop watching for changes to DOM\n            // find all use elements\n            uses = document.getElementsByTagName("use");\n            for (i = 0; i < uses.length; i += 1) {\n                try {\n                    bcr = uses[i].getBoundingClientRect();\n                } catch (ignore) {\n                    // failed to get bounding rectangle of the use element\n                    bcr = false;\n                }\n                href = uses[i].getAttribute("href");\n                if (!href) {\n                    href = uses[i].getAttributeNS(xlinkNS, "href");\n                    isXlink = true;\n                } else {\n                    isXlink = false;\n                }\n                if (href && href.split) {\n                    url = href.split("#");\n                } else {\n                    url = ["", ""];\n                }\n                base = url[0];\n                hash = url[1];\n                isHidden = bcr && bcr.left === 0 && bcr.right === 0 && bcr.top === 0 && bcr.bottom === 0;\n                if (bcr && bcr.width === 0 && bcr.height === 0 && !isHidden) {\n                    // the use element is empty\n                    // if there is a reference to an external SVG, try to fetch it\n                    // use the optional fallback URL if there is no reference to an external SVG\n                    if (fallback && !base.length && hash && !document.getElementById(hash)) {\n                        base = fallback;\n                    }\n                    if (base.length) {\n                        // schedule updating xlink:href\n                        xhr = cache[base];\n                        if (xhr !== true) {\n                            // true signifies that prepending the SVG was not required\n                            setTimeout(attrUpdateFunc({\n                                useEl: uses[i],\n                                base: base,\n                                hash: hash,\n                                isXlink: isXlink\n                            }), 0);\n                        }\n                        if (xhr === undefined) {\n                            Request = createRequest(base);\n                            if (Request !== undefined) {\n                                xhr = new Request();\n                                cache[base] = xhr;\n                                xhr.onload = onloadFunc(xhr);\n                                xhr.onerror = onErrorTimeout(xhr);\n                                xhr.ontimeout = onErrorTimeout(xhr);\n                                xhr.open("GET", base);\n                                xhr.send();\n                                inProgressCount += 1;\n                            }\n                        }\n                    }\n                } else {\n                    if (!isHidden) {\n                        if (cache[base] === undefined) {\n                            // remember this URL if the use element was not empty and no request was sent\n                            cache[base] = true;\n                        } else if (cache[base].onload) {\n                            // if it turns out that prepending the SVG is not necessary,\n                            // abort the in-progress xhr.\n                            cache[base].abort();\n                            delete cache[base].onload;\n                            cache[base] = true;\n                        }\n                    } else if (base.length && cache[base]) {\n                        setTimeout(attrUpdateFunc({\n                            useEl: uses[i],\n                            base: base,\n                            hash: hash,\n                            isXlink: isXlink\n                        }), 0);\n                    }\n                }\n            }\n            uses = "";\n            inProgressCount += 1;\n            observeIfDone();\n        };\n        // The load event fires when all resources have finished loading, which allows detecting whether SVG use elements are empty.\n        window.addEventListener("load", function winLoad() {\n            window.removeEventListener("load", winLoad, false); // to prevent memory leaks\n            tid = setTimeout(checkUseElems, 0);\n        }, false);\n    }\n}());\n'},395:function(t,n,e){e(7)(e(396))},396:function(t,n){t.exports='/*! Tablesaw - v3.0.1 - 2017-06-01\n* https://github.com/filamentgroup/tablesaw\n* Copyright (c) 2017 Filament Group; Licensed MIT */\n(function( win ) {\n\t"use strict";\n\n\tvar $;\n\tif( \'shoestring\' in win ) {\n\t\t$ = win.shoestring;\n\t} else if( \'jQuery\' in win ) {\n\t\t$ = win.jQuery;\n\t} else {\n\t\tthrow new Error( "tablesaw: DOM library not found." );\n\t}\n\n\t// DOM-ready auto-init of plugins.\n\t// Many plugins bind to an "enhance" event to init themselves on dom ready, or when new markup is inserted into the DOM\n\t// Use raw DOMContentLoaded instead of shoestring (may have issues in Android 2.3, exhibited by stack table)\n\tif( "addEventListener" in document ) {\n\t\tdocument.addEventListener( "DOMContentLoaded", function() {\n\t\t\t$( document ).trigger( "enhance.tablesaw" );\n\t\t});\n\t}\n\n})( typeof window !== "undefined" ? window : this );'},397:function(t,n,e){e(7)(e(398))},398:function(t,n){t.exports='/*! Tablesaw - v3.0.1 - 2017-06-01\n* https://github.com/filamentgroup/tablesaw\n* Copyright (c) 2017 Filament Group; Licensed MIT */\n// UMD module definition\n// From: https://github.com/umdjs/umd/blob/master/templates/jqueryPlugin.js\n\n(function (factory) {\n\tif (typeof define === \'function\' && define.amd) {\n\t\t\t// AMD. Register as an anonymous module.\n\t\t\tdefine([\'jquery\'], factory);\n\t} else if (typeof module === \'object\' && module.exports) {\n\t\t// Node/CommonJS\n\t\tmodule.exports = function( root, jQuery ) {\n\t\t\tif ( jQuery === undefined ) {\n\t\t\t\t// require(\'jQuery\') returns a factory that requires window to\n\t\t\t\t// build a jQuery instance, we normalize how we use modules\n\t\t\t\t// that require this pattern but the window provided is a noop\n\t\t\t\t// if it\'s defined (how jquery works)\n\t\t\t\tif ( typeof window !== \'undefined\' ) {\n\t\t\t\t\tjQuery = require(\'jquery\');\n\t\t\t\t} else {\n\t\t\t\t\tjQuery = require(\'jquery\')(root);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfactory(jQuery);\n\t\t\treturn jQuery;\n\t\t};\n\t} else {\n\t\t// Browser globals\n\t\tfactory(jQuery);\n\t}\n}(function ($) {\n\t"use strict";\n\n\tvar win = typeof window !== "undefined" ? window : this;\n\nvar Tablesaw = {\n\ti18n: {\n\t\tmodes: [ \'Stack\', \'Swipe\', \'Toggle\' ],\n\t\tcolumns: \'Col<span class=\\"a11y-sm\\">umn</span>s\',\n\t\tcolumnBtnText: \'Columns\',\n\t\tcolumnsDialogError: \'No eligible columns.\',\n\t\tsort: \'Sort\'\n\t},\n\t// cut the mustard\n\tmustard: ( \'head\' in document ) && // IE9+, Firefox 4+, Safari 5.1+, Mobile Safari 4.1+, Opera 11.5+, Android 2.3+\n\t\t( !window.blackberry || window.WebKitPoint ) && // only WebKit Blackberry (OS 6+)\n\t\t!window.operamini\n};\n\nif( Tablesaw.mustard ) {\n\t$( document.documentElement ).addClass( \'tablesaw-enhanced\' );\n}\n\n(function() {\n\tvar pluginName = "tablesaw";\n\tvar classes = {\n\t\ttoolbar: "tablesaw-bar"\n\t};\n\tvar events = {\n\t\tcreate: "tablesawcreate",\n\t\tdestroy: "tablesawdestroy",\n\t\trefresh: "tablesawrefresh",\n\t\tresize: "tablesawresize"\n\t};\n\tvar defaultMode = "stack";\n\tvar initSelector = "table";\n\tvar initFilterSelector = "[data-tablesaw],[data-tablesaw-mode],[data-tablesaw-sortable]";\n\tvar defaultConfig = {};\n\n\tTablesaw.events = events;\n\n\tvar Table = function( element ) {\n\t\tif( !element ) {\n\t\t\tthrow new Error( "Tablesaw requires an element." );\n\t\t}\n\n\t\tthis.table = element;\n\t\tthis.$table = $( element );\n\n\t\t// only one <thead> and <tfoot> are allowed, per the specification\n\t\tthis.$thead = this.$table.children().filter( "thead" ).eq( 0 );\n\n\t\t// multiple <tbody> are allowed, per the specification\n\t\tthis.$tbody = this.$table.children().filter( "tbody" );\n\n\t\tthis.mode = this.$table.attr( "data-tablesaw-mode" ) || defaultMode;\n\n\t\tthis.$toolbar = null;\n\n\t\tthis.init();\n\t};\n\n\tTable.prototype.init = function() {\n\t\t// assign an id if there is none\n\t\tif ( !this.$table.attr( "id" ) ) {\n\t\t\tthis.$table.attr( "id", pluginName + "-" + Math.round( Math.random() * 10000 ) );\n\t\t}\n\n\t\tthis.createToolbar();\n\n\t\tthis._initCells();\n\n\t\tthis.$table.data( pluginName, this );\n\n\t\tthis.$table.trigger( events.create, [ this ] );\n\t};\n\n\tTable.prototype.getConfig = function( pluginSpecificConfig ) {\n\t\t// shoestring extend doesn’t support arbitrary args\n\t\tvar configs = $.extend( defaultConfig, pluginSpecificConfig || {} );\n\t\treturn $.extend( configs, typeof TablesawConfig !== "undefined" ? TablesawConfig : {} );\n\t};\n\n\tTable.prototype._getPrimaryHeaderRow = function() {\n\t\treturn this._getHeaderRows().eq( 0 );\n\t};\n\n\tTable.prototype._getHeaderRows = function() {\n\t\treturn this.$thead.children().filter( "tr" ).filter(function() {\n\t\t\treturn !$( this ).is( "[data-tablesaw-ignorerow]" );\n\t\t});\n\t};\n\n\tTable.prototype._getRowIndex = function( $row ) {\n\t\treturn $row.prevAll().length;\n\t};\n\n\tTable.prototype._getHeaderRowIndeces = function() {\n\t\tvar self = this;\n\t\tvar indeces = [];\n\t\tthis._getHeaderRows().each(function() {\n\t\t\tindeces.push( self._getRowIndex( $( this ) ) );\n\t\t});\n\t\treturn indeces;\n\t};\n\n\tTable.prototype._getPrimaryHeaderCells = function( $row ) {\n\t\treturn ( $row || this._getPrimaryHeaderRow() ).find( "th" );\n\t};\n\n\tTable.prototype._findPrimaryHeadersForCell = function( cell ) {\n\t\tvar $headerRow = this._getPrimaryHeaderRow();\n\t\tvar $headers = this._getPrimaryHeaderCells( $headerRow );\n\t\tvar headerRowIndex = this._getRowIndex( $headerRow );\n\t\tvar results = [];\n\n\t\tfor( var rowNumber = 0; rowNumber < this.headerMapping.length; rowNumber++ ) {\n\t\t\tif( rowNumber === headerRowIndex ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor( var colNumber = 0; colNumber < this.headerMapping[ rowNumber ].length; colNumber++ ) {\n\t\t\t\tif( this.headerMapping[ rowNumber ][ colNumber ] === cell ) {\n\t\t\t\t\tresults.push( $headers[ colNumber ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t};\n\n\t// used by init cells\n\tTable.prototype.getRows = function() {\n\t\tvar self = this;\n\t\treturn this.$table.find( "tr" ).filter(function() {\n\t\t\treturn $( this ).closest( "table" ).is( self.$table );\n\t\t});\n\t};\n\n\t// used by sortable\n\tTable.prototype.getBodyRows = function( tbody ) {\n\t\treturn ( tbody ? $( tbody ) : this.$tbody ).children().filter( "tr" );\n\t};\n\n\tTable.prototype.getHeaderCellIndex = function( cell ) {\n\t\tvar lookup = this.headerMapping[ 0 ];\n\t\tfor( var colIndex = 0; colIndex < lookup.length; colIndex++ ) {\n\t\t\tif( lookup[ colIndex ] === cell ) {\n\t\t\t\treturn colIndex;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t};\n\n\tTable.prototype._initCells = function() {\n\t\tvar $rows = this.getRows();\n\t\tvar columnLookup = [];\n\n\t\t$rows.each(function( rowNumber ) {\n\t\t\tcolumnLookup[ rowNumber ] = [];\n\t\t});\n\n\t\t$rows.each(function( rowNumber ) {\n\t\t\tvar coltally = 0;\n\t\t\tvar $t = $( this );\n\t\t\tvar children = $t.children();\n\n\t\t\tchildren.each(function() {\n\t\t\t\tvar colspan = parseInt( this.getAttribute( "colspan" ), 10 );\n\t\t\t\tvar rowspan = parseInt( this.getAttribute( "rowspan" ), 10 );\n\n\t\t\t\t// set in a previous rowspan\n\t\t\t\twhile( columnLookup[ rowNumber ][ coltally ] ) {\n\t\t\t\t\tcoltally++;\n\t\t\t\t}\n\n\t\t\t\tcolumnLookup[ rowNumber ][ coltally ] = this;\n\n\t\t\t\t// TODO? both colspan and rowspan\n\t\t\t\tif( colspan ) {\n\t\t\t\t\tfor( var k = 0; k < colspan - 1; k++ ){\n\t\t\t\t\t\tcoltally++;\n\t\t\t\t\t\tcolumnLookup[ rowNumber ][ coltally ] = this;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( rowspan ) {\n\t\t\t\t\tfor( var j = 1; j < rowspan; j++ ){\n\t\t\t\t\t\tcolumnLookup[ rowNumber + j ][ coltally ] = this;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcoltally++;\n\t\t\t});\n\t\t});\n\n\t\tvar headerRowIndeces = this._getHeaderRowIndeces();\n\t\tfor( var colNumber = 0; colNumber < columnLookup[ 0 ].length; colNumber++ ) {\n\t\t\tfor( var headerIndex = 0, k = headerRowIndeces.length; headerIndex < k; headerIndex++ ) {\n\t\t\t\tvar headerCol = columnLookup[ headerRowIndeces[ headerIndex ] ][ colNumber ];\n\n\t\t\t\tvar rowNumber = headerRowIndeces[ headerIndex ];\n\t\t\t\tvar rowCell;\n\n\t\t\t\tif( !headerCol.cells ) {\n\t\t\t\t\theaderCol.cells = [];\n\t\t\t\t}\n\n\t\t\t\twhile( rowNumber < columnLookup.length ) {\n\t\t\t\t\trowCell = columnLookup[ rowNumber ][ colNumber ];\n\n\t\t\t\t\tif( headerCol !== rowCell ) {\n\t\t\t\t\t\theaderCol.cells.push( rowCell );\n\t\t\t\t\t}\n\n\t\t\t\t\trowNumber++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.headerMapping = columnLookup;\n\t};\n\n\tTable.prototype.refresh = function() {\n\t\tthis._initCells();\n\n\t\tthis.$table.trigger( events.refresh, [ this ] );\n\t};\n\n\tTable.prototype._getToolbarAnchor = function() {\n\t\tvar $parent = this.$table.parent();\n\t\tif( $parent.is( ".tablesaw-overflow" ) ) {\n\t\t\treturn $parent;\n\t\t}\n\t\treturn this.$table;\n\t};\n\n\tTable.prototype._getToolbar = function( $anchor ) {\n\t\tif( !$anchor ) {\n\t\t\t$anchor = this._getToolbarAnchor();\n\t\t}\n\t\treturn $anchor.prev().filter( "." + classes.toolbar );\n\t};\n\n\tTable.prototype.createToolbar = function() {\n\t\t// Insert the toolbar\n\t\t// TODO move this into a separate component\n\t\tvar $anchor = this._getToolbarAnchor();\n\t\tvar $toolbar = this._getToolbar( $anchor );\n\t\tif( !$toolbar.length ) {\n\t\t\t$toolbar = $( \'<div>\' )\n\t\t\t\t.addClass( classes.toolbar )\n\t\t\t\t.insertBefore( $anchor );\n\t\t}\n\t\tthis.$toolbar = $toolbar;\n\n\t\tif( this.mode ) {\n\t\t\tthis.$toolbar.addClass( \'tablesaw-mode-\' + this.mode );\n\t\t}\n\t};\n\n\tTable.prototype.destroy = function() {\n\t\t// Don’t remove the toolbar, just erase the classes on it.\n\t\t// Some of the table features are not yet destroy-friendly.\n\t\tthis._getToolbar().each(function() {\n\t\t\tthis.className = this.className.replace( /\\btablesaw-mode\\-\\w*\\b/gi, \'\' );\n\t\t});\n\n\t\tvar tableId = this.$table.attr( \'id\' );\n\t\t$( document ).off( "." + tableId );\n\t\t$( window ).off( "." + tableId );\n\n\t\t// other plugins\n\t\tthis.$table.trigger( events.destroy, [ this ] );\n\n\t\tthis.$table.removeData( pluginName );\n\t};\n\n\t// Collection method.\n\t$.fn[ pluginName ] = function() {\n\t\treturn this.each( function() {\n\t\t\tvar $t = $( this );\n\n\t\t\tif( $t.data( pluginName ) ){\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tnew Table( this );\n\t\t});\n\t};\n\n\tvar $doc = $( win.document );\n\t$doc.on( "enhance.tablesaw", function( e ) {\n\t\t// Cut the mustard\n\t\tif( Tablesaw.mustard ) {\n\t\t\t$( e.target ).find( initSelector ).filter( initFilterSelector )[ pluginName ]();\n\t\t}\n\t});\n\n\t// Avoid a resize during scroll:\n\t// Some Mobile devices trigger a resize during scroll (sometimes when\n\t// doing elastic stretch at the end of the document or from the \n\t// location bar hide)\n\tvar isScrolling = false;\n\tvar scrollTimeout;\n\t$doc.on( "scroll.tablesaw", function() {\n\t\tisScrolling = true;\n\n\t\twin.clearTimeout( scrollTimeout );\n\t\tscrollTimeout = win.setTimeout(function() {\n\t\t\tisScrolling = false;\n\t\t}, 300 ); // must be greater than the resize timeout below\n\t});\n\n\tvar resizeTimeout;\n\t$( win ).on( "resize", function() {\n\t\tif( !isScrolling ) {\n\t\t\twin.clearTimeout( resizeTimeout );\n\t\t\tresizeTimeout = win.setTimeout(function() {\n\t\t\t\t$doc.trigger( events.resize );\n\t\t\t}, 150 ); // must be less than the scrolling timeout above.\n\t\t}\n\t});\n\n}());\n\n(function(){\n\n\tvar classes = {\n\t\tstackTable: \'tablesaw-stack\',\n\t\tcellLabels: \'tablesaw-cell-label\',\n\t\tcellContentLabels: \'tablesaw-cell-content\'\n\t};\n\n\tvar data = {\n\t\tkey: \'tablesaw-stack\'\n\t};\n\n\tvar attrs = {\n\t\tlabelless: \'data-tablesaw-no-labels\',\n\t\thideempty: \'data-tablesaw-hide-empty\'\n\t};\n\n\tvar Stack = function( element, tablesaw ) {\n\n\t\tthis.tablesaw = tablesaw;\n\t\tthis.$table = $( element );\n\n\t\tthis.labelless = this.$table.is( \'[\' + attrs.labelless + \']\' );\n\t\tthis.hideempty = this.$table.is( \'[\' + attrs.hideempty + \']\' );\n\n\t\tthis.$table.data( data.key, this );\n\t};\n\n\tStack.prototype.init = function() {\n\t\tthis.$table.addClass( classes.stackTable );\n\n\t\tif( this.labelless ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar self = this;\n\n\t\tthis.$table.find( "th, td" ).filter(function() {\n\t\t\treturn !$( this ).closest( "thead" ).length;\n\t\t}).filter(function() {\n\t\t\treturn !$( this ).closest( "tr" ).is( "[" + attrs.labelless + "]" ) &&\n\t\t\t\t( !self.hideempty || !!$( this ).html() );\n\t\t}).each(function() {\n\t\t\tvar $newHeader = $( document.createElement( "b" ) ).addClass( classes.cellLabels );\n\t\t\tvar $cell = $( this );\n\n\t\t\t$( self.tablesaw._findPrimaryHeadersForCell( this ) ).each(function( index ) {\n\t\t\t\tvar $header = $( this.cloneNode( true ) );\n\t\t\t\t// TODO decouple from sortable better\n\t\t\t\t// Changed from .text() in https://github.com/filamentgroup/tablesaw/commit/b9c12a8f893ec192830ec3ba2d75f062642f935b\n\t\t\t\t// to preserve structural html in headers, like <a>\n\t\t\t\tvar $sortableButton = $header.find( ".tablesaw-sortable-btn" );\n\t\t\t\t$header.find( ".tablesaw-sortable-arrow" ).remove();\n\n\t\t\t\t// TODO decouple from checkall better\n\t\t\t\tvar $checkall = $header.find( "[data-tablesaw-checkall]" );\n\t\t\t\t$checkall.closest( "label" ).remove();\n\t\t\t\tif( $checkall.length ) {\n\t\t\t\t\t$newHeader = $([]);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif( index > 0 ) {\n\t\t\t\t\t$newHeader.append( document.createTextNode( ", " ) );\n\t\t\t\t}\n\t\t\t\t$newHeader.append( $sortableButton.length ? $sortableButton[ 0 ].childNodes : $header[ 0 ].childNodes );\n\t\t\t});\n\n\t\t\tif( $newHeader.length && !$cell.find( "." + classes.cellContentLabels ).length ) {\n\t\t\t\t$cell.wrapInner( "<span class=\'" + classes.cellContentLabels + "\'></span>" );\n\t\t\t}\n\n\t\t\t// Update if already exists.\n\t\t\tvar $label = $cell.find( "." + classes.cellLabels );\n\t\t\tif( !$label.length ) {\n\t\t\t\t$cell.prepend( $newHeader );\n\t\t\t} else { // only if changed\n\t\t\t\t$label.replaceWith( $newHeader );\n\t\t\t}\n\t\t});\n\t};\n\n\tStack.prototype.destroy = function() {\n\t\tthis.$table.removeClass( classes.stackTable );\n\t\tthis.$table.find( \'.\' + classes.cellLabels ).remove();\n\t\tthis.$table.find( \'.\' + classes.cellContentLabels ).each(function() {\n\t\t\t$( this ).replaceWith( this.childNodes );\n\t\t});\n\t};\n\n\t// on tablecreate, init\n\t$( document ).on( Tablesaw.events.create, function( e, tablesaw ){\n\t\tif( tablesaw.mode === \'stack\' ){\n\t\t\tvar table = new Stack( tablesaw.table, tablesaw );\n\t\t\ttable.init();\n\t\t}\n\t}).on( Tablesaw.events.refresh, function( e, tablesaw ){\n\t\tif( tablesaw.mode === \'stack\' ){\n\t\t\t$( tablesaw.table ).data( data.key ).init();\n\t\t}\n\t}).on( Tablesaw.events.destroy, function( e, tablesaw ){\n\t\tif( tablesaw.mode === \'stack\' ){\n\t\t\t$( tablesaw.table ).data( data.key ).destroy();\n\t\t}\n\t});\n\n}());\n(function() {\n\tvar pluginName = "tablesawbtn",\n\t\tmethods = {\n\t\t\t_create: function(){\n\t\t\t\treturn $( this ).each(function() {\n\t\t\t\t\t$( this )\n\t\t\t\t\t\t.trigger( "beforecreate." + pluginName )[ pluginName ]( "_init" )\n\t\t\t\t\t\t.trigger( "create." + pluginName );\n\t\t\t\t});\n\t\t\t},\n\t\t\t_init: function(){\n\t\t\t\tvar oEl = $( this ),\n\t\t\t\t\tsel = this.getElementsByTagName( "select" )[ 0 ];\n\n\t\t\t\tif( sel ) {\n\t\t\t\t\t// TODO next major version: remove .btn-select\n\t\t\t\t\t$( this )\n\t\t\t\t\t\t.addClass( "btn-select tablesaw-btn-select" )[ pluginName ]( "_select", sel );\n\t\t\t\t}\n\t\t\t\treturn oEl;\n\t\t\t},\n\t\t\t_select: function( sel ) {\n\t\t\t\tvar update = function( oEl, sel ) {\n\t\t\t\t\tvar opts = $( sel ).find( "option" );\n\t\t\t\t\tvar label = document.createElement( "span" );\n\t\t\t\t\tvar el;\n\t\t\t\t\tvar children;\n\t\t\t\t\tvar found = false;\n\n\t\t\t\t\tlabel.setAttribute( "aria-hidden", "true" );\n\t\t\t\t\tlabel.innerHTML = "&#160;";\n\n\t\t\t\t\topts.each(function() {\n\t\t\t\t\t\tvar opt = this;\n\t\t\t\t\t\tif( opt.selected ) {\n\t\t\t\t\t\t\tlabel.innerHTML = opt.text;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tchildren = oEl.childNodes;\n\t\t\t\t\tif( opts.length > 0 ){\n\t\t\t\t\t\tfor( var i = 0, l = children.length; i < l; i++ ) {\n\t\t\t\t\t\t\tel = children[ i ];\n\n\t\t\t\t\t\t\tif( el && el.nodeName.toUpperCase() === "SPAN" ) {\n\t\t\t\t\t\t\t\toEl.replaceChild( label, el );\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif( !found ) {\n\t\t\t\t\t\t\toEl.insertBefore( label, oEl.firstChild );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tupdate( this, sel );\n\t\t\t\t$( this ).on( "change refresh", function() {\n\t\t\t\t\tupdate( this, sel );\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t// Collection method.\n\t$.fn[ pluginName ] = function( arrg, a, b, c ) {\n\t\treturn this.each(function() {\n\n\t\t\t// if it\'s a method\n\t\t\tif( arrg && typeof( arrg ) === "string" ){\n\t\t\t\treturn $.fn[ pluginName ].prototype[ arrg ].call( this, a, b, c );\n\t\t\t}\n\n\t\t\t// don\'t re-init\n\t\t\tif( $( this ).data( pluginName + "active" ) ){\n\t\t\t\treturn $( this );\n\t\t\t}\n\n\t\t\t$( this ).data( pluginName + "active", true );\n\n\t\t\t$.fn[ pluginName ].prototype._create.call( this );\n\t\t});\n\t};\n\n\t// add methods\n\t$.extend( $.fn[ pluginName ].prototype, methods );\n\n}());\n(function(){\n\n\tvar data = {\n\t\tkey: "tablesaw-coltoggle"\n\t};\n\n\tvar ColumnToggle = function( element ) {\n\n\t\tthis.$table = $( element );\n\n\t\tif( !this.$table.length ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.tablesaw = this.$table.data( "tablesaw" );\n\n\t\tthis.attributes = {\n\t\t\tsubrow: "data-tablesaw-subrow",\n\t\t\tignorerow: "data-tablesaw-ignorerow",\n\t\t\tbtnTarget: \'data-tablesaw-columntoggle-btn-target\',\n\t\t\tset: \'data-tablesaw-columntoggle-set\'\n\t\t};\n\n\t\tthis.classes = {\n\t\t\tcolumnToggleTable: \'tablesaw-columntoggle\',\n\t\t\tcolumnBtnContain: \'tablesaw-columntoggle-btnwrap tablesaw-advance\',\n\t\t\tcolumnBtn: \'tablesaw-columntoggle-btn tablesaw-nav-btn down\',\n\t\t\tpopup: \'tablesaw-columntoggle-popup\',\n\t\t\tpriorityPrefix: \'tablesaw-priority-\'\n\t\t};\n\n\t\tthis.set = [];\n\t\tthis.$headers = this.tablesaw._getPrimaryHeaderCells();\n\n\t\tthis.$table.data( data.key, this );\n\t};\n\n\t// Column Toggle Sets (one column chooser can control multiple tables)\n\tColumnToggle.prototype.initSet = function() {\n\t\tvar set = this.$table.attr( this.attributes.set );\n\t\tif( set ) {\n\t\t\t// Should not include the current table\n\t\t\tvar table = this.$table[ 0 ];\n\t\t\tthis.set = $( "table[" + this.attributes.set + "=\'" + set + "\']" ).filter(function() {\n\t\t\t\treturn this !== table;\n\t\t\t}).get();\n\t\t}\n\t};\n\n\tColumnToggle.prototype.init = function() {\n\n\t\tif( !this.$table.length ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar tableId,\n\t\t\tid,\n\t\t\t$menuButton,\n\t\t\t$popup,\n\t\t\t$menu,\n\t\t\t$btnContain,\n\t\t\tself = this;\n\n\t\tvar cfg = this.tablesaw.getConfig({\n\t\t\tgetColumnToggleLabelTemplate: function( text ) {\n\t\t\t\treturn "<label><input type=\'checkbox\' checked>" + text + "</label>";\n\t\t\t}\n\t\t});\n\n\t\tthis.$table.addClass( this.classes.columnToggleTable );\n\n\t\ttableId = this.$table.attr( "id" );\n\t\tid = tableId + "-popup";\n\t\t$btnContain = $( "<div class=\'" + this.classes.columnBtnContain + "\'></div>" );\n\t\t// TODO next major version: remove .btn\n\t\t$menuButton = $( "<a href=\'#" + id + "\' class=\'btn tablesaw-btn btn-micro " + this.classes.columnBtn +"\' data-popup-link>" +\n\t\t\t\t\t\t\t\t\t\t"<span>" + Tablesaw.i18n.columnBtnText + "</span></a>" );\n\t\t$popup = $( "<div class=\'" + this.classes.popup + "\' id=\'" + id + "\'></div>" );\n\t\t$menu = $( "<div class=\'btn-group\'></div>" );\n\n\t\tthis.$popup = $popup;\n\n\t\tvar hasNonPersistentHeaders = false;\n\t\tthis.$headers.each( function() {\n\t\t\tvar $this = $( this ),\n\t\t\t\tpriority = $this.attr("data-tablesaw-priority"),\n\t\t\t\t$cells = self.$getCells( this );\n\n\t\t\tif( priority && priority !== "persist" ) {\n\t\t\t\t$cells.addClass( self.classes.priorityPrefix + priority );\n\n\t\t\t\t$( cfg.getColumnToggleLabelTemplate( $this.text() ) )\n\t\t\t\t\t.appendTo( $menu )\n\t\t\t\t\t.find( "input[type=\\"checkbox\\"]" )\n\t\t\t\t\t.data( "tablesaw-header", this );\n\n\t\t\t\thasNonPersistentHeaders = true;\n\t\t\t}\n\t\t});\n\n\t\tif( !hasNonPersistentHeaders ) {\n\t\t\t$menu.append( \'<label>\' + Tablesaw.i18n.columnsDialogError + \'</label>\' );\n\t\t}\n\n\t\t$menu.appendTo( $popup );\n\n\t\tfunction onToggleCheckboxChange( checkbox ) {\n\t\t\tvar checked = checkbox.checked;\n\n\t\t\tvar header = self.getHeaderFromCheckbox( checkbox );\n\t\t\tvar $cells = self.$getCells( header );\n\n\t\t\t$cells[ !checked ? "addClass" : "removeClass" ]( "tablesaw-cell-hidden" );\n\t\t\t$cells[ checked ? "addClass" : "removeClass" ]( "tablesaw-cell-visible" );\n\n\t\t\tself.updateColspanIgnoredRows( checked, $( header ).add( header.cells ) );\n\n\t\t\tself.$table.trigger( \'tablesawcolumns\' );\n\t\t}\n\n\t\t// bind change event listeners to inputs - TODO: move to a private method?\n\t\t$menu.find( \'input[type="checkbox"]\' ).on( "change", function(e) {\n\t\t\tonToggleCheckboxChange( e.target );\n\n\t\t\tif( self.set.length ) {\n\t\t\t\tvar index;\n\t\t\t\t$( self.$popup ).find( "input[type=\'checkbox\']" ).each(function( j ) {\n\t\t\t\t\tif( this === e.target ) {\n\t\t\t\t\t\tindex = j;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t$( self.set ).each(function() {\n\t\t\t\t\tvar checkbox = $( this ).data( data.key ).$popup.find( "input[type=\'checkbox\']" ).get( index );\n\t\t\t\t\tif( checkbox ) {\n\t\t\t\t\t\tcheckbox.checked = e.target.checked;\n\t\t\t\t\t\tonToggleCheckboxChange( checkbox );\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\t$menuButton.appendTo( $btnContain );\n\n\t\t// Use a different target than the toolbar\n\t\tvar $btnTarget = $( this.$table.attr( this.attributes.btnTarget ) );\n\t\t$btnContain.appendTo( $btnTarget.length ? $btnTarget : this.tablesaw.$toolbar );\n\n\t\tfunction closePopup( event ) {\n\t\t\t// Click came from inside the popup, ignore.\n\t\t\tif( event && $( event.target ).closest( "." + self.classes.popup ).length ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t$( document ).off( \'click.\' + tableId );\n\t\t\t$menuButton.removeClass( \'up\' ).addClass( \'down\' );\n\t\t\t$btnContain.removeClass( \'visible\' );\n\t\t}\n\n\t\tvar closeTimeout;\n\t\tfunction openPopup() {\n\t\t\t$btnContain.addClass( \'visible\' );\n\t\t\t$menuButton.removeClass( \'down\' ).addClass( \'up\' );\n\n\t\t\t$( document ).off( \'click.\' + tableId, closePopup );\n\n\t\t\twindow.clearTimeout( closeTimeout );\n\t\t\tcloseTimeout = window.setTimeout(function() {\n\t\t\t\t$( document ).on( \'click.\' + tableId, closePopup );\n\t\t\t}, 15 );\n\t\t}\n\n\t\t$menuButton.on( "click.tablesaw", function( event ) {\n\t\t\tevent.preventDefault();\n\n\t\t\tif( !$btnContain.is( ".visible" ) ) {\n\t\t\t\topenPopup();\n\t\t\t} else {\n\t\t\t\tclosePopup();\n\t\t\t}\n\t\t});\n\n\t\t$popup.appendTo( $btnContain );\n\n\t\tthis.$menu = $menu;\n\n\t\t// Fix for iOS not rendering shadows correctly when using `-webkit-overflow-scrolling`\n\t\tvar $overflow = this.$table.closest( ".tablesaw-overflow" );\n\t\tif( $overflow.css( "-webkit-overflow-scrolling" ) ) {\n\t\t\tvar timeout;\n\t\t\t$overflow.on( "scroll", function() {\n\t\t\t\tvar $div = $( this );\n\t\t\t\twindow.clearTimeout( timeout );\n\t\t\t\ttimeout = window.setTimeout(function() {\n\t\t\t\t\t$div.css( "-webkit-overflow-scrolling", "auto" );\n\t\t\t\t\twindow.setTimeout(function() {\n\t\t\t\t\t\t$div.css( "-webkit-overflow-scrolling", "touch" );\n\t\t\t\t\t}, 0 );\n\t\t\t\t}, 100 );\n\t\t\t});\n\t\t}\n\n\t\t$(window).on( Tablesaw.events.resize + "." + tableId, function(){\n\t\t\tself.refreshToggle();\n\t\t});\n\n\t\tthis.initSet();\n\t\tthis.refreshToggle();\n\t};\n\n\tColumnToggle.prototype.updateColspanIgnoredRows = function( invisibleColumnCount, $cells ) {\n\t\tthis.$table.find( "[" + this.attributes.subrow + "],[" + this.attributes.ignorerow + "]" ).each(function() {\n\t\t\tvar $t = $( this );\n\t\t\tvar $td = $t.find( "td[colspan]" ).eq( 0 );\n\t\t\tvar excludedInvisibleColumns;\n\n\t\t\tvar colspan;\n\t\t\tvar originalColspan;\n\t\t\tvar modifier;\n\n\t\t\t// increment or decrementing only (from a user triggered column show/hide)\n\t\t\tif( invisibleColumnCount === true || invisibleColumnCount === false ) {\n\t\t\t\t// unless the column being hidden is not included in the colspan\n\t\t\t\tmodifier = $cells.filter(function() {\n\t\t\t\t\treturn this === $td[ 0 ];\n\t\t\t\t}).length ? ( invisibleColumnCount ? 1 : -1 ) : 0;\n\n\t\t\t\tcolspan = parseInt( $td.attr( "colspan" ), 10 ) + modifier;\n\t\t\t} else {\n\t\t\t\t// triggered from a resize or init\n\t\t\t\toriginalColspan = $td.data( "original-colspan" );\n\n\t\t\t\tif( originalColspan ) {\n\t\t\t\t\tcolspan = originalColspan;\n\t\t\t\t} else {\n\t\t\t\t\tcolspan = parseInt( $td.attr( "colspan" ), 10 );\n\t\t\t\t\t$td.data( "original-colspan", colspan );\n\t\t\t\t}\n\n\t\t\t\texcludedInvisibleColumns = $t.find( "td" ).filter(function() {\n\t\t\t\t\treturn this !== $td[ 0 ] && $( this ).css( "display" ) === "none";\n\t\t\t\t}).length;\n\n\t\t\t\tcolspan -= ( invisibleColumnCount - excludedInvisibleColumns );\n\t\t\t}\n\n\t\t\t// TODO add a colstart param so that this more appropriately selects colspan elements based on the column being hidden.\n\t\t\t$td.attr( "colspan", colspan );\n\t\t});\n\t};\n\n\tColumnToggle.prototype.$getCells = function( th ) {\n\t\tvar self = this;\n\t\treturn $( th ).add( th.cells ).filter(function() {\n\t\t\tvar $t = $( this );\n\t\t\tvar $row = $t.parent();\n\t\t\tvar hasColspan = $t.is( "[colspan]" );\n\t\t\t// no subrows or ignored rows (keep cells in ignored rows that do not have a colspan)\n\t\t\treturn !$row.is( "[" + self.attributes.subrow + "]" ) &&\n\t\t\t\t( !$row.is( "[" + self.attributes.ignorerow + "]" ) || !hasColspan );\n\t\t});\n\t};\n\n\tColumnToggle.prototype.getHeaderFromCheckbox = function( checkbox ) {\n\t\treturn $( checkbox ).data( "tablesaw-header" );\n\t};\n\n\tColumnToggle.prototype.refreshToggle = function() {\n\t\tvar self = this;\n\t\tvar invisibleColumns = 0;\n\t\tthis.$menu.find( "input" ).each( function() {\n\t\t\tvar header = self.getHeaderFromCheckbox( this );\n\t\t\tvar isVisible = self.$getCells( header ).eq( 0 ).css( "display" ) === "table-cell";\n\t\t\tthis.checked = isVisible;\n\n\t\t\tif( !isVisible ) {\n\t\t\t\tinvisibleColumns++;\n\t\t\t}\n\t\t});\n\n\t\tthis.updateColspanIgnoredRows( invisibleColumns );\n\t};\n\n\tColumnToggle.prototype.destroy = function() {\n\t\tthis.$table.removeClass( this.classes.columnToggleTable );\n\t\tthis.$table.find( \'th, td\' ).each(function() {\n\t\t\tvar $cell = $( this );\n\t\t\t$cell.removeClass( \'tablesaw-cell-hidden\' )\n\t\t\t\t.removeClass( \'tablesaw-cell-visible\' );\n\n\t\t\tthis.className = this.className.replace( /\\bui\\-table\\-priority\\-\\d\\b/g, \'\' );\n\t\t});\n\t};\n\n\t// on tablecreate, init\n\t$( document ).on( Tablesaw.events.create, function( e, tablesaw ){\n\n\t\tif( tablesaw.mode === \'columntoggle\' ){\n\t\t\tvar table = new ColumnToggle( tablesaw.table );\n\t\t\ttable.init();\n\t\t}\n\n\t} );\n\n\t$( document ).on( Tablesaw.events.destroy, function( e, tablesaw ){\n\t\tif( tablesaw.mode === \'columntoggle\' ){\n\t\t\t$( tablesaw.table ).data( data.key ).destroy();\n\t\t}\n\t} );\n\n}());\n;(function() {\n\tfunction getSortValue( cell ) {\n\t\tvar text = [];\n\t\t$( cell.childNodes ).each(function() {\n\t\t\tvar $el = $( this );\n\t\t\tif( $el.is( \'input, select\' ) ) {\n\t\t\t\ttext.push( $el.val() );\n\t\t\t} else if( $el.is( \'.tablesaw-cell-label\' ) ) {\n\t\t\t} else {\n\t\t\t\ttext.push( ( $el.text() || \'\' ).replace(/^\\s+|\\s+$/g, \'\') );\n\t\t\t}\n\t\t});\n\n\t\treturn text.join( \'\' );\n\t}\n\n\tvar pluginName = "tablesaw-sortable",\n\t\tinitSelector = "table[data-" + pluginName + "]",\n\t\tsortableSwitchSelector = "[data-" + pluginName + "-switch]",\n\t\tattrs = {\n\t\t\tsortCol: "data-tablesaw-sortable-col",\n\t\t\tdefaultCol: "data-tablesaw-sortable-default-col",\n\t\t\tnumericCol: "data-tablesaw-sortable-numeric",\n\t\t\tsubRow: "data-tablesaw-subrow",\n\t\t\tignoreRow: "data-tablesaw-ignorerow"\n\t\t},\n\t\tclasses = {\n\t\t\thead: pluginName + "-head",\n\t\t\tascend: pluginName + "-ascending",\n\t\t\tdescend: pluginName + "-descending",\n\t\t\tswitcher: pluginName + "-switch",\n\t\t\ttableToolbar: \'tablesaw-bar-section\',\n\t\t\tsortButton: pluginName + "-btn"\n\t\t},\n\t\tmethods = {\n\t\t\t_create: function( o ){\n\t\t\t\treturn $( this ).each(function() {\n\t\t\t\t\tvar init = $( this ).data( pluginName + "-init" );\n\t\t\t\t\tif( init ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t$( this )\n\t\t\t\t\t\t.data( pluginName + "-init", true )\n\t\t\t\t\t\t.trigger( "beforecreate." + pluginName )\n\t\t\t\t\t\t[ pluginName ]( "_init" , o )\n\t\t\t\t\t\t.trigger( "create." + pluginName );\n\t\t\t\t});\n\t\t\t},\n\t\t\t_init: function(){\n\t\t\t\tvar el = $( this );\n\t\t\t\tvar tblsaw = el.data( "tablesaw" );\n\t\t\t\tvar heads;\n\t\t\t\tvar $switcher;\n\n\t\t\t\tfunction addClassToHeads( h ){\n\t\t\t\t\t$.each( h , function( i , v ){\n\t\t\t\t\t\t$( v ).addClass( classes.head );\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tfunction makeHeadsActionable( h , fn ){\n\t\t\t\t\t$.each( h , function( i , col ){\n\t\t\t\t\t\tvar b = $( "<button class=\'" + classes.sortButton + "\'/>" );\n\t\t\t\t\t\tb.on( "click" , { col: col } , fn );\n\t\t\t\t\t\t$( col ).wrapInner( b ).find( "button" ).append( "<span class=\'tablesaw-sortable-arrow\'>" );\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tfunction clearOthers( headcells ){\n\t\t\t\t\t$.each( headcells , function( i , v ){\n\t\t\t\t\t\tvar col = $( v );\n\t\t\t\t\t\tcol.removeAttr( attrs.defaultCol );\n\t\t\t\t\t\tcol.removeClass( classes.ascend );\n\t\t\t\t\t\tcol.removeClass( classes.descend );\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tfunction headsOnAction( e ){\n\t\t\t\t\tif( $( e.target ).is( \'a[href]\' ) ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\te.stopPropagation();\n\t\t\t\t\tvar headCell = $( e.target ).closest( "[" + attrs.sortCol + "]" ),\n\t\t\t\t\t\tv = e.data.col,\n\t\t\t\t\t\tnewSortValue = heads.index( headCell[0] );\n\n\t\t\t\t\tclearOthers( headCell.closest( "thead" ).find( "th" ).filter(function() {\n\t\t\t\t\t\treturn this !== headCell[ 0 ];\n\t\t\t\t\t}) );\n\t\t\t\t\tif( headCell.is( "." + classes.descend ) || !headCell.is( "." + classes.ascend ) ){\n\t\t\t\t\t\tel[ pluginName ]( "sortBy" , v , true);\n\t\t\t\t\t\tnewSortValue += \'_asc\';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tel[ pluginName ]( "sortBy" , v );\n\t\t\t\t\t\tnewSortValue += \'_desc\';\n\t\t\t\t\t}\n\t\t\t\t\tif( $switcher ) {\n\t\t\t\t\t\t$switcher.find( \'select\' ).val( newSortValue ).trigger( \'refresh\' );\n\t\t\t\t\t}\n\n\t\t\t\t\te.preventDefault();\n\t\t\t\t}\n\n\t\t\t\tfunction handleDefault( heads ){\n\t\t\t\t\t$.each( heads , function( idx , el ){\n\t\t\t\t\t\tvar $el = $( el );\n\t\t\t\t\t\tif( $el.is( "[" + attrs.defaultCol + "]" ) ){\n\t\t\t\t\t\t\tif( !$el.is( "." + classes.descend ) ) {\n\t\t\t\t\t\t\t\t$el.addClass( classes.ascend );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tfunction addSwitcher( heads ){\n\t\t\t\t\t$switcher = $( \'<div>\' ).addClass( classes.switcher ).addClass( classes.tableToolbar );\n\n\t\t\t\t\tvar html = [ \'<label>\' + Tablesaw.i18n.sort + \':\' ];\n\n\t\t\t\t\t// TODO next major version: remove .btn\n\t\t\t\t\thtml.push( \'<span class="btn tablesaw-btn"><select>\' );\n\t\t\t\t\theads.each(function( j ) {\n\t\t\t\t\t\tvar $t = $( this );\n\t\t\t\t\t\tvar isDefaultCol = $t.is( "[" + attrs.defaultCol + "]" );\n\t\t\t\t\t\tvar isDescending = $t.is( "." + classes.descend );\n\n\t\t\t\t\t\tvar hasNumericAttribute = $t.is( \'[\' + attrs.numericCol + \']\' );\n\t\t\t\t\t\tvar numericCount = 0;\n\t\t\t\t\t\t// Check only the first four rows to see if the column is numbers.\n\t\t\t\t\t\tvar numericCountMax = 5;\n\n\t\t\t\t\t\t$( this.cells.slice( 0, numericCountMax ) ).each(function() {\n\t\t\t\t\t\t\tif( !isNaN( parseInt( getSortValue( this ), 10 ) ) ) {\n\t\t\t\t\t\t\t\tnumericCount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tvar isNumeric = numericCount === numericCountMax;\n\t\t\t\t\t\tif( !hasNumericAttribute ) {\n\t\t\t\t\t\t\t$t.attr( attrs.numericCol, isNumeric ? "" : "false" );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\thtml.push( \'<option\' + ( isDefaultCol && !isDescending ? \' selected\' : \'\' ) + \' value="\' + j + \'_asc">\' + $t.text() + \' \' + ( isNumeric ? \'&#x2191;\' : \'(A-Z)\' ) + \'</option>\' );\n\t\t\t\t\t\thtml.push( \'<option\' + ( isDefaultCol && isDescending ? \' selected\' : \'\' ) + \' value="\' + j + \'_desc">\' + $t.text() + \' \' + ( isNumeric ? \'&#x2193;\' : \'(Z-A)\' ) + \'</option>\' );\n\t\t\t\t\t});\n\t\t\t\t\thtml.push( \'</select></span></label>\' );\n\n\t\t\t\t\t$switcher.html( html.join(\'\') );\n\n\t\t\t\t\tvar $firstChild = tblsaw.$toolbar.children().eq( 0 );\n\t\t\t\t\tif( $firstChild.length ) {\n\t\t\t\t\t\t$switcher.insertBefore( $firstChild );\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$switcher.appendTo( tblsaw.$toolbar );\n\t\t\t\t\t}\n\t\t\t\t\t$switcher.find( \'.tablesaw-btn\' ).tablesawbtn();\n\t\t\t\t\t$switcher.find( \'select\' ).on( \'change\', function() {\n\t\t\t\t\t\tvar val = $( this ).val().split( \'_\' ),\n\t\t\t\t\t\t\thead = heads.eq( val[ 0 ] );\n\n\t\t\t\t\t\tclearOthers( head.siblings() );\n\t\t\t\t\t\tel[ pluginName ]( \'sortBy\', head.get( 0 ), val[ 1 ] === \'asc\' );\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tel.addClass( pluginName );\n\n\t\t\t\theads = el.children().filter( "thead" ).find( "th[" + attrs.sortCol + "]" );\n\n\t\t\t\taddClassToHeads( heads );\n\t\t\t\tmakeHeadsActionable( heads , headsOnAction );\n\t\t\t\thandleDefault( heads );\n\n\t\t\t\tif( el.is( sortableSwitchSelector ) ) {\n\t\t\t\t\taddSwitcher( heads );\n\t\t\t\t}\n\t\t\t},\n\t\t\tsortRows: function( rows, colNum, ascending, col, tbody ){\n\t\t\t\tfunction convertCells( cellArr, belongingToTbody ){\n\t\t\t\t\tvar cells = [];\n\t\t\t\t\t$.each( cellArr, function( i , cell ){\n\t\t\t\t\t\tvar row = cell.parentNode;\n\t\t\t\t\t\tvar $row = $( row );\n\t\t\t\t\t\t// next row is a subrow\n\t\t\t\t\t\tvar subrows = [];\n\t\t\t\t\t\tvar $next = $row.next();\n\t\t\t\t\t\twhile( $next.is( "[" + attrs.subRow + "]" ) ) {\n\t\t\t\t\t\t\tsubrows.push( $next[ 0 ] );\n\t\t\t\t\t\t\t$next = $next.next();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar tbody = row.parentNode;\n\n\t\t\t\t\t\t// current row is a subrow\n\t\t\t\t\t\tif( $row.is( "[" + attrs.subRow + "]" ) ) {\n\t\t\t\t\t\t} else if( tbody === belongingToTbody ) {\n\t\t\t\t\t\t\tcells.push({\n\t\t\t\t\t\t\t\telement: cell,\n\t\t\t\t\t\t\t\tcell: getSortValue( cell ),\n\t\t\t\t\t\t\t\trow: row,\n\t\t\t\t\t\t\t\tsubrows: subrows.length ? subrows : null,\n\t\t\t\t\t\t\t\tignored: $row.is( "[" + attrs.ignoreRow + "]" )\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\treturn cells;\n\t\t\t\t}\n\n\t\t\t\tfunction getSortFxn( ascending, forceNumeric ){\n\t\t\t\t\tvar fn,\n\t\t\t\t\t\tregex = /[^\\-\\+\\d\\.]/g;\n\t\t\t\t\tif( ascending ){\n\t\t\t\t\t\tfn = function( a , b ){\n\t\t\t\t\t\t\tif( a.ignored || b.ignored ) {\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif( forceNumeric ) {\n\t\t\t\t\t\t\t\treturn parseFloat( a.cell.replace( regex, \'\' ) ) - parseFloat( b.cell.replace( regex, \'\' ) );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn a.cell.toLowerCase() > b.cell.toLowerCase() ? 1 : -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfn = function( a , b ){\n\t\t\t\t\t\t\tif( a.ignored || b.ignored ) {\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif( forceNumeric ) {\n\t\t\t\t\t\t\t\treturn parseFloat( b.cell.replace( regex, \'\' ) ) - parseFloat( a.cell.replace( regex, \'\' ) );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn a.cell.toLowerCase() < b.cell.toLowerCase() ? 1 : -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\treturn fn;\n\t\t\t\t}\n\n\t\t\t\tfunction convertToRows( sorted ) {\n\t\t\t\t\tvar newRows = [], i, l;\n\t\t\t\t\tfor( i = 0, l = sorted.length ; i < l ; i++ ){\n\t\t\t\t\t\tnewRows.push( sorted[ i ].row );\n\t\t\t\t\t\tif( sorted[ i ].subrows ) {\n\t\t\t\t\t\t\tnewRows.push( sorted[ i ].subrows );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn newRows;\n\t\t\t\t}\n\n\t\t\t\tvar fn;\n\t\t\t\tvar sorted;\n\t\t\t\tvar cells = convertCells( col.cells, tbody );\n\n\t\t\t\tvar customFn = $( col ).data( \'tablesaw-sort\' );\n\n\t\t\t\tfn = ( customFn && typeof customFn === "function" ? customFn( ascending ) : false ) ||\n\t\t\t\t\tgetSortFxn( ascending, $( col ).is( \'[\' + attrs.numericCol + \']\' ) && !$( col ).is( \'[\' + attrs.numericCol + \'="false"]\' ) );\n\n\t\t\t\tsorted = cells.sort( fn );\n\n\t\t\t\trows = convertToRows( sorted );\n\n\t\t\t\treturn rows;\n\t\t\t},\n\t\t\tmakeColDefault: function( col , a ){\n\t\t\t\tvar c = $( col );\n\t\t\t\tc.attr( attrs.defaultCol , "true" );\n\t\t\t\tif( a ){\n\t\t\t\t\tc.removeClass( classes.descend );\n\t\t\t\t\tc.addClass( classes.ascend );\n\t\t\t\t} else {\n\t\t\t\t\tc.removeClass( classes.ascend );\n\t\t\t\t\tc.addClass( classes.descend );\n\t\t\t\t}\n\t\t\t},\n\t\t\tsortBy: function( col , ascending ){\n\t\t\t\tvar el = $( this );\n\t\t\t\tvar colNum;\n\t\t\t\tvar tbl = el.data( "tablesaw" );\n\t\t\t\ttbl.$tbody.each(function() {\n\t\t\t\t\tvar tbody = this;\n\t\t\t\t\tvar $tbody = $( this );\n\t\t\t\t\tvar rows = tbl.getBodyRows( tbody );\n\t\t\t\t\tvar sortedRows;\n\t\t\t\t\tvar map = tbl.headerMapping[ 0 ];\n\t\t\t\t\tvar j, k;\n\n\t\t\t\t\t// find the column number that we’re sorting\n\t\t\t\t\tfor( j = 0, k = map.length; j < k; j++ ) {\n\t\t\t\t\t\tif( map[ j ] === col ) {\n\t\t\t\t\t\t\tcolNum = j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tsortedRows = el[ pluginName ]( "sortRows" , rows, colNum, ascending, col, tbody );\n\n\t\t\t\t\t// replace Table rows\n\t\t\t\t\tfor( j = 0, k = sortedRows.length; j < k; j++ ) {\n\t\t\t\t\t\t$tbody.append( sortedRows[ j ] );\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tel[ pluginName ]( "makeColDefault" , col , ascending );\n\n\t\t\t\tel.trigger( "tablesaw-sorted" );\n\t\t\t}\n\t\t};\n\n\t// Collection method.\n\t$.fn[ pluginName ] = function( arrg ) {\n\t\tvar args = Array.prototype.slice.call( arguments , 1),\n\t\t\treturnVal;\n\n\t\t// if it\'s a method\n\t\tif( arrg && typeof( arrg ) === "string" ){\n\t\t\treturnVal = $.fn[ pluginName ].prototype[ arrg ].apply( this[0], args );\n\t\t\treturn (typeof returnVal !== "undefined")? returnVal:$(this);\n\t\t}\n\t\t// check init\n\t\tif( !$( this ).data( pluginName + "-active" ) ){\n\t\t\t$( this ).data( pluginName + "-active", true );\n\t\t\t$.fn[ pluginName ].prototype._create.call( this , arrg );\n\t\t}\n\t\treturn $(this);\n\t};\n\t// add methods\n\t$.extend( $.fn[ pluginName ].prototype, methods );\n\n\t$( document ).on( Tablesaw.events.create, function( e, Tablesaw ) {\n\t\tif( Tablesaw.$table.is( initSelector ) ) {\n\t\t\tTablesaw.$table[ pluginName ]();\n\t\t}\n\t});\n\n}());\n\n(function(){\n\n\tvar classes = {\n\t\thideBtn: "disabled",\n\t\tpersistWidths: "tablesaw-fix-persist",\n\t\tallColumnsVisible: \'tablesaw-all-cols-visible\'\n\t};\n\tvar attrs = {\n\t\tdisableTouchEvents: "data-tablesaw-no-touch"\n\t};\n\n\tfunction createSwipeTable( tbl, $table ){\n\t\tvar tblsaw = $table.data( "tablesaw" );\n\n\t\tvar $btns = $( "<div class=\'tablesaw-advance\'></div>" );\n\t\t// TODO next major version: remove .btn\n\t\tvar $prevBtn = $( "<a href=\'#\' class=\'btn tablesaw-nav-btn tablesaw-btn btn-micro left\' title=\'Previous Column\'></a>" ).appendTo( $btns );\n\t\t// TODO next major version: remove .btn\n\t\tvar $nextBtn = $( "<a href=\'#\' class=\'btn tablesaw-nav-btn tablesaw-btn btn-micro right\' title=\'Next Column\'></a>" ).appendTo( $btns );\n\n\t\tvar $headerCells = tbl._getPrimaryHeaderCells();\n\t\tvar $headerCellsNoPersist = $headerCells.not( \'[data-tablesaw-priority="persist"]\' );\n\t\tvar headerWidths = [];\n\t\tvar $head = $( document.head || \'head\' );\n\t\tvar tableId = $table.attr( \'id\' );\n\n\t\tif( !$headerCells.length ) {\n\t\t\tthrow new Error( "tablesaw swipe: no header cells found. Are you using <th> inside of <thead>?" );\n\t\t}\n\n\t\t$table.addClass( "tablesaw-swipe" );\n\n\t\t// Calculate initial widths\n\t\t$headerCells.each(function() {\n\t\t\tvar width = this.offsetWidth;\n\t\t\theaderWidths.push( width );\n\t\t});\n\n\t\t$btns.appendTo( tblsaw.$toolbar );\n\n\t\tif( !tableId ) {\n\t\t\ttableId = \'tableswipe-\' + Math.round( Math.random() * 10000 );\n\t\t\t$table.attr( \'id\', tableId );\n\t\t}\n\n\t\tfunction $getCells( headerCell ) {\n\t\t\treturn $( headerCell.cells ).add( headerCell );\n\t\t}\n\n\t\tfunction showColumn( headerCell ) {\n\t\t\t$getCells( headerCell ).removeClass( \'tablesaw-cell-hidden\' );\n\t\t}\n\n\t\tfunction hideColumn( headerCell ) {\n\t\t\t$getCells( headerCell ).addClass( \'tablesaw-cell-hidden\' );\n\t\t}\n\n\t\tfunction persistColumn( headerCell ) {\n\t\t\t$getCells( headerCell ).addClass( \'tablesaw-cell-persist\' );\n\t\t}\n\n\t\tfunction isPersistent( headerCell ) {\n\t\t\treturn $( headerCell ).is( \'[data-tablesaw-priority="persist"]\' );\n\t\t}\n\n\t\tfunction unmaintainWidths() {\n\t\t\t$table.removeClass( classes.persistWidths );\n\t\t\t$( \'#\' + tableId + \'-persist\' ).remove();\n\t\t}\n\n\t\tfunction maintainWidths() {\n\t\t\tvar prefix = \'#\' + tableId + \'.tablesaw-swipe \',\n\t\t\t\tstyles = [],\n\t\t\t\ttableWidth = $table.width(),\n\t\t\t\thash = [],\n\t\t\t\tnewHash;\n\n\t\t\t// save persistent column widths (as long as they take up less than 75% of table width)\n\t\t\t$headerCells.each(function( index ) {\n\t\t\t\tvar width;\n\t\t\t\tif( isPersistent( this ) ) {\n\t\t\t\t\twidth = this.offsetWidth;\n\n\t\t\t\t\tif( width < tableWidth * 0.75 ) {\n\t\t\t\t\t\thash.push( index + \'-\' + width );\n\t\t\t\t\t\tstyles.push( prefix + \' .tablesaw-cell-persist:nth-child(\' + ( index + 1 ) + \') { width: \' + width + \'px; }\' );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tnewHash = hash.join( \'_\' );\n\n\t\t\tif( styles.length ) {\n\t\t\t\t$table.addClass( classes.persistWidths );\n\t\t\t\tvar $style = $( \'#\' + tableId + \'-persist\' );\n\t\t\t\t// If style element not yet added OR if the widths have changed\n\t\t\t\tif( !$style.length || $style.data( \'tablesaw-hash\' ) !== newHash ) {\n\t\t\t\t\t// Remove existing\n\t\t\t\t\t$style.remove();\n\n\t\t\t\t\t$( \'<style>\' + styles.join( "\\n" ) + \'</style>\' )\n\t\t\t\t\t\t.attr( \'id\', tableId + \'-persist\' )\n\t\t\t\t\t\t.data( \'tablesaw-hash\', newHash )\n\t\t\t\t\t\t.appendTo( $head );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction getNext(){\n\t\t\tvar next = [],\n\t\t\t\tcheckFound;\n\n\t\t\t$headerCellsNoPersist.each(function( i ) {\n\t\t\t\tvar $t = $( this ),\n\t\t\t\t\tisHidden = $t.css( "display" ) === "none" || $t.is( ".tablesaw-cell-hidden" );\n\n\t\t\t\tif( !isHidden && !checkFound ) {\n\t\t\t\t\tcheckFound = true;\n\t\t\t\t\tnext[ 0 ] = i;\n\t\t\t\t} else if( isHidden && checkFound ) {\n\t\t\t\t\tnext[ 1 ] = i;\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn next;\n\t\t}\n\n\t\tfunction getPrev(){\n\t\t\tvar next = getNext();\n\t\t\treturn [ next[ 1 ] - 1 , next[ 0 ] - 1 ];\n\t\t}\n\n\t\tfunction nextpair( fwd ){\n\t\t\treturn fwd ? getNext() : getPrev();\n\t\t}\n\n\t\tfunction canAdvance( pair ){\n\t\t\treturn pair[ 1 ] > -1 && pair[ 1 ] < $headerCellsNoPersist.length;\n\t\t}\n\n\t\tfunction matchesMedia() {\n\t\t\tvar matchMedia = $table.attr( "data-tablesaw-swipe-media" );\n\t\t\treturn !matchMedia || ( "matchMedia" in win ) && win.matchMedia( matchMedia ).matches;\n\t\t}\n\n\t\tfunction fakeBreakpoints() {\n\t\t\tif( !matchesMedia() ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar\tcontainerWidth = $table.parent().width(),\n\t\t\t\tpersist = [],\n\t\t\t\tsum = 0,\n\t\t\t\tsums = [],\n\t\t\t\tvisibleNonPersistantCount = $headerCells.length;\n\n\t\t\t$headerCells.each(function( index ) {\n\t\t\t\tvar $t = $( this ),\n\t\t\t\t\tisPersist = $t.is( \'[data-tablesaw-priority="persist"]\' );\n\n\t\t\t\tpersist.push( isPersist );\n\t\t\t\tsum += headerWidths[ index ];\n\t\t\t\tsums.push( sum );\n\n\t\t\t\t// is persistent or is hidden\n\t\t\t\tif( isPersist || sum > containerWidth ) {\n\t\t\t\t\tvisibleNonPersistantCount--;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// We need at least one column to swipe.\n\t\t\tvar needsNonPersistentColumn = visibleNonPersistantCount === 0;\n\n\t\t\t$headerCells.each(function( index ) {\n\t\t\t\tif( persist[ index ] ) {\n\n\t\t\t\t\t// for visual box-shadow\n\t\t\t\t\tpersistColumn( this );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif( sums[ index ] <= containerWidth || needsNonPersistentColumn ) {\n\t\t\t\t\tneedsNonPersistentColumn = false;\n\t\t\t\t\tshowColumn( this );\n\t\t\t\t} else {\n\t\t\t\t\thideColumn( this );\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tunmaintainWidths();\n\t\t\t$table.trigger( \'tablesawcolumns\' );\n\t\t}\n\n\t\tfunction advance( fwd ){\n\t\t\tvar pair = nextpair( fwd );\n\t\t\tif( canAdvance( pair ) ){\n\t\t\t\tif( isNaN( pair[ 0 ] ) ){\n\t\t\t\t\tif( fwd ){\n\t\t\t\t\t\tpair[0] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tpair[0] = $headerCellsNoPersist.length - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmaintainWidths();\n\n\t\t\t\thideColumn( $headerCellsNoPersist.get( pair[ 0 ] ) );\n\t\t\t\tshowColumn( $headerCellsNoPersist.get( pair[ 1 ] ) );\n\n\t\t\t\t$table.trigger( \'tablesawcolumns\' );\n\t\t\t}\n\t\t}\n\n\t\t$prevBtn.add( $nextBtn ).on( "click", function( e ){\n\t\t\tadvance( !!$( e.target ).closest( $nextBtn ).length );\n\t\t\te.preventDefault();\n\t\t});\n\n\t\tfunction getCoord( event, key ) {\n\t\t\treturn ( event.touches || event.originalEvent.touches )[ 0 ][ key ];\n\t\t}\n\n\t\tif( !$table.is( "[" + attrs.disableTouchEvents + "]" ) ) {\n\n\t\t\t$table\n\t\t\t\t.on( "touchstart.swipetoggle", function( e ){\n\t\t\t\t\tvar originX = getCoord( e, \'pageX\' );\n\t\t\t\t\tvar originY = getCoord( e, \'pageY\' );\n\t\t\t\t\tvar x;\n\t\t\t\t\tvar y;\n\t\t\t\t\tvar scrollTop = window.pageYOffset;\n\n\t\t\t\t\t$( win ).off( Tablesaw.events.resize, fakeBreakpoints );\n\n\t\t\t\t\t$( this )\n\t\t\t\t\t\t.on( "touchmove.swipetoggle", function( e ){\n\t\t\t\t\t\t\tx = getCoord( e, \'pageX\' );\n\t\t\t\t\t\t\ty = getCoord( e, \'pageY\' );\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.on( "touchend.swipetoggle", function() {\n\t\t\t\t\t\t\tvar cfg = tbl.getConfig({\n\t\t\t\t\t\t\t\tswipeHorizontalThreshold: 30,\n\t\t\t\t\t\t\t\tswipeVerticalThreshold: 30\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t// This config code is a little awkward because shoestring doesn’t support deep $.extend\n\t\t\t\t\t\t\t// Trying to work around when devs only override one of (not both) horizontalThreshold or\n\t\t\t\t\t\t\t// verticalThreshold in their TablesawConfig.\n\t\t\t\t\t\t\t// @TODO major version bump: remove cfg.swipe, move to just use the swipePrefix keys\n\t\t\t\t\t\t\tvar verticalThreshold = cfg.swipe ? cfg.swipe.verticalThreshold : cfg.swipeVerticalThreshold;\n\t\t\t\t\t\t\tvar horizontalThreshold = cfg.swipe ? cfg.swipe.horizontalThreshold : cfg.swipeHorizontalThreshold;\n\n\t\t\t\t\t\t\tvar isPageScrolled = Math.abs( window.pageYOffset - scrollTop ) >= verticalThreshold;\n\t\t\t\t\t\t\tvar isVerticalSwipe = Math.abs( y - originY ) >= verticalThreshold;\n\n\t\t\t\t\t\t\tif( !isVerticalSwipe && !isPageScrolled ) {\n\t\t\t\t\t\t\t\tif( x - originX < -1 * horizontalThreshold ){\n\t\t\t\t\t\t\t\t\tadvance( true );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif( x - originX > horizontalThreshold ){\n\t\t\t\t\t\t\t\t\tadvance( false );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\twindow.setTimeout(function() {\n\t\t\t\t\t\t\t\t$( win ).on( Tablesaw.events.resize, fakeBreakpoints );\n\t\t\t\t\t\t\t}, 300);\n\n\t\t\t\t\t\t\t$( this ).off( "touchmove.swipetoggle touchend.swipetoggle" );\n\t\t\t\t\t\t});\n\t\t\t\t});\n\t\t}\n\n\t\t$table\n\t\t\t.on( "tablesawcolumns.swipetoggle", function(){\n\t\t\t\tvar canGoPrev = canAdvance( getPrev() );\n\t\t\t\tvar canGoNext = canAdvance( getNext() );\n\t\t\t\t$prevBtn[ canGoPrev ? "removeClass" : "addClass" ]( classes.hideBtn );\n\t\t\t\t$nextBtn[ canGoNext ? "removeClass" : "addClass" ]( classes.hideBtn );\n\n\t\t\t\ttblsaw.$toolbar[ !canGoPrev && !canGoNext ? \'addClass\' : \'removeClass\' ]( classes.allColumnsVisible );\n\t\t\t})\n\t\t\t.on( "tablesawnext.swipetoggle", function(){\n\t\t\t\tadvance( true );\n\t\t\t} )\n\t\t\t.on( "tablesawprev.swipetoggle", function(){\n\t\t\t\tadvance( false );\n\t\t\t} )\n\t\t\t.on( Tablesaw.events.destroy + ".swipetoggle", function(){\n\t\t\t\tvar $t = $( this );\n\n\t\t\t\t$t.removeClass( \'tablesaw-swipe\' );\n\t\t\t\ttblsaw.$toolbar.find( \'.tablesaw-advance\' ).remove();\n\t\t\t\t$( win ).off( Tablesaw.events.resize, fakeBreakpoints );\n\n\t\t\t\t$t.off( ".swipetoggle" );\n\t\t\t})\n\t\t\t.on( Tablesaw.events.refresh, function() {\n\t\t\t\t// manual refresh\n\t\t\t\theaderWidths = [];\n\t\t\t\t$headerCells.each(function() {\n\t\t\t\t\tvar width = this.offsetWidth;\n\t\t\t\t\theaderWidths.push( width );\n\t\t\t\t});\n\n\t\t\t\tfakeBreakpoints();\n\t\t\t});\n\n\t\tfakeBreakpoints();\n\t\t$( win ).on( Tablesaw.events.resize, fakeBreakpoints );\n\t}\n\n\t// on tablecreate, init\n\t$( document ).on( Tablesaw.events.create, function( e, tablesaw ){\n\t\tif( tablesaw.mode === \'swipe\' ){\n\t\t\tcreateSwipeTable( tablesaw, tablesaw.$table );\n\t\t}\n\n\t} );\n\n}());\n\n;(function(){\n\n\tvar MiniMap = {\n\t\tattr: {\n\t\t\tinit: \'data-tablesaw-minimap\'\n\t\t}\n\t};\n\n\tfunction createMiniMap( $table ){\n\n\t\tvar tblsaw = $table.data( "tablesaw" );\n\t\tvar $btns = $( \'<div class="tablesaw-advance minimap">\' );\n\t\tvar $dotNav = $( \'<ul class="tablesaw-advance-dots">\' ).appendTo( $btns );\n\t\tvar hideDot = \'tablesaw-advance-dots-hide\';\n\t\tvar $headerCells = $table.find( \'thead th\' );\n\n\t\t// populate dots\n\t\t$headerCells.each(function(){\n\t\t\t$dotNav.append( \'<li><i></i></li>\' );\n\t\t});\n\n\t\t$btns.appendTo( tblsaw.$toolbar );\n\n\t\tfunction showMinimap( $table ) {\n\t\t\tvar mq = $table.attr( MiniMap.attr.init );\n\t\t\treturn !mq || win.matchMedia && win.matchMedia( mq ).matches;\n\t\t}\n\n\t\tfunction showHideNav(){\n\t\t\tif( !showMinimap( $table ) ) {\n\t\t\t\t$btns.css( "display", "none" );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t$btns.css( "display", "block" );\n\n\t\t\t// show/hide dots\n\t\t\tvar dots = $dotNav.find( "li" ).removeClass( hideDot );\n\t\t\t$table.find( "thead th" ).each(function(i){\n\t\t\t\tif( $( this ).css( "display" ) === "none" ){\n\t\t\t\t\tdots.eq( i ).addClass( hideDot );\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// run on init and resize\n\t\tshowHideNav();\n\t\t$( win ).on( Tablesaw.events.resize, showHideNav );\n\n\n\t\t$table\n\t\t\t.on( "tablesawcolumns.minimap", function(){\n\t\t\t\tshowHideNav();\n\t\t\t})\n\t\t\t.on( Tablesaw.events.destroy + ".minimap", function(){\n\t\t\t\tvar $t = $( this );\n\n\t\t\t\ttblsaw.$toolbar.find( \'.tablesaw-advance\' ).remove();\n\t\t\t\t$( win ).off( Tablesaw.events.resize, showHideNav );\n\n\t\t\t\t$t.off( ".minimap" );\n\t\t\t});\n\t}\n\n\n\n\t// on tablecreate, init\n\t$( document ).on( Tablesaw.events.create, function( e, tablesaw ){\n\n\t\tif( ( tablesaw.mode === \'swipe\' || tablesaw.mode === \'columntoggle\' ) && tablesaw.$table.is( \'[ \' + MiniMap.attr.init + \']\' ) ){\n\t\t\tcreateMiniMap( tablesaw.$table );\n\t\t}\n\n\t} );\n\n}());\n\n;(function() {\n\n\tvar S = {\n\t\tselectors: {\n\t\t\tinit: \'table[data-tablesaw-mode-switch]\'\n\t\t},\n\t\tattributes: {\n\t\t\texcludeMode: \'data-tablesaw-mode-exclude\'\n\t\t},\n\t\tclasses: {\n\t\t\tmain: \'tablesaw-modeswitch\',\n\t\t\ttoolbar: \'tablesaw-bar-section\'\n\t\t},\n\t\tmodes: [ \'stack\', \'swipe\', \'columntoggle\' ],\n\t\tinit: function( table ) {\n\t\t\tvar $table = $( table );\n\t\t\tvar tblsaw = $table.data( "tablesaw" );\n\t\t\tvar ignoreMode = $table.attr( S.attributes.excludeMode );\n\t\t\tvar $toolbar = tblsaw.$toolbar;\n\t\t\tvar $switcher = $( \'<div>\' ).addClass( S.classes.main + \' \' + S.classes.toolbar );\n\n\t\t\tvar html = [ \'<label>\' + Tablesaw.i18n.columns + \':\' ],\n\t\t\t\tdataMode = $table.attr( \'data-tablesaw-mode\' ),\n\t\t\t\tisSelected;\n\n\t\t\t// TODO next major version: remove .btn\n\t\t\thtml.push( \'<span class="btn tablesaw-btn"><select>\' );\n\t\t\tfor( var j=0, k = S.modes.length; j<k; j++ ) {\n\t\t\t\tif( ignoreMode && ignoreMode.toLowerCase() === S.modes[ j ] ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tisSelected = dataMode === S.modes[ j ];\n\n\t\t\t\thtml.push( \'<option\' +\n\t\t\t\t\t( isSelected ? \' selected\' : \'\' ) +\n\t\t\t\t\t\' value="\' + S.modes[ j ] + \'">\' + Tablesaw.i18n.modes[ j ] + \'</option>\' );\n\t\t\t}\n\t\t\thtml.push( \'</select></span></label>\' );\n\n\t\t\t$switcher.html( html.join( \'\' ) );\n\n\t\t\tvar $otherToolbarItems = $toolbar.find( \'.tablesaw-advance\' ).eq( 0 );\n\t\t\tif( $otherToolbarItems.length ) {\n\t\t\t\t$switcher.insertBefore( $otherToolbarItems );\n\t\t\t} else {\n\t\t\t\t$switcher.appendTo( $toolbar );\n\t\t\t}\n\n\t\t\t$switcher.find( \'.tablesaw-btn\' ).tablesawbtn();\n\t\t\t$switcher.find( \'select\' ).on( \'change\', function( event ) {\n\t\t\t\treturn S.onModeChange.call( table, event, $( this ).val() );\n\t\t\t});\n\t\t},\n\t\tonModeChange: function( event, val ) {\n\t\t\tvar $table = $( this );\n\t\t\tvar tblsaw = $table.data( "tablesaw" );\n\t\t\tvar $switcher = tblsaw.$toolbar.find( \'.\' + S.classes.main );\n\n\t\t\t$switcher.remove();\n\t\t\ttblsaw.destroy();\n\n\t\t\t$table.attr( \'data-tablesaw-mode\', val );\n\t\t\t$table.tablesaw();\n\t\t}\n\t};\n\n\t$( win.document ).on( Tablesaw.events.create, function( e, Tablesaw ) {\n\t\tif( Tablesaw.$table.is( S.selectors.init ) ) {\n\t\t\tS.init( Tablesaw.table );\n\t\t}\n\t});\n\n})();\n(function(){\n\tvar pluginName = "tablesawCheckAll";\n\n\tfunction CheckAll( tablesaw ) {\n\t\tthis.tablesaw = tablesaw;\n\t\tthis.$table = tablesaw.$table;\n\n\t\tthis.attr = "data-tablesaw-checkall";\n\t\tthis.checkAllSelector = "[" + this.attr + "]";\n\t\tthis.forceCheckedSelector = "[" + this.attr + "-checked]";\n\t\tthis.forceUncheckedSelector = "[" + this.attr + "-unchecked]";\n\t\tthis.checkboxSelector = "input[type=\\"checkbox\\"]";\n\n\t\tthis.$triggers = null;\n\t\tthis.$checkboxes = null;\n\n\t\tif( this.$table.data( pluginName ) ) {\n\t\t\treturn;\n\t\t}\n\t\tthis.$table.data( pluginName, this );\n\t\tthis.init();\n\t}\n\n\tCheckAll.prototype._filterCells = function( $checkboxes ) {\n\t\treturn $checkboxes.filter(function() {\n\t\t\treturn !$( this ).closest( "tr" ).is( "[data-tablesaw-subrow],[data-tablesaw-ignorerow]" );\n\t\t}).find( this.checkboxSelector ).not( this.checkAllSelector );\n\t};\n\n\t// With buttons you can use a scoping selector like: data-tablesaw-checkall="#my-scoped-id input[type=\'checkbox\']"\n\tCheckAll.prototype.getCheckboxesForButton = function( button ) {\n\t\treturn this._filterCells( $( $( button ).attr( this.attr ) ) );\n\t};\n\n\tCheckAll.prototype.getCheckboxesForCheckbox = function( checkbox ) {\n\t\treturn this._filterCells( $( $( checkbox ).closest( "th" )[ 0 ].cells ) );\n\t};\n\n\tCheckAll.prototype.init = function() {\n\t\tvar self = this;\n\t\tthis.$table.find( this.checkAllSelector ).each(function() {\n\t\t\tvar $trigger = $( this );\n\t\t\tif( $trigger.is( self.checkboxSelector ) ) {\n\t\t\t\tself.addCheckboxEvents( this );\n\t\t\t} else {\n\t\t\t\tself.addButtonEvents( this );\n\t\t\t}\n\t\t});\n\t};\n\n\tCheckAll.prototype.addButtonEvents = function( trigger ) {\n\t\tvar self = this;\n\n\t\t// Update body checkboxes when header checkbox is changed\n\t\t$( trigger ).on( "click", function( event ) {\n\t\t\tevent.preventDefault();\n\n\t\t\tvar $checkboxes = self.getCheckboxesForButton( this );\n\n\t\t\tvar allChecked = true;\n\t\t\t$checkboxes.each(function() {\n\t\t\t\tif( !this.checked ) {\n\t\t\t\t\tallChecked = false;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tvar setChecked;\n\t\t\tif( $( this ).is( self.forceCheckedSelector ) ) {\n\t\t\t\tsetChecked = true;\n\t\t\t} else if( $( this ).is( self.forceUncheckedSelector ) ) {\n\t\t\t\tsetChecked = false;\n\t\t\t} else {\n\t\t\t\tsetChecked = allChecked ? false : true;\n\t\t\t}\n\n\t\t\t$checkboxes.each(function() {\n\t\t\t\tthis.checked = setChecked;\n\n\t\t\t\t$( this ).trigger( "change." + pluginName );\n\t\t\t});\n\t\t});\n\t};\n\n\tCheckAll.prototype.addCheckboxEvents = function( trigger ) {\n\t\tvar self = this;\n\n\t\t// Update body checkboxes when header checkbox is changed\n\t\t$( trigger ).on( "change", function() {\n\t\t\tvar setChecked = this.checked;\n\n\t\t\tself.getCheckboxesForCheckbox( this ).each(function() {\n\t\t\t\tthis.checked = setChecked;\n\t\t\t});\n\t\t});\n\n\t\tvar $checkboxes = self.getCheckboxesForCheckbox( trigger );\n\n\t\t// Update header checkbox when body checkboxes are changed\n\t\t$checkboxes.on( "change." + pluginName, function() {\n\t\t\tvar checkedCount = 0;\n\t\t\t$checkboxes.each(function() {\n\t\t\t\tif( this.checked ) {\n\t\t\t\t\tcheckedCount++;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tvar allSelected = checkedCount === $checkboxes.length;\n\n\t\t\ttrigger.checked = allSelected;\n\n\t\t\t// only indeterminate if some are selected (not all and not none)\n\t\t\ttrigger.indeterminate = checkedCount !== 0 && !allSelected;\n\t\t});\n\t};\n\n\t// on tablecreate, init\n\t$( document ).on( Tablesaw.events.create, function( e, tablesaw ){\n\t\tnew CheckAll( tablesaw );\n\t});\n\n}());\n\n}));\n'},7:function(t,n){t.exports=function(t){function n(t){"undefined"!=typeof console&&(console.error||console.log)("[Script Loader]",t)}try{"undefined"!=typeof execScript&&"undefined"!=typeof attachEvent&&"undefined"==typeof addEventListener?execScript(t):"undefined"!=typeof eval?eval.call(null,t):n("EvalError: No eval function available")}catch(t){n(t)}}}});
//# sourceMappingURL=vendor.min.js.map;
!function(t){var e={};function n(i){if(e[i])return e[i].exports;var o=e[i]={i:i,l:!1,exports:{}};return t[i].call(o.exports,o,o.exports,n),o.l=!0,o.exports}n.m=t,n.c=e,n.d=function(t,e,i){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:i})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var i=Object.create(null);if(n.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var o in t)n.d(i,o,function(e){return t[e]}.bind(null,o));return i},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="",n(n.s=360)}({100:function(t,e,n){(function(n){var i,o;/*! smooth-scroll v12.1.5 | (c) 2017 Chris Ferdinandi | MIT License | http://github.com/cferdinandi/smooth-scroll */o=void 0!==n?n:"undefined"!=typeof window?window:this,void 0===(i=function(){return function(t){"use strict";var e="querySelector"in document&&"addEventListener"in t&&"requestAnimationFrame"in t&&"closest"in t.Element.prototype,n={ignore:"[data-scroll-ignore]",header:null,speed:500,offset:0,easing:"easeInOutCubic",customEasing:null,before:function(){},after:function(){}},i=function(){for(var t={},e=0,n=arguments.length;e<n;e++){var i=arguments[e];!function(e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])}(i)}return t},o=function(e){return parseInt(t.getComputedStyle(e).height,10)},r=function(t){"#"===t.charAt(0)&&(t=t.substr(1));for(var e,n=String(t),i=n.length,o=-1,r="",a=n.charCodeAt(0);++o<i;){if(0===(e=n.charCodeAt(o)))throw new InvalidCharacterError("Invalid character: the input contains U+0000.");r+=e>=1&&e<=31||127==e||0===o&&e>=48&&e<=57||1===o&&e>=48&&e<=57&&45===a?"\\"+e.toString(16)+" ":e>=128||45===e||95===e||e>=48&&e<=57||e>=65&&e<=90||e>=97&&e<=122?n.charAt(o):"\\"+n.charAt(o)}return"#"+r},a=function(t){return t?o(t)+t.offsetTop:0};return function(o,s){var l,c,u,d,f,h,g,p={cancelScroll:function(){cancelAnimationFrame(g)},animateScroll:function(e,o,r){var s=i(l||n,r||{}),c="[object Number]"===Object.prototype.toString.call(e),u=c||!e.tagName?null:e;if(c||u){var h=t.pageYOffset;s.header&&!d&&(d=document.querySelector(s.header)),f||(f=a(d));var g,m,v,b=c?e:function(t,e,n){var i=0;if(t.offsetParent)do{i+=t.offsetTop,t=t.offsetParent}while(t);return i=Math.max(i-e-n,0)}(u,f,parseInt("function"==typeof s.offset?s.offset():s.offset,10)),y=b-h,w=Math.max(document.body.scrollHeight,document.documentElement.scrollHeight,document.body.offsetHeight,document.documentElement.offsetHeight,document.body.clientHeight,document.documentElement.clientHeight),_=0,k=function(n,i){var r=t.pageYOffset;if(n==i||r==i||(h<i&&t.innerHeight+r)>=w)return p.cancelScroll(),function(e,n,i){i||(e.focus(),document.activeElement.id!==e.id&&(e.setAttribute("tabindex","-1"),e.focus(),e.style.outline="none"),t.scrollTo(0,n))}(e,i,c),s.after(e,o),g=null,!0},S=function(e){g||(g=e),m=(_+=e-g)/parseInt(s.speed,10),v=h+y*function(t,e){var n;return"easeInQuad"===t.easing&&(n=e*e),"easeOutQuad"===t.easing&&(n=e*(2-e)),"easeInOutQuad"===t.easing&&(n=e<.5?2*e*e:(4-2*e)*e-1),"easeInCubic"===t.easing&&(n=e*e*e),"easeOutCubic"===t.easing&&(n=--e*e*e+1),"easeInOutCubic"===t.easing&&(n=e<.5?4*e*e*e:(e-1)*(2*e-2)*(2*e-2)+1),"easeInQuart"===t.easing&&(n=e*e*e*e),"easeOutQuart"===t.easing&&(n=1- --e*e*e*e),"easeInOutQuart"===t.easing&&(n=e<.5?8*e*e*e*e:1-8*--e*e*e*e),"easeInQuint"===t.easing&&(n=e*e*e*e*e),"easeOutQuint"===t.easing&&(n=1+--e*e*e*e*e),"easeInOutQuint"===t.easing&&(n=e<.5?16*e*e*e*e*e:1+16*--e*e*e*e*e),t.customEasing&&(n=t.customEasing(e)),n||e}(s,m=m>1?1:m),t.scrollTo(0,Math.floor(v)),k(v,b)||(t.requestAnimationFrame(S),g=e)};0===t.pageYOffset&&t.scrollTo(0,0),s.before(e,o),p.cancelScroll(),t.requestAnimationFrame(S)}}},m=function(t){c&&(c.id=c.getAttribute("data-scroll-id"),p.animateScroll(c,u),c=null,u=null)},v=function(e){if(!("matchMedia"in t&&t.matchMedia("(prefers-reduced-motion)").matches)&&0===e.button&&!e.metaKey&&!e.ctrlKey&&(u=e.target.closest(o))&&"a"===u.tagName.toLowerCase()&&!e.target.closest(l.ignore)&&u.hostname===t.location.hostname&&u.pathname===t.location.pathname&&/#/.test(u.href)){var n;try{n=r(decodeURIComponent(u.hash))}catch(t){n=r(u.hash)}if("#"===n){e.preventDefault();var i=(c=document.body).id?c.id:"smooth-scroll-top";return c.setAttribute("data-scroll-id",i),c.id="",void(t.location.hash.substring(1)===i?m():t.location.hash=i)}(c=document.querySelector(n))&&(c.setAttribute("data-scroll-id",c.id),c.id="",u.hash===t.location.hash&&(e.preventDefault(),m()))}},b=function(t){h||(h=setTimeout(function(){h=null,f=a(d)},66))};return p.destroy=function(){l&&(document.removeEventListener("click",v,!1),t.removeEventListener("resize",b,!1),p.cancelScroll(),l=null,c=null,u=null,d=null,f=null,h=null,g=null)},p.init=function(o){e&&(p.destroy(),l=i(n,o||{}),d=l.header?document.querySelector(l.header):null,f=a(d),document.addEventListener("click",v,!1),t.addEventListener("hashchange",m,!1),d&&t.addEventListener("resize",b,!1))},p.init(s),p}}(o)}.apply(e,[]))||(t.exports=i)}).call(this,n(3))},105:function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i,o=function(){function t(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(e,n,i){return n&&t(e.prototype,n),i&&t(e,i),e}}(),r=n(70),a=(i=r)&&i.__esModule?i:{default:i};var s=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:".ck__dialog",n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:".btn-show-modal-disclosure",i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this.disableTriggerLinks(n),this.initialize(e,i)}return o(t,[{key:"disableTriggerLinks",value:function(t){var e=document.querySelectorAll(t),n=e.length,i=0;for(i=0;i<n;i++)e[i].addEventListener("click",function(t){t.preventDefault()})}},{key:"initialize",value:function(t,e){var n=document.querySelectorAll(t),i=n.length,o=0,r=null;for(o=0;o<i;o++)n[o].style.visibility="visible",r=new a.default(n[o]),e.onShow&&r.on("show",e.onShow)}}]),t}();e.default=s,new s},220:function(t,e,n){var i=n(343),o=n(373);for(var r in(e=t.exports=function(t,e){return new o(e).process(t)}).FilterCSS=o,i)e[r]=i[r];"undefined"!=typeof window&&(window.filterCSS=t.exports)},221:function(t,e){t.exports={indexOf:function(t,e){var n,i;if(Array.prototype.indexOf)return t.indexOf(e);for(n=0,i=t.length;n<i;n++)if(t[n]===e)return n;return-1},forEach:function(t,e,n){var i,o;if(Array.prototype.forEach)return t.forEach(e,n);for(i=0,o=t.length;i<o;i++)e.call(n,t[i],i,t)},trim:function(t){return String.prototype.trim?t.trim():t.replace(/(^\s*)|(\s*$)/g,"")},spaceIndex:function(t){var e=/\s|\n|\t/.exec(t);return e?e.index:-1}}},222:function(t,e,n){"use strict";
/*! npm.im/object-fit-images 3.2.4 */var i="bfred-it:object-fit-images",o=/(object-fit|object-position)\s*:\s*([-.\w\s%]+)/g,r="undefined"==typeof Image?{style:{"object-position":1}}:new Image,a="object-fit"in r.style,s="object-position"in r.style,l="background-size"in r.style,c="string"==typeof r.currentSrc,u=r.getAttribute,d=r.setAttribute,f=!1;function h(t,e,n){var i="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='"+(e||1)+"' height='"+(n||0)+"'%3E%3C/svg%3E";u.call(t,"src")!==i&&d.call(t,"src",i)}function g(t,e){t.naturalWidth?e(t):setTimeout(g,100,t,e)}function p(t){var e=function(t){for(var e,n=getComputedStyle(t).fontFamily,i={};null!==(e=o.exec(n));)i[e[1]]=e[2];return i}(t),n=t[i];if(e["object-fit"]=e["object-fit"]||"fill",!n.img){if("fill"===e["object-fit"])return;if(!n.skipTest&&a&&!e["object-position"])return}if(!n.img){n.img=new Image(t.width,t.height),n.img.srcset=u.call(t,"data-ofi-srcset")||t.srcset,n.img.src=u.call(t,"data-ofi-src")||t.src,d.call(t,"data-ofi-src",t.src),t.srcset&&d.call(t,"data-ofi-srcset",t.srcset),h(t,t.naturalWidth||t.width,t.naturalHeight||t.height),t.srcset&&(t.srcset="");try{!function(t){var e={get:function(e){return t[i].img[e||"src"]},set:function(e,n){return t[i].img[n||"src"]=e,d.call(t,"data-ofi-"+n,e),p(t),e}};Object.defineProperty(t,"src",e),Object.defineProperty(t,"currentSrc",{get:function(){return e.get("currentSrc")}}),Object.defineProperty(t,"srcset",{get:function(){return e.get("srcset")},set:function(t){return e.set(t,"srcset")}})}(t)}catch(t){window.console&&console.warn("https://bit.ly/ofi-old-browser")}}!function(t){if(t.srcset&&!c&&window.picturefill){var e=window.picturefill._;t[e.ns]&&t[e.ns].evaled||e.fillImg(t,{reselect:!0}),t[e.ns].curSrc||(t[e.ns].supported=!1,e.fillImg(t,{reselect:!0})),t.currentSrc=t[e.ns].curSrc||t.src}}(n.img),t.style.backgroundImage='url("'+(n.img.currentSrc||n.img.src).replace(/"/g,'\\"')+'")',t.style.backgroundPosition=e["object-position"]||"center",t.style.backgroundRepeat="no-repeat",t.style.backgroundOrigin="content-box",/scale-down/.test(e["object-fit"])?g(n.img,function(){n.img.naturalWidth>t.width||n.img.naturalHeight>t.height?t.style.backgroundSize="contain":t.style.backgroundSize="auto"}):t.style.backgroundSize=e["object-fit"].replace("none","auto").replace("fill","100% 100%"),g(n.img,function(e){h(t,e.naturalWidth,e.naturalHeight)})}function m(t,e){var n=!f&&!t;if(e=e||{},t=t||"img",s&&!e.skipTest||!l)return!1;"img"===t?t=document.getElementsByTagName("img"):"string"==typeof t?t=document.querySelectorAll(t):"length"in t||(t=[t]);for(var o=0;o<t.length;o++)t[o][i]=t[o][i]||{skipTest:e.skipTest},p(t[o]);n&&(document.body.addEventListener("load",function(t){"IMG"===t.target.tagName&&m(t.target,{skipTest:e.skipTest})},!0),f=!0,t="img"),e.watchMQ&&window.addEventListener("resize",m.bind(null,t,{skipTest:e.skipTest}))}m.supportsObjectFit=a,m.supportsObjectPosition=s,function(){function t(t,e){return t[i]&&t[i].img&&("src"===e||"srcset"===e)?t[i].img:t}s||(HTMLImageElement.prototype.getAttribute=function(e){return u.call(t(this,e),e)},HTMLImageElement.prototype.setAttribute=function(e,n){return d.call(t(this,e),e,String(n))})}(),t.exports=m},3:function(t,e){var n;n=function(){return this}();try{n=n||new Function("return this")()}catch(t){"object"==typeof window&&(n=window)}t.exports=n},342:function(t,e,n){var i=n(220).FilterCSS,o=n(220).getDefaultWhiteList,r=n(221);function a(){return{a:["target","href","title"],abbr:["title"],address:[],area:["shape","coords","href","alt"],article:[],aside:[],audio:["autoplay","controls","loop","preload","src"],b:[],bdi:["dir"],bdo:["dir"],big:[],blockquote:["cite"],br:[],caption:[],center:[],cite:[],code:[],col:["align","valign","span","width"],colgroup:["align","valign","span","width"],dd:[],del:["datetime"],details:["open"],div:[],dl:[],dt:[],em:[],font:["color","size","face"],footer:[],h1:[],h2:[],h3:[],h4:[],h5:[],h6:[],header:[],hr:[],i:[],img:["src","alt","title","width","height"],ins:["datetime"],li:[],mark:[],nav:[],ol:[],p:[],pre:[],s:[],section:[],small:[],span:[],sub:[],sup:[],strong:[],table:["width","border","align","valign"],tbody:["align","valign"],td:["width","rowspan","colspan","align","valign"],tfoot:["align","valign"],th:["width","rowspan","colspan","align","valign"],thead:["align","valign"],tr:["rowspan","align","valign"],tt:[],u:[],ul:[],video:["autoplay","controls","loop","preload","src","height","width"]}}var s=new i;function l(t){return t.replace(c,"&lt;").replace(u,"&gt;")}var c=/</g,u=/>/g,d=/"/g,f=/&quot;/g,h=/&#([a-zA-Z0-9]*);?/gim,g=/&colon;?/gim,p=/&newline;?/gim,m=/((j\s*a\s*v\s*a|v\s*b|l\s*i\s*v\s*e)\s*s\s*c\s*r\s*i\s*p\s*t\s*|m\s*o\s*c\s*h\s*a)\:/gi,v=/e\s*x\s*p\s*r\s*e\s*s\s*s\s*i\s*o\s*n\s*\(.*/gi,b=/u\s*r\s*l\s*\(.*/gi;function y(t){return t.replace(d,"&quot;")}function w(t){return t.replace(f,'"')}function _(t){return t.replace(h,function(t,e){return"x"===e[0]||"X"===e[0]?String.fromCharCode(parseInt(e.substr(1),16)):String.fromCharCode(parseInt(e,10))})}function k(t){return t.replace(g,":").replace(p," ")}function S(t){for(var e="",n=0,i=t.length;n<i;n++)e+=t.charCodeAt(n)<32?" ":t.charAt(n);return r.trim(e)}function E(t){return t=S(t=k(t=_(t=w(t))))}function x(t){return t=l(t=y(t))}var L=/<!--[\s\S]*?-->/g;e.whiteList={a:["target","href","title"],abbr:["title"],address:[],area:["shape","coords","href","alt"],article:[],aside:[],audio:["autoplay","controls","loop","preload","src"],b:[],bdi:["dir"],bdo:["dir"],big:[],blockquote:["cite"],br:[],caption:[],center:[],cite:[],code:[],col:["align","valign","span","width"],colgroup:["align","valign","span","width"],dd:[],del:["datetime"],details:["open"],div:[],dl:[],dt:[],em:[],font:["color","size","face"],footer:[],h1:[],h2:[],h3:[],h4:[],h5:[],h6:[],header:[],hr:[],i:[],img:["src","alt","title","width","height"],ins:["datetime"],li:[],mark:[],nav:[],ol:[],p:[],pre:[],s:[],section:[],small:[],span:[],sub:[],sup:[],strong:[],table:["width","border","align","valign"],tbody:["align","valign"],td:["width","rowspan","colspan","align","valign"],tfoot:["align","valign"],th:["width","rowspan","colspan","align","valign"],thead:["align","valign"],tr:["rowspan","align","valign"],tt:[],u:[],ul:[],video:["autoplay","controls","loop","preload","src","height","width"]},e.getDefaultWhiteList=a,e.onTag=function(t,e,n){},e.onIgnoreTag=function(t,e,n){},e.onTagAttr=function(t,e,n){},e.onIgnoreTagAttr=function(t,e,n){},e.safeAttrValue=function(t,e,n,i){if(n=E(n),"href"===e||"src"===e){if("#"===(n=r.trim(n)))return"#";if("http://"!==n.substr(0,7)&&"https://"!==n.substr(0,8)&&"mailto:"!==n.substr(0,7)&&"tel:"!==n.substr(0,4)&&"#"!==n[0]&&"/"!==n[0])return""}else if("background"===e){if(m.lastIndex=0,m.test(n))return""}else if("style"===e){if(v.lastIndex=0,v.test(n))return"";if(b.lastIndex=0,b.test(n)&&(m.lastIndex=0,m.test(n)))return"";!1!==i&&(n=(i=i||s).process(n))}return n=x(n)},e.escapeHtml=l,e.escapeQuote=y,e.unescapeQuote=w,e.escapeHtmlEntities=_,e.escapeDangerHtml5Entities=k,e.clearNonPrintableCharacter=S,e.friendlyAttrValue=E,e.escapeAttrValue=x,e.onIgnoreTagStripAll=function(){return""},e.StripTagBody=function(t,e){"function"!=typeof e&&(e=function(){});var n=!Array.isArray(t),i=[],o=!1;return{onIgnoreTag:function(a,s,l){if(function(e){return!!n||-1!==r.indexOf(t,e)}(a)){if(l.isClosing){var c="[/removed]",u=l.position+c.length;return i.push([!1!==o?o:l.position,u]),o=!1,c}return o||(o=l.position),"[removed]"}return e(a,s,l)},remove:function(t){var e="",n=0;return r.forEach(i,function(i){e+=t.slice(n,i[0]),n=i[1]}),e+=t.slice(n)}}},e.stripCommentTag=function(t){return t.replace(L,"")},e.stripBlankChar=function(t){var e=t.split("");return(e=e.filter(function(t){var e=t.charCodeAt(0);return!(127===e||e<=31&&10!==e&&13!==e)})).join("")},e.cssFilter=s,e.getDefaultCSSWhiteList=o},343:function(t,e){function n(){var t={"align-content":!1,"align-items":!1,"align-self":!1,"alignment-adjust":!1,"alignment-baseline":!1,all:!1,"anchor-point":!1,animation:!1,"animation-delay":!1,"animation-direction":!1,"animation-duration":!1,"animation-fill-mode":!1,"animation-iteration-count":!1,"animation-name":!1,"animation-play-state":!1,"animation-timing-function":!1,azimuth:!1,"backface-visibility":!1,background:!0,"background-attachment":!0,"background-clip":!0,"background-color":!0,"background-image":!0,"background-origin":!0,"background-position":!0,"background-repeat":!0,"background-size":!0,"baseline-shift":!1,binding:!1,bleed:!1,"bookmark-label":!1,"bookmark-level":!1,"bookmark-state":!1,border:!0,"border-bottom":!0,"border-bottom-color":!0,"border-bottom-left-radius":!0,"border-bottom-right-radius":!0,"border-bottom-style":!0,"border-bottom-width":!0,"border-collapse":!0,"border-color":!0,"border-image":!0,"border-image-outset":!0,"border-image-repeat":!0,"border-image-slice":!0,"border-image-source":!0,"border-image-width":!0,"border-left":!0,"border-left-color":!0,"border-left-style":!0,"border-left-width":!0,"border-radius":!0,"border-right":!0,"border-right-color":!0,"border-right-style":!0,"border-right-width":!0,"border-spacing":!0,"border-style":!0,"border-top":!0,"border-top-color":!0,"border-top-left-radius":!0,"border-top-right-radius":!0,"border-top-style":!0,"border-top-width":!0,"border-width":!0,bottom:!1,"box-decoration-break":!0,"box-shadow":!0,"box-sizing":!0,"box-snap":!0,"box-suppress":!0,"break-after":!0,"break-before":!0,"break-inside":!0,"caption-side":!1,chains:!1,clear:!0,clip:!1,"clip-path":!1,"clip-rule":!1,color:!0,"color-interpolation-filters":!0,"column-count":!1,"column-fill":!1,"column-gap":!1,"column-rule":!1,"column-rule-color":!1,"column-rule-style":!1,"column-rule-width":!1,"column-span":!1,"column-width":!1,columns:!1,contain:!1,content:!1,"counter-increment":!1,"counter-reset":!1,"counter-set":!1,crop:!1,cue:!1,"cue-after":!1,"cue-before":!1,cursor:!1,direction:!1,display:!0,"display-inside":!0,"display-list":!0,"display-outside":!0,"dominant-baseline":!1,elevation:!1,"empty-cells":!1,filter:!1,flex:!1,"flex-basis":!1,"flex-direction":!1,"flex-flow":!1,"flex-grow":!1,"flex-shrink":!1,"flex-wrap":!1,float:!1,"float-offset":!1,"flood-color":!1,"flood-opacity":!1,"flow-from":!1,"flow-into":!1,font:!0,"font-family":!0,"font-feature-settings":!0,"font-kerning":!0,"font-language-override":!0,"font-size":!0,"font-size-adjust":!0,"font-stretch":!0,"font-style":!0,"font-synthesis":!0,"font-variant":!0,"font-variant-alternates":!0,"font-variant-caps":!0,"font-variant-east-asian":!0,"font-variant-ligatures":!0,"font-variant-numeric":!0,"font-variant-position":!0,"font-weight":!0,grid:!1,"grid-area":!1,"grid-auto-columns":!1,"grid-auto-flow":!1,"grid-auto-rows":!1,"grid-column":!1,"grid-column-end":!1,"grid-column-start":!1,"grid-row":!1,"grid-row-end":!1,"grid-row-start":!1,"grid-template":!1,"grid-template-areas":!1,"grid-template-columns":!1,"grid-template-rows":!1,"hanging-punctuation":!1,height:!0,hyphens:!1,icon:!1,"image-orientation":!1,"image-resolution":!1,"ime-mode":!1,"initial-letters":!1,"inline-box-align":!1,"justify-content":!1,"justify-items":!1,"justify-self":!1,left:!1,"letter-spacing":!0,"lighting-color":!0,"line-box-contain":!1,"line-break":!1,"line-grid":!1,"line-height":!1,"line-snap":!1,"line-stacking":!1,"line-stacking-ruby":!1,"line-stacking-shift":!1,"line-stacking-strategy":!1,"list-style":!0,"list-style-image":!0,"list-style-position":!0,"list-style-type":!0,margin:!0,"margin-bottom":!0,"margin-left":!0,"margin-right":!0,"margin-top":!0,"marker-offset":!1,"marker-side":!1,marks:!1,mask:!1,"mask-box":!1,"mask-box-outset":!1,"mask-box-repeat":!1,"mask-box-slice":!1,"mask-box-source":!1,"mask-box-width":!1,"mask-clip":!1,"mask-image":!1,"mask-origin":!1,"mask-position":!1,"mask-repeat":!1,"mask-size":!1,"mask-source-type":!1,"mask-type":!1,"max-height":!0,"max-lines":!1,"max-width":!0,"min-height":!0,"min-width":!0,"move-to":!1,"nav-down":!1,"nav-index":!1,"nav-left":!1,"nav-right":!1,"nav-up":!1,"object-fit":!1,"object-position":!1,opacity:!1,order:!1,orphans:!1,outline:!1,"outline-color":!1,"outline-offset":!1,"outline-style":!1,"outline-width":!1,overflow:!1,"overflow-wrap":!1,"overflow-x":!1,"overflow-y":!1,padding:!0,"padding-bottom":!0,"padding-left":!0,"padding-right":!0,"padding-top":!0,page:!1,"page-break-after":!1,"page-break-before":!1,"page-break-inside":!1,"page-policy":!1,pause:!1,"pause-after":!1,"pause-before":!1,perspective:!1,"perspective-origin":!1,pitch:!1,"pitch-range":!1,"play-during":!1,position:!1,"presentation-level":!1,quotes:!1,"region-fragment":!1,resize:!1,rest:!1,"rest-after":!1,"rest-before":!1,richness:!1,right:!1,rotation:!1,"rotation-point":!1,"ruby-align":!1,"ruby-merge":!1,"ruby-position":!1,"shape-image-threshold":!1,"shape-outside":!1,"shape-margin":!1,size:!1,speak:!1,"speak-as":!1,"speak-header":!1,"speak-numeral":!1,"speak-punctuation":!1,"speech-rate":!1,stress:!1,"string-set":!1,"tab-size":!1,"table-layout":!1,"text-align":!0,"text-align-last":!0,"text-combine-upright":!0,"text-decoration":!0,"text-decoration-color":!0,"text-decoration-line":!0,"text-decoration-skip":!0,"text-decoration-style":!0,"text-emphasis":!0,"text-emphasis-color":!0,"text-emphasis-position":!0,"text-emphasis-style":!0,"text-height":!0,"text-indent":!0,"text-justify":!0,"text-orientation":!0,"text-overflow":!0,"text-shadow":!0,"text-space-collapse":!0,"text-transform":!0,"text-underline-position":!0,"text-wrap":!0,top:!1,transform:!1,"transform-origin":!1,"transform-style":!1,transition:!1,"transition-delay":!1,"transition-duration":!1,"transition-property":!1,"transition-timing-function":!1,"unicode-bidi":!1,"vertical-align":!1,visibility:!1,"voice-balance":!1,"voice-duration":!1,"voice-family":!1,"voice-pitch":!1,"voice-range":!1,"voice-rate":!1,"voice-stress":!1,"voice-volume":!1,volume:!1,"white-space":!1,widows:!1,width:!0,"will-change":!1,"word-break":!0,"word-spacing":!0,"word-wrap":!0,"wrap-flow":!1,"wrap-through":!1,"writing-mode":!1,"z-index":!1};return t}var i=/javascript\s*\:/gim;e.whiteList=n(),e.getDefaultWhiteList=n,e.onAttr=function(t,e,n){},e.onIgnoreAttr=function(t,e,n){},e.safeAttrValue=function(t,e){return i.test(e)?"":e}},344:function(t,e){t.exports={indexOf:function(t,e){var n,i;if(Array.prototype.indexOf)return t.indexOf(e);for(n=0,i=t.length;n<i;n++)if(t[n]===e)return n;return-1},forEach:function(t,e,n){var i,o;if(Array.prototype.forEach)return t.forEach(e,n);for(i=0,o=t.length;i<o;i++)e.call(n,t[i],i,t)},trim:function(t){return String.prototype.trim?t.trim():t.replace(/(^\s*)|(\s*$)/g,"")},trimRight:function(t){return String.prototype.trimRight?t.trimRight():t.replace(/(\s*$)/g,"")}}},345:function(t,e,n){var i=n(221);function o(t){var e=i.spaceIndex(t);if(-1===e)var n=t.slice(1,-1);else n=t.slice(1,e+1);return"/"===(n=i.trim(n).toLowerCase()).slice(0,1)&&(n=n.slice(1)),"/"===n.slice(-1)&&(n=n.slice(0,-1)),n}function r(t){return"</"===t.slice(0,2)}var a=/[^a-zA-Z0-9_:\.\-]/gim;function s(t,e){for(;e<t.length;e++){var n=t[e];if(" "!==n)return"="===n?e:-1}}function l(t,e){for(;e>0;e--){var n=t[e];if(" "!==n)return"="===n?e:-1}}function c(t){return function(t){return'"'===t[0]&&'"'===t[t.length-1]||"'"===t[0]&&"'"===t[t.length-1]}(t)?t.substr(1,t.length-2):t}e.parseTag=function(t,e,n){var i="",a=0,s=!1,l=!1,c=0,u=t.length,d="",f="";for(c=0;c<u;c++){var h=t.charAt(c);if(!1===s){if("<"===h){s=c;continue}}else if(!1===l){if("<"===h){i+=n(t.slice(a,c)),s=c,a=c;continue}if(">"===h){i+=n(t.slice(a,s)),d=o(f=t.slice(s,c+1)),i+=e(s,i.length,d,f,r(f)),a=c+1,s=!1;continue}if(('"'===h||"'"===h)&&"="===t.charAt(c-1)){l=h;continue}}else if(h===l){l=!1;continue}}return a<t.length&&(i+=n(t.substr(a))),i},e.parseAttr=function(t,e){var n=0,o=[],r=!1,u=t.length;function d(t,n){if(!((t=(t=i.trim(t)).replace(a,"").toLowerCase()).length<1)){var r=e(t,n||"");r&&o.push(r)}}for(var f=0;f<u;f++){var h,g=t.charAt(f);if(!1!==r||"="!==g)if(!1===r||f!==n||'"'!==g&&"'"!==g||"="!==t.charAt(f-1)){if(/\s|\n|\t/.test(g)){if(t=t.replace(/\s|\n|\t/g," "),!1===r){if(-1===(h=s(t,f))){d(i.trim(t.slice(n,f))),r=!1,n=f+1;continue}f=h-1;continue}if(-1===(h=l(t,f-1))){d(r,c(i.trim(t.slice(n,f)))),r=!1,n=f+1;continue}}}else{if(-1===(h=t.indexOf(g,f+1)))break;d(r,i.trim(t.slice(n+1,h))),r=!1,n=(f=h)+1}else r=t.slice(n,f),n=f+1}return n<t.length&&(!1===r?d(t.slice(n)):d(r,c(i.trim(t.slice(n))))),i.trim(o.join(" "))}},360:function(t,e,n){n(361),n(368),n(369),n(370),n(371),n(376),n(105),n(378),n(379),t.exports=n(380)},361:function(t,e,n){"use strict";n(362),n(364),n(366)},362:function(t,e,n){(function(e){t.exports=e.ck_ready=n(363)}).call(this,n(3))},363:function(t,e,n){"use strict";Array.prototype.includes||Object.defineProperty(Array.prototype,"includes",{value:function(t,e){if(null===this)throw new TypeError('"this" is null or not defined');var n=Object(this),i=n.length>>>0;if(0===i)return!1;var o,r,a=0|e,s=Math.max(a>=0?a:i-Math.abs(a),0);for(;s<i;){if((o=n[s])===(r=t)||"number"==typeof o&&"number"==typeof r&&isNaN(o)&&isNaN(r))return!0;s++}return!1}}),t.exports=function(t){"loading"!=document.readyState?t():document.addEventListener("DOMContentLoaded",t)}},364:function(t,e,n){n(7)(n(365))},365:function(t,e){t.exports="'use strict';\n\n(function (window, $) {\n\t'use strict';\n\n\t/**\n  * Returns a function, that, as long as it continues to be invoked, will not\n  * be triggered. The function will be called after it stops being called for\n  * N milliseconds. If `immediate` is passed, trigger the function on the\n  * leading edge, instead of the trailing.\n  */\n\n\tfunction debounce(func, wait, immediate) {\n\t\tvar timeout;\n\t\treturn function () {\n\t\t\tvar context = this,\n\t\t\t    args = arguments;\n\t\t\tvar later = function later() {\n\t\t\t\ttimeout = null;\n\t\t\t\tif (!immediate) func.apply(context, args);\n\t\t\t};\n\n\t\t\tvar callNow = immediate && !timeout;\n\t\t\tclearTimeout(timeout);\n\t\t\ttimeout = setTimeout(later, wait);\n\t\t\tif (callNow) func.apply(context, args);\n\t\t};\n\t}\n\n\t/**\n  * Set everything up\n  */\n\tfunction setup() {\n\t\t// Cache elements\n\t\tvar bodyElement = $('body');\n\n\t\t/**\n   * When the nav menu is ready, we add the closed class.\n   *\n   * @param Event e\n   *\n   * @return void\n   */\n\t\t$('#menu-header, #menu-header-right').on('navigation:ready', function (e) {\n\t\t\t// By default the menu is closed on mobile\n\t\t\tbodyElement.addClass('menu-is-closed');\n\t\t});\n\n\t\t/**\n   * Whenever we click on the mobile hamburger icon\n   *\n   * @param Event e\n   *\n   * @return void\n   *\n   */\n\t\t$(document.getElementById('js-menu-toggle')).on('click', function (e) {\n\t\t\tif (!bodyElement.hasClass('menu-is-closed')) {\n\t\t\t\tbodyElement.delay(500).queue(function () {\n\t\t\t\t\tbodyElement.addClass('menu-is-closed').dequeue();\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tbodyElement.removeClass('menu-is-closed').addClass('menu-is-opening');\n\t\t\t\tbodyElement.delay(10).queue(function () {\n\t\t\t\t\tbodyElement.removeClass('menu-is-opening').dequeue();\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\t// Init our 10up navigation component.\n\t\tTenUp.navigation({\n\t\t\t'target': '#menu-header',\n\t\t\t'toggle': '#js-menu-toggle',\n\t\t\t'sub_menu_open': 'click, hover'\n\t\t}, function () {\n\t\t\t// Ensure that we show both the left and right menus on single posts (only place both are used currently)\n\t\t\tif (bodyElement.hasClass('single-post') || bodyElement.hasClass('search') || bodyElement.hasClass('single-ck-sem') || bodyElement.hasClass('archive') && bodyElement.hasClass('category')) {\n\t\t\t\t// When we click on the hamburger, we open the other menu as well.\n\t\t\t\tdocument.getElementById('js-menu-toggle').addEventListener('click', function (e) {\n\t\t\t\t\tvar menu = document.getElementById('menu-header-right');\n\t\t\t\t\tif (!menu.getAttribute('aria-hidden') || undefined === menu.getAttribute('aria-hidden') || 'true' === menu.getAttribute('aria-hidden')) {\n\t\t\t\t\t\tmenu.setAttribute('aria-hidden', 'false');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmenu.setAttribute('aria-hidden', 'true');\n\t\t\t\t\t}\n\t\t\t\t}, false);\n\t\t\t}\n\n\t\t\t// Trigger custom event to let the world know the menu is ready.\n\t\t\t$(document.getElementById('menu-header')).trigger('navigation:ready');\n\t\t});\n\n\t\t// We have 2 menus on the page. One on the left, and one on the right.\n\t\tTenUp.navigation({\n\t\t\t'target': '#menu-header-right',\n\t\t\t'toggle': '#js-menu-toggle',\n\t\t\t'sub_menu_open': 'click, hover'\n\t\t}, function () {\n\t\t\t// Trigger custom event to let the world know the second menu is ready.\n\t\t\t$(document.getElementById('menu-header-right')).trigger('navigation:ready');\n\t\t});\n\n\t\t// Listen for clicks on parent menus\n\t\tvar toggles = document.querySelectorAll('#js-sticky-nav .menu-item-has-children > a');\n\n\t\t// Loop through each parent menu\n\t\t[].forEach.call(toggles, function (ele, index) {\n\t\t\t// Attach a click event\n\t\t\tele.addEventListener('click', function (event) {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tevent.stopPropagation();\n\n\t\t\t\t// Set the aria-hidden and classes appropriately depending whether it's closed or not.\n\t\t\t\tif (!this.parentNode.classList.contains('--is-expanded')) {\n\t\t\t\t\tthis.parentNode.classList.add('--is-expanded');\n\t\t\t\t\tthis.parentNode.querySelector('.sub-menu').setAttribute('aria-hidden', false);\n\t\t\t\t} else {\n\t\t\t\t\tthis.parentNode.classList.remove('--is-expanded');\n\t\t\t\t\tthis.parentNode.querySelector('.sub-menu').setAttribute('aria-hidden', true);\n\t\t\t\t}\n\t\t\t}, false);\n\t\t});\n\n\t\t/**\n   * We add another listener since when passing true to the original one, the second menu behaves erratically.\n   * Keep the following lines in case we want the same button to close the submenus first and then the main menu.\n   * Useful if we are using the sliding technique.\n  document.getElementById( 'js-menu-toggle' ).addEventListener( 'click', function( e ) {\n  \t// We look for any opened submenu.\n  \tvar openedSubmenu = document.querySelector( '.sub-menu[aria-hidden=\"false\"]' );\n  \tif ( openedSubmenu ) {\n  \t\t// We prevent the default behaviour, i.e closing the menu.\n  \t\te.preventDefault();\n  \t\te.stopPropagation();\n  \t\t\t// We close the sub menu first.\n  \t\topenedSubmenu.setAttribute( 'aria-hidden', 'true' );\n  \t\topenedSubmenu.parentNode.classList.remove( '--is-expanded' );\n  \t}\n  }, true );\n  */\n\t}\n\n\t/**\n  * Initializes all search feature implementation\n  *\n  * @return void\n  */\n\tfunction initSearch() {\n\t\t// DOM elements for later re-use\n\t\tvar bodyElement = $('body');\n\t\tvar standAloneSearchInput = $('.site-main .search-form input[type=\"search\"]');\n\t\tvar totalStandAloneSearchInput = standAloneSearchInput.length;\n\t\tvar navbarSearchInput = $('.navigation__search input[type=\"search\"]');\n\t\tvar totalNavbarSearchInput = navbarSearchInput.length;\n\t\tvar closeSearchDialogElement = $('.js-close-header-search');\n\n\t\t/**\n   * Whenever we click on the search icon in the header\n   *\n   * @param Event e\n   *\n   * @return void\n   */\n\t\t$('.js-open-header-search').on('click', function (e) {\n\t\t\te.preventDefault();\n\n\t\t\tbodyElement.addClass('ck-search__is-opening').delay(250).queue(function () {\n\t\t\t\tbodyElement.removeClass('ck-search__is-opening').addClass('ck-search__is-open').dequeue();\n\t\t\t});\n\t\t});\n\n\t\t/**\n   * Whenever we click on the close icon in the header\n   *\n   * @param Event e\n   *\n   * @return void\n   */\n\t\tcloseSearchDialogElement.on('click', function (e) {\n\t\t\te.preventDefault();\n\n\t\t\t// Below are mainly for animations. Quite ugly though.\n\t\t\tbodyElement.removeClass('ck-search__is-open ck-search__is-closed').addClass('ck-search__is-pre-closing').delay(250).queue(function () {\n\t\t\t\tbodyElement.removeClass('ck-search__is-pre-closing').addClass('ck-search__is-closing').dequeue();\n\t\t\t}).delay(250).queue(function () {\n\t\t\t\tbodyElement.removeClass('ck-search__is-closing').addClass('ck-search__is-closed').dequeue();\n\t\t\t}).delay(250).queue(function () {\n\t\t\t\tbodyElement.removeClass('ck-search__is-closed').dequeue();\n\t\t\t});\n\t\t});\n\n\t\t// Whenever the user inputs something in the search inputs\n\t\t$('.search-form input[type=\"search\"]').each(function (index) {\n\t\t\t$(this).on('keyup', debounce(function (e) {\n\t\t\t\tif (this.value.length > 0) {\n\t\t\t\t\tbodyElement.removeClass('ck-search__has-focus').addClass('ck-search__is-not-empty').delay(250).queue(function () {\n\t\t\t\t\t\tbodyElement.addClass('ck-search_recommendation-closed').dequeue();\n\t\t\t\t\t}).delay(275).queue(function () {\n\t\t\t\t\t\tbodyElement.addClass('ck-search_recommendation-hidden').dequeue();\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tbodyElement.removeClass('ck-search__is-not-empty ck-search_recommendation-closed ck-search_recommendation-hidden').addClass('ck-search__has-focus');\n\t\t\t\t}\n\t\t\t}, 500));\n\t\t});\n\n\t\t// The is-not-empty class is added so that we have the green color for the submit button.\n\t\tif (totalNavbarSearchInput) {\n\t\t\tif (navbarSearchInput.val().length) {\n\t\t\t\tbodyElement.addClass('ck-search__is-not-empty ck-search_recommendation-closed ck-search_recommendation-hidden');\n\t\t\t}\n\t\t}\n\n\t\tif (totalStandAloneSearchInput) {\n\t\t\t// Add focus to show recommended links.\n\t\t\tstandAloneSearchInput.on('focus', debounce(function (e) {\n\t\t\t\tbodyElement.addClass('ck-search__has-focus');\n\t\t\t}, 500));\n\n\t\t\tstandAloneSearchInput.on('blur', debounce(function (e) {\n\t\t\t\tbodyElement.removeClass('ck-search__has-focus');\n\t\t\t}, 500));\n\t\t}\n\n\t\tif (totalStandAloneSearchInput || totalNavbarSearchInput) {\n\t\t\t/**\n    * Closes the dialog upon hitting escape\n    *\n    * @param Event e\n    *\n    * @return void\n    */\n\t\t\tbodyElement.on('keyup', function (e) {\n\t\t\t\tif (27 === e.keyCode) {\n\t\t\t\t\tif (bodyElement.hasClass('ck-search__is-open')) {\n\t\t\t\t\t\t// close the dialog\n\t\t\t\t\t\tcloseSearchDialogElement.click();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Whenever the user submits the search form, redirect to /search/i/search-query\n\t\t$('.search-form').each(function () {\n\t\t\t$(this).on('submit', function () {\n\t\t\t\tvar searchAction = $(this).attr('action');\n\n\t\t\t\t// search for category_name\n\t\t\t\tvar categoryName = '';\n\t\t\t\t$(this).find('#category_name').each(function () {\n\t\t\t\t\tcategoryName = $(this).val();\n\t\t\t\t});\n\n\t\t\t\t//redirect the \n\t\t\t\t$(this).find('.search-field').each(function () {\n\t\t\t\t\tvar searchInput = $(this).val();\n\t\t\t\t\tif (searchInput !== '') {\n\t\t\t\t\t\tsearchInput = searchInput.replace(/ /g, '-');\n\t\t\t\t\t\tvar searchUrl = searchAction + searchInput;\n\t\t\t\t\t\tif (categoryName !== '') {\n\t\t\t\t\t\t\tsearchUrl += '?category_name=' + categoryName;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar encodedSearchUrl = encodeURI(searchUrl);\n\t\t\t\t\t\t$(location).attr('href', encodedSearchUrl);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn false;\n\t\t\t});\n\t\t});\n\t}\n\tck_ready(initSearch);\n\tck_ready(setup);\n})(undefined, jQuery);"},366:function(t,e,n){n(7)(n(367))},367:function(t,e){t.exports="'use strict';\n\n/**\n * Credit Karma\n */\n\n(function (window, undefined) {\n\t'use strict';\n\n\t/**\n  * Toggle Advertiser diclosure box\n  */\n\n\tfunction toggleAdvertiserDisclosure() {\n\t\tif (!document.body.classList.contains('tax-ck-group') && !document.body.classList.contains('single-ck-explore')) {\n\t\t\tvar toggle = document.querySelector('#advertiser-disclosure > a'),\n\t\t\t    adDisclosure = document.getElementById('advertiser-disclosure'),\n\t\t\t    toggleClose = document.querySelector('#advertiser-disclosure span.-close');\n\n\t\t\tif (toggle) {\n\t\t\t\ttoggle.addEventListener('click', function (event) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\tif (!adDisclosure.classList.contains('-show')) {\n\t\t\t\t\t\tadDisclosure.classList.add('-show');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tadDisclosure.classList.remove('-show');\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\ttoggleClose.addEventListener('click', function (event) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\tif (adDisclosure.classList.contains('-show')) {\n\t\t\t\t\t\tadDisclosure.classList.remove('-show');\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n  * Fire tracking event when an element clicked\n  */\n\tfunction fireTracking() {\n\t\tvar buttons = document.querySelectorAll('[data-click-tracking-key]');\n\n\t\tif (typeof fbq === 'undefined') {\n\t\t\treturn;\n\t\t}\n\n\t\t[].forEach.call(buttons, function (ele, index) {\n\t\t\tele.addEventListener('click', function (event) {\n\t\t\t\tfbq('track', 'TakeCC_CDT');\n\t\t\t\tFLOOD1();\n\t\t\t}, false);\n\t\t});\n\t}\n\n\t/**\n  * Send GA Click events\n  */\n\tfunction sendGaClickEvents() {\n\t\tvar links = document.querySelectorAll('a');\n\t\t[].forEach.call(links, function (ele, index) {\n\t\t\tele.addEventListener('click', function (event) {\n\t\t\t\tga('send', 'event', {\n\t\t\t\t\teventCategory: 'CMS',\n\t\t\t\t\teventAction: 'click',\n\t\t\t\t\teventLabel: event.target.href\n\t\t\t\t});\n\t\t\t}, false);\n\t\t});\n\t}\n\n\t/**\n  * Shows/hides more content in the last update box\n  */\n\tfunction toggleLastUpdate() {\n\t\t// Check if we are on the single page.\n\t\tif (document.body.classList.contains('single')) {\n\t\t\t// Look for any toggler in the page.\n\t\t\tvar togglers = document.querySelectorAll('.js-ck__toggle--previous-updates');\n\t\t\t[].forEach.call(togglers, function (el, i) {\n\t\t\t\ttogglers[i].addEventListener('click', function (e) {\n\t\t\t\t\te.preventDefault();\n\n\t\t\t\t\t// Add expanded class to the parent element.\n\t\t\t\t\ttogglers[i].parentElement.classList.toggle('expanded');\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n  * Shows/hides the fast facts content box\n  */\n\tfunction toggleFastFacts() {\n\t\tvar togglers = document.querySelectorAll('.js-ck__toggle--fast-facts');\n\t\t[].forEach.call(togglers, function (el, i) {\n\t\t\ttogglers[i].addEventListener('click', function (e) {\n\t\t\t\te.preventDefault();\n\n\t\t\t\t// Add expanded class to the grand parent element.\n\t\t\t\ttogglers[i].parentElement.parentElement.classList.toggle('expanded');\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n  * Shows/hides the data breach collapsible\n  */\n\tfunction toggleDataBreach() {\n\t\tvar togglers = document.querySelectorAll('.js-data-breach__toggle');\n\t\t[].forEach.call(togglers, function (el, i) {\n\t\t\ttogglers[i].addEventListener('click', function (e) {\n\t\t\t\te.preventDefault();\n\n\t\t\t\t// Add expanded class to the grand parent element.\n\t\t\t\ttogglers[i].parentElement.parentElement.classList.toggle('expanded');\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n  * Function to disable clicks on header items in the RevMar sidebar menu\n  */\n\tfunction disableSidebarHeaderNavigation() {\n\t\tif (document.getElementById('menu-revmar-menu')) {\n\t\t\tjQuery(document.getElementById('menu-revmar-menu')).on('click', '> li.menu-item-has-children > a', function (e) {\n\t\t\t\te.preventDefault();\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n  * Function to init slick carousel\n  */\n\tfunction initSlick() {\n\t\t// Carousel for hero images.\n\t\tvar ckCarouselSlick = jQuery('.ck-carousel__slick');\n\n\t\tif (ckCarouselSlick.length) {\n\t\t\tckCarouselSlick.slick({\n\t\t\t\tdots: false,\n\t\t\t\tresponsive: [{\n\t\t\t\t\tbreakpoint: 480,\n\t\t\t\t\tsettings: {\n\t\t\t\t\t\tarrows: false,\n\t\t\t\t\t\tdots: true\n\t\t\t\t\t}\n\t\t\t\t}]\n\t\t\t});\n\t\t}\n\n\t\t// Carousel for anchor links having more than 3 items.\n\t\tvar ckAnchorLinks = document.querySelectorAll('.ck-anchor__links');\n\t\tvar ckAnchorLinksChildren = 0;\n\t\t[].forEach.call(ckAnchorLinks, function (ele, index) {\n\t\t\tckAnchorLinksChildren = ele.querySelectorAll('.ck-anchor_links--item').length;\n\n\t\t\tif (ckAnchorLinksChildren > 3) {\n\t\t\t\tjQuery(ele).slick({\n\t\t\t\t\tslidesToShow: 3,\n\t\t\t\t\tinfinite: false,\n\t\t\t\t\tresponsive: [{\n\t\t\t\t\t\tbreakpoint: 1020,\n\t\t\t\t\t\tsettings: {\n\t\t\t\t\t\t\tslidesToShow: 3,\n\t\t\t\t\t\t\tdots: false\n\t\t\t\t\t\t}\n\t\t\t\t\t}, {\n\t\t\t\t\t\tbreakpoint: 768,\n\t\t\t\t\t\tsettings: {\n\t\t\t\t\t\t\tslidesToShow: 2,\n\t\t\t\t\t\t\tarrows: false,\n\t\t\t\t\t\t\tdots: true\n\t\t\t\t\t\t}\n\t\t\t\t\t}, {\n\t\t\t\t\t\tbreakpoint: 480,\n\t\t\t\t\t\tsettings: {\n\t\t\t\t\t\t\tslidesToShow: 1,\n\t\t\t\t\t\t\tarrows: false,\n\t\t\t\t\t\t\tdots: true\n\t\t\t\t\t\t}\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tif ('production' !== ckSettings.environment) {\n\t\t\t// SEM Wrap carousel if any\n\t\t\tvar ckSemWrapSlick = jQuery('.ck-sem-wrap__slick');\n\t\t\tif (ckSemWrapSlick.length) {\n\t\t\t\tvar isInfinite = ckSemWrapSlick.data('slick-infinite') === true;\n\n\t\t\t\tckSemWrapSlick.slick({\n\t\t\t\t\tslidesToShow: 3,\n\t\t\t\t\tinfinite: isInfinite,\n\t\t\t\t\tresponsive: [{\n\t\t\t\t\t\tbreakpoint: 1020,\n\t\t\t\t\t\tsettings: {\n\t\t\t\t\t\t\tslidesToShow: 3,\n\t\t\t\t\t\t\tdots: false\n\t\t\t\t\t\t}\n\t\t\t\t\t}, {\n\t\t\t\t\t\tbreakpoint: 768,\n\t\t\t\t\t\tsettings: {\n\t\t\t\t\t\t\tslidesToShow: 2,\n\t\t\t\t\t\t\tdots: false\n\t\t\t\t\t\t}\n\t\t\t\t\t}, {\n\t\t\t\t\t\tbreakpoint: 480,\n\t\t\t\t\t\tsettings: {\n\t\t\t\t\t\t\tslidesToShow: 1\n\t\t\t\t\t\t}\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tck_ready(toggleAdvertiserDisclosure);\n\tck_ready(fireTracking);\n\tck_ready(sendGaClickEvents);\n\tck_ready(toggleLastUpdate);\n\tck_ready(toggleFastFacts);\n\tck_ready(disableSidebarHeaderNavigation);\n\tck_ready(toggleDataBreach);\n\tck_ready(initSlick);\n})(undefined);"},368:function(t,e,n){"use strict";var i=function(){function t(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(e,n,i){return n&&t(e.prototype,n),i&&t(e,i),e}}();var o=function(){function t(){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this.checkForOldCards()}return i(t,[{key:"checkForOldCards",value:function(){document.querySelectorAll(".ck-offer-widget").length&&(document.body.classList.add("--contains-old-cards"),this.disableResponsiveness())}},{key:"disableResponsiveness",value:function(){jQuery('meta[name="viewport"]').attr("content","width=1200, initial-scale=0")}}]),t}();document.body.classList.contains("single-ck-email-landing")&&new o},369:function(t,e,n){"use strict";var i=function(){function t(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(e,n,i){return n&&t(e.prototype,n),i&&t(e,i),e}}();var o=function(){function t(){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this.text=["builders","creators","dreamers","explorers","strivers"],this.counter=1,this.rotatingTextContainer=document.getElementById("rotatingText"),this.inst=setInterval(this.textRotate.bind(this),1500),this.carousel=jQuery(".benefits-carousel"),this.carousel.slick({infinite:!0,dots:!0,arrows:!0,slidesToShow:1,nextArrow:'<button class="slick-next slick-arrow" aria-label="Next" type="button"><i class="arrow right"></i></button>',prevArrow:'<button class="slick-prev slick-arrow" aria-label="Previous" type="button"><i class="arrow left"></i></button>'})}return i(t,[{key:"textRotate",value:function(){this.rotatingTextContainer.innerHTML=this.text[this.counter],this.counter++,this.counter>=this.text.length&&(this.counter=0,clearInterval(this.inst))}}]),t}();document.body.classList.contains("page-template-page-careers")&&new o},370:function(t,e,n){"use strict";var i=function(){function t(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(e,n,i){return n&&t(e.prototype,n),i&&t(e,i),e}}();var o=function(){function t(){var e=this;if(function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this.navigationElement=document.querySelector(".ck-revmar__navigation"),null!==this.navigationElement){this.navigationElement.addEventListener("click",function(t){if("A"===t.target.tagName){var n=t.target.parentNode;(t.target.classList.contains("ck-revmar__navigation--toggle")||t.target.classList.contains("ck-revmar__navigation--close"))&&(t.preventDefault(),e.toggleNavigation()),n.classList.contains("menu-item-has-children")&&"#"===t.target.getAttribute("href")&&(t.preventDefault(),n.classList.toggle("--is-open"),e.updateAria(n))}});var n=this.navigationElement.querySelector(".ck-revmar__navigation--content ul li:first-child");null!==n&&(n.classList.add("--is-open"),n.setAttribute("aria-expanded","true"))}}return i(t,[{key:"toggleNavigation",value:function(){this.navigationElement.classList.toggle("--is-open"),this.updateAria(this.navigationElement)}},{key:"updateAria",value:function(t){t.classList.contains("--is-open")?t.setAttribute("aria-expanded","true"):t.setAttribute("aria-expanded","false")}}]),t}();document.body.classList.contains("single-ck-explore")&&new o},371:function(t,e,n){"use strict";var i=function(){function t(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(e,n,i){return n&&t(e.prototype,n),i&&t(e,i),e}}(),o=a(n(100)),r=a(n(372));function a(t){return t&&t.__esModule?t:{default:t}}var s=function(){function t(){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),document.body.classList.contains("revmar-template-v2")||document.body.classList.contains("single-ck-email-landing")?(this.cardSelector=".ck-offer__card",this.imageSelector=".ck-offer__card--photo",this.titleSelector=".ck-offer__card--title",this.quoteSelector=".ck-offer__card--headline",this.ratingSelector=".ck-offer__card--count",this.starsSelector='span[class*="stars"]'):document.body.classList.contains("revmar-template-default")&&(this.cardSelector=".ck-offer-widget",this.imageSelector=".cardLogo",this.titleSelector=".ccTitle a");var e=this.buildGlossary(),n=document.querySelector(".ck-revmar__glossary");n.classList.add("--ready"),n.appendChild(e),this.removeNumbers(),new o.default('a[href*="!#"]')}return i(t,[{key:"removeNumbers",value:function(){var t=document.querySelector(".ck-revmar__glossary"),e=t.classList.contains("desktop-hidden"),n=t.classList.contains("mobile-hidden"),i=document.querySelector(".ck-explore"),o=document.querySelector(".ck-el__content--main"),r=document.body.classList.contains("single-ck-explore");e||(r?i.classList.add("desktop-numbers-hidden"):o.classList.add("desktop-numbers-hidden")),n||(r?i.classList.add("mobile-numbers-hidden"):o.classList.add("mobile-numbers-hidden"))}},{key:"buildGlossary",value:function(){var t=this,e=document.querySelectorAll(this.cardSelector),n=[].concat(function(t){if(Array.isArray(t)){for(var e=0,n=Array(t.length);e<t.length;e++)n[e]=t[e];return n}return Array.from(t)}(e)),i=document.createElement("ul");i.classList.add("list-loading");var o=void 0,a=void 0,s=void 0,l=void 0,c=void 0,u=void 0,d=void 0,f=void 0,h=null;return n.map(function(e){if(o=document.createElement("li"),(a=document.createElement("a")).setAttribute("href","#"+(0,r.default)(e.getAttribute("id"))),(s=document.createElement("img")).setAttribute("src",(0,r.default)(e.querySelector(t.imageSelector).getAttribute("src"))),(l=document.createElement("p")).textContent=(0,r.default)(e.querySelector(t.titleSelector).textContent),(d=document.createElement("div")).classList.add("ck-offer__card--stars"),f=document.createElement("p"),h=document.createElement("span"),null===e.querySelector(t.ratingSelector)&&(t.ratingSelector=".ck-offer__card--reviews p"),null!==e.querySelector(t.ratingSelector)){f.textContent=(0,r.default)(e.querySelector(t.ratingSelector).textContent);var n=e.querySelector(t.starsSelector).className.split(" ");h.classList.add(n[0],n[1]),d.appendChild(f),d.appendChild(h),(u=document.createElement("p")).textContent=(0,r.default)(e.querySelector(t.quoteSelector).textContent),(c=document.createElement("div")).classList.add("ck-offer__card--title"),c.appendChild(l),c.appendChild(u),a.appendChild(s),a.appendChild(c),a.appendChild(d),o.appendChild(a),i.appendChild(o)}}),i}}]),t}(),l=document.body.classList.contains("single-ck-email-landing");(document.body.classList.contains("single-ck-explore")&&document.querySelector(".ck-revmar__glossary")||l&&document.querySelector(".ck-revmar__glossary"))&&new s},372:function(t,e,n){var i=n(342),o=n(345),r=n(375);function a(t,e){return new r(e).process(t)}for(var s in(e=t.exports=a).filterXSS=a,e.FilterXSS=r,i)e[s]=i[s];for(var s in o)e[s]=o[s];"undefined"!=typeof window&&(window.filterXSS=t.exports),"undefined"!=typeof self&&"undefined"!=typeof DedicatedWorkerGlobalScope&&self instanceof DedicatedWorkerGlobalScope&&(self.filterXSS=t.exports)},373:function(t,e,n){var i=n(343),o=n(374);n(344);function r(t){return null==t}function a(t){(t=function(t){var e={};for(var n in t)e[n]=t[n];return e}(t||{})).whiteList=t.whiteList||i.whiteList,t.onAttr=t.onAttr||i.onAttr,t.onIgnoreAttr=t.onIgnoreAttr||i.onIgnoreAttr,t.safeAttrValue=t.safeAttrValue||i.safeAttrValue,this.options=t}a.prototype.process=function(t){if(!(t=(t=t||"").toString()))return"";var e=this.options,n=e.whiteList,i=e.onAttr,a=e.onIgnoreAttr,s=e.safeAttrValue;return o(t,function(t,e,o,l,c){var u=n[o],d=!1;if(!0===u?d=u:"function"==typeof u?d=u(l):u instanceof RegExp&&(d=u.test(l)),!0!==d&&(d=!1),l=s(o,l)){var f,h={position:e,sourcePosition:t,source:c,isWhite:d};return d?r(f=i(o,l,h))?o+":"+l:f:r(f=a(o,l,h))?void 0:f}})},t.exports=a},374:function(t,e,n){var i=n(344);t.exports=function(t,e){";"!==(t=i.trimRight(t))[t.length-1]&&(t+=";");var n=t.length,o=!1,r=0,a=0,s="";function l(){if(!o){var n=i.trim(t.slice(r,a)),l=n.indexOf(":");if(-1!==l){var c=i.trim(n.slice(0,l)),u=i.trim(n.slice(l+1));if(c){var d=e(r,s.length,c,u,n);d&&(s+=d+"; ")}}}r=a+1}for(;a<n;a++){var c=t[a];if("/"===c&&"*"===t[a+1]){var u=t.indexOf("*/",a+2);if(-1===u)break;r=(a=u+1)+1,o=!1}else"("===c?o=!0:")"===c?o=!1:";"===c?o||l():"\n"===c&&l()}return i.trim(s)}},375:function(t,e,n){var i=n(220).FilterCSS,o=n(342),r=n(345),a=r.parseTag,s=r.parseAttr,l=n(221);function c(t){return null==t}function u(t){(t=function(t){var e={};for(var n in t)e[n]=t[n];return e}(t||{})).stripIgnoreTag&&(t.onIgnoreTag&&console.error('Notes: cannot use these two options "stripIgnoreTag" and "onIgnoreTag" at the same time'),t.onIgnoreTag=o.onIgnoreTagStripAll),t.whiteList=t.whiteList||o.whiteList,t.onTag=t.onTag||o.onTag,t.onTagAttr=t.onTagAttr||o.onTagAttr,t.onIgnoreTag=t.onIgnoreTag||o.onIgnoreTag,t.onIgnoreTagAttr=t.onIgnoreTagAttr||o.onIgnoreTagAttr,t.safeAttrValue=t.safeAttrValue||o.safeAttrValue,t.escapeHtml=t.escapeHtml||o.escapeHtml,this.options=t,!1===t.css?this.cssFilter=!1:(t.css=t.css||{},this.cssFilter=new i(t.css))}u.prototype.process=function(t){if(!(t=(t=t||"").toString()))return"";var e=this.options,n=e.whiteList,i=e.onTag,r=e.onIgnoreTag,u=e.onTagAttr,d=e.onIgnoreTagAttr,f=e.safeAttrValue,h=e.escapeHtml,g=this.cssFilter;e.stripBlankChar&&(t=o.stripBlankChar(t)),e.allowCommentTag||(t=o.stripCommentTag(t));var p=!1;if(e.stripIgnoreTagBody){p=o.StripTagBody(e.stripIgnoreTagBody,r);r=p.onIgnoreTag}var m=a(t,function(t,e,o,a,p){var m,v={sourcePosition:t,position:e,isClosing:p,isWhite:n.hasOwnProperty(o)};if(!c(m=i(o,a,v)))return m;if(v.isWhite){if(v.isClosing)return"</"+o+">";var b=function(t){var e=l.spaceIndex(t);if(-1===e)return{html:"",closing:"/"===t[t.length-2]};var n="/"===(t=l.trim(t.slice(e+1,-1)))[t.length-1];return n&&(t=l.trim(t.slice(0,-1))),{html:t,closing:n}}(a),y=n[o],w=s(b.html,function(t,e){var n,i=-1!==l.indexOf(y,t);return c(n=u(o,t,e,i))?i?(e=f(o,t,e,g))?t+'="'+e+'"':t:c(n=d(o,t,e,i))?void 0:n:n});a="<"+o;return w&&(a+=" "+w),b.closing&&(a+=" /"),a+=">"}return c(m=r(o,a,v))?h(a):m},h);return p&&(m=p.remove(m)),m},t.exports=u},376:function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i,o=function(){function t(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(e,n,i){return n&&t(e.prototype,n),i&&t(e,i),e}}(),r=n(377),a=(i=r)&&i.__esModule?i:{default:i};var s=function(){function t(){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this.initialize()}return o(t,[{key:"initialize",value:function(){this.myLazyLoad=new a.default({elements_selector:".lazy-load"})}}]),t}();e.default=s,new s},377:function(t,e,n){"use strict";n.r(e);const i=(t,e)=>t.getAttribute("data-"+e),o=t=>((t,e,n)=>{var i="data-"+e;null!==n?t.setAttribute(i,n):t.removeAttribute(i)})(t,"was-processed","true"),r=t=>"true"===i(t,"was-processed"),a=function(t){return t.getBoundingClientRect().top+window.pageYOffset-t.ownerDocument.documentElement.clientTop},s=function(t,e,n){return(e===window?window.innerHeight+window.pageYOffset:a(e)+e.offsetHeight)<=a(t)-n},l=function(t){return t.getBoundingClientRect().left+window.pageXOffset-t.ownerDocument.documentElement.clientLeft},c=function(t,e,n){const i=window.innerWidth;return(e===window?i+window.pageXOffset:l(e)+i)<=l(t)-n},u=function(t,e,n){return(e===window?window.pageYOffset:a(e))>=a(t)+n+t.offsetHeight},d=function(t,e,n){return(e===window?window.pageXOffset:l(e))>=l(t)+n+t.offsetWidth};function f(t,e,n){return!(s(t,e,n)||u(t,e,n)||c(t,e,n)||d(t,e,n))}const h=function(t,e){var n;let i=new t(e);try{n=new CustomEvent("LazyLoad::Initialized",{detail:{instance:i}})}catch(t){(n=document.createEvent("CustomEvent")).initCustomEvent("LazyLoad::Initialized",!1,!1,{instance:i})}window.dispatchEvent(n)};const g=(t,e)=>e?t.replace(/\.(jpe?g|png)/gi,".webp"):t,p="undefined"!=typeof window,m=p&&!("onscroll"in window)||/(gle|ing|ro)bot|crawl|spider/i.test(navigator.userAgent),v=p&&"classList"in document.createElement("p"),b=p&&(!(!(y=document.createElement("canvas")).getContext||!y.getContext("2d"))&&0===y.toDataURL("image/webp").indexOf("data:image/webp"));var y;const w=(t,e)=>{v?t.classList.add(e):t.className+=(t.className?" ":"")+e},_=function(t,e,n,o){for(let r,a=0;r=t.children[a];a+=1)if("SOURCE"===r.tagName){let t=i(r,n);k(r,e,t,o)}},k=function(t,e,n,i){n&&t.setAttribute(e,g(n,i))},S={IMG:(t,e)=>{const n=b&&e.to_webp,o=e.data_srcset,r=t.parentNode;r&&"PICTURE"===r.tagName&&_(r,"srcset",o,n);const a=i(t,e.data_sizes);k(t,"sizes",a);const s=i(t,o);k(t,"srcset",s,n);const l=i(t,e.data_src);k(t,"src",l,n)},IFRAME:(t,e)=>{const n=i(t,e.data_src);k(t,"src",n)},VIDEO:(t,e)=>{const n=e.data_src,o=i(t,n);_(t,"src",n),k(t,"src",o),t.load()}},E=(t,e)=>{const n=e._settings,o=t.tagName,r=S[o];if(r)return r(t,n),e._updateLoadingCount(1),void(e._elements=((t,e)=>t.filter(t=>t!==e))(e._elements,t));((t,e)=>{const n=b&&e.to_webp,o=i(t,e.data_src),r=i(t,e.data_bg);if(o){let e=g(o,n);t.style.backgroundImage=`url("${e}")`}if(r){let e=g(r,n);t.style.backgroundImage=e}})(t,n)},x=function(t,e){t&&t(e)},L=(t,e,n)=>{t.addEventListener(e,n)},A=(t,e,n)=>{t.removeEventListener(e,n)},T=(t,e,n)=>{A(t,"load",e),A(t,"loadeddata",e),A(t,"error",n)},C=function(t,e,n){var i=n._settings;const o=e?i.class_loaded:i.class_error,r=e?i.callback_load:i.callback_error,a=t.target;((t,e)=>{v?t.classList.remove(e):t.className=t.className.replace(new RegExp("(^|\\s+)"+e+"(\\s+|$)")," ").replace(/^\s+/,"").replace(/\s+$/,"")})(a,i.class_loading),w(a,o),x(r,a),n._updateLoadingCount(-1)},I=(t,e)=>{const n=o=>{C(o,!0,e),T(t,n,i)},i=o=>{C(o,!1,e),T(t,n,i)};((t,e,n)=>{L(t,"load",e),L(t,"loadeddata",e),L(t,"error",n)})(t,n,i)},O=["IMG","IFRAME","VIDEO"];const q=function(t){this._settings=Object.assign({},(()=>({elements_selector:"img",container:window,threshold:300,throttle:150,data_src:"src",data_srcset:"srcset",data_sizes:"sizes",data_bg:"bg",class_loading:"loading",class_loaded:"loaded",class_error:"error",class_initial:"initial",skip_invisible:!0,callback_load:null,callback_error:null,callback_set:null,callback_enter:null,callback_finish:null,to_webp:!1}))(),t),this._loadingCount=0,this._queryOriginNode=this._settings.container===window?document:this._settings.container,this._previousLoopTime=0,this._loopTimeout=null,this._boundHandleScroll=this.handleScroll.bind(this),this._isFirstLoop=!0,window.addEventListener("resize",this._boundHandleScroll),this.update()};q.prototype={_loopThroughElements:function(t){const e=this._settings,n=this._elements,i=n?n.length:0;let o,r=[],a=this._isFirstLoop;if(a&&(this._isFirstLoop=!1),0!==i){for(o=0;o<i;o++){let i=n[o];e.skip_invisible&&null===i.offsetParent||(t||f(i,e.container,e.threshold))&&(a&&w(i,e.class_initial),this.load(i),r.push(o))}((t,e)=>{for(;e.length;)t.splice(e.pop(),1)})(n,r)}else this._stopScrollHandler()},_startScrollHandler:function(){this._isHandlingScroll||(this._isHandlingScroll=!0,this._settings.container.addEventListener("scroll",this._boundHandleScroll))},_stopScrollHandler:function(){this._isHandlingScroll&&(this._isHandlingScroll=!1,this._settings.container.removeEventListener("scroll",this._boundHandleScroll))},_updateLoadingCount:function(t){this._loadingCount+=t,0===this._elements.length&&0===this._loadingCount&&x(this._settings.callback_finish)},handleScroll:function(){const t=this._settings.throttle;if(0!==t){let e=Date.now(),n=t-(e-this._previousLoopTime);n<=0||n>t?(this._loopTimeout&&(clearTimeout(this._loopTimeout),this._loopTimeout=null),this._previousLoopTime=e,this._loopThroughElements()):this._loopTimeout||(this._loopTimeout=setTimeout(function(){this._previousLoopTime=Date.now(),this._loopTimeout=null,this._loopThroughElements()}.bind(this),n))}else this._loopThroughElements()},loadAll:function(){this._loopThroughElements(!0)},update:function(t){const e=this._settings,n=t||this._queryOriginNode.querySelectorAll(e.elements_selector);this._elements=(t=>t.filter(t=>!r(t)))(Array.prototype.slice.call(n)),m?this.loadAll():(this._loopThroughElements(),this._startScrollHandler())},destroy:function(){window.removeEventListener("resize",this._boundHandleScroll),this._loopTimeout&&(clearTimeout(this._loopTimeout),this._loopTimeout=null),this._stopScrollHandler(),this._elements=null,this._queryOriginNode=null,this._settings=null},load:function(t,e){!function(t,e,n){var i=e._settings;!n&&r(t)||(x(i.callback_enter,t),O.indexOf(t.tagName)>-1&&(I(t,e),w(t,i.class_loading)),E(t,e),o(t),x(i.callback_set,t))}(t,this,e)}},p&&function(t,e){if(e)if(e.length)for(let n,i=0;n=e[i];i+=1)h(t,n);else h(t,e)}(q,window.lazyLoadOptions),e.default=q},378:function(t,e,n){"use strict";var i,o=n(222),r=(i=o)&&i.__esModule?i:{default:i};window.addEventListener("DOMContentLoaded",function(){var t=document.querySelectorAll(".author-info .avatar");(0,r.default)(t)})},379:function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=function(){function t(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(e,n,i){return n&&t(e.prototype,n),i&&t(e,i),e}}();var o=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"js-tooltip",n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"js-close-tooltip";!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this.tooltip=document.getElementById(e),this.desktop=window.matchMedia("(min-width: 768px)").matches,this.container=document.querySelector(".tooltip-container"),this.closeBtn=document.getElementById(n),this.init(this.tooltip)}return i(t,[{key:"init",value:function(t){var e=this;t&&(t.addEventListener("click",function(){return e.openTooltip()}),this.closeBtn.addEventListener("click",function(){return e.closeTooltip()}))}},{key:"openTooltip",value:function(){this.desktop||(this.closeBtn.classList.remove("hidden"),this.container.classList.add("expand"))}},{key:"closeTooltip",value:function(){this.container.classList.contains("expand")&&(this.container.classList.remove("expand"),this.closeBtn.classList.add("hidden"))}}]),t}();e.default=o,new o},380:function(t,e,n){"use strict";var i,o=n(381),r=(i=o)&&i.__esModule?i:{default:i};var a=document.querySelector(".sticky-polly"),s=document.querySelector("#editorial-navigation-sidebar"),l=document.querySelector(".nutshell"),c=document.querySelector(".editorial-navigational-sidebar-container"),u=null;if(null!==a&&null!==l)u=l;else if(null!==a&&null!==c){var d=c.querySelector(".entry-content");u=d}null!==a&&null!==u&&window.addEventListener("scroll",function(){var t=u.getBoundingClientRect();s.style.top=t.top+"px"}),null!==a&&null!==u&&window.addEventListener("load",function(){r.default.add(a);var t=u.getBoundingClientRect();s.style.top=t.top+"px",s.classList.add("visible")})},381:function(t,e,n){!function(e,n){"use strict";var i=function(){function t(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(e,n,i){return n&&t(e.prototype,n),i&&t(e,i),e}}();var o,r=!1,a=void 0!==e;a&&e.getComputedStyle?(o=n.createElement("div"),["","-webkit-","-moz-","-ms-"].some(function(t){try{o.style.position=t+"sticky"}catch(t){}return""!=o.style.position})&&(r=!0)):r=!0;var s=!1,l="undefined"!=typeof ShadowRoot,c={top:null,left:null},u=[];function d(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])}function f(t){return parseFloat(t)||0}function h(t){for(var e=0;t;)e+=t.offsetTop,t=t.offsetParent;return e}var g=function(){function t(e){if(function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),!(e instanceof HTMLElement))throw new Error("First argument must be HTMLElement");if(u.some(function(t){return t._node===e}))throw new Error("Stickyfill is already applied to this node");this._node=e,this._stickyMode=null,this._active=!1,u.push(this),this.refresh()}return i(t,[{key:"refresh",value:function(){if(!r&&!this._removed){this._active&&this._deactivate();var t=this._node,i=getComputedStyle(t),o={position:i.position,top:i.top,display:i.display,marginTop:i.marginTop,marginBottom:i.marginBottom,marginLeft:i.marginLeft,marginRight:i.marginRight,cssFloat:i.cssFloat};if(!isNaN(parseFloat(o.top))&&"table-cell"!=o.display&&"none"!=o.display){this._active=!0;var a=t.style.position;"sticky"!=i.position&&"-webkit-sticky"!=i.position||(t.style.position="static");var s=t.parentNode,c=l&&s instanceof ShadowRoot?s.host:s,u=t.getBoundingClientRect(),g=c.getBoundingClientRect(),p=getComputedStyle(c);this._parent={node:c,styles:{position:c.style.position},offsetHeight:c.offsetHeight},this._offsetToWindow={left:u.left,right:n.documentElement.clientWidth-u.right},this._offsetToParent={top:u.top-g.top-f(p.borderTopWidth),left:u.left-g.left-f(p.borderLeftWidth),right:-u.right+g.right-f(p.borderRightWidth)},this._styles={position:a,top:t.style.top,bottom:t.style.bottom,left:t.style.left,right:t.style.right,width:t.style.width,marginTop:t.style.marginTop,marginLeft:t.style.marginLeft,marginRight:t.style.marginRight};var m=f(o.top);this._limits={start:u.top+e.pageYOffset-m,end:g.top+e.pageYOffset+c.offsetHeight-f(p.borderBottomWidth)-t.offsetHeight-m-f(o.marginBottom)};var v=p.position;"absolute"!=v&&"relative"!=v&&(c.style.position="relative"),this._recalcPosition();var b=this._clone={};b.node=n.createElement("div"),d(b.node.style,{width:u.right-u.left+"px",height:u.bottom-u.top+"px",marginTop:o.marginTop,marginBottom:o.marginBottom,marginLeft:o.marginLeft,marginRight:o.marginRight,cssFloat:o.cssFloat,padding:0,border:0,borderSpacing:0,fontSize:"1em",position:"static"}),s.insertBefore(b.node,t),b.docOffsetTop=h(b.node)}}}},{key:"_recalcPosition",value:function(){if(this._active&&!this._removed){var t=c.top<=this._limits.start?"start":c.top>=this._limits.end?"end":"middle";if(this._stickyMode!=t){switch(t){case"start":d(this._node.style,{position:"absolute",left:this._offsetToParent.left+"px",right:this._offsetToParent.right+"px",top:this._offsetToParent.top+"px",bottom:"auto",width:"auto",marginLeft:0,marginRight:0,marginTop:0});break;case"middle":d(this._node.style,{position:"fixed",left:this._offsetToWindow.left+"px",right:this._offsetToWindow.right+"px",top:this._styles.top,bottom:"auto",width:"auto",marginLeft:0,marginRight:0,marginTop:0});break;case"end":d(this._node.style,{position:"absolute",left:this._offsetToParent.left+"px",right:this._offsetToParent.right+"px",top:"auto",bottom:0,width:"auto",marginLeft:0,marginRight:0})}this._stickyMode=t}}}},{key:"_fastCheck",value:function(){this._active&&!this._removed&&(Math.abs(h(this._clone.node)-this._clone.docOffsetTop)>1||Math.abs(this._parent.node.offsetHeight-this._parent.offsetHeight)>1)&&this.refresh()}},{key:"_deactivate",value:function(){var t=this;this._active&&!this._removed&&(this._clone.node.parentNode.removeChild(this._clone.node),delete this._clone,d(this._node.style,this._styles),delete this._styles,u.some(function(e){return e!==t&&e._parent&&e._parent.node===t._parent.node})||d(this._parent.node.style,this._parent.styles),delete this._parent,this._stickyMode=null,this._active=!1,delete this._offsetToWindow,delete this._offsetToParent,delete this._limits)}},{key:"remove",value:function(){var t=this;this._deactivate(),u.some(function(e,n){if(e._node===t._node)return u.splice(n,1),!0}),this._removed=!0}}]),t}(),p={stickies:u,Sticky:g,forceSticky:function(){r=!1,m(),this.refreshAll()},addOne:function(t){if(!(t instanceof HTMLElement)){if(!t.length||!t[0])return;t=t[0]}for(var e=0;e<u.length;e++)if(u[e]._node===t)return u[e];return new g(t)},add:function(t){if(t instanceof HTMLElement&&(t=[t]),t.length){for(var e=[],n=function(n){var i=t[n];return i instanceof HTMLElement?u.some(function(t){if(t._node===i)return e.push(t),!0})?"continue":void e.push(new g(i)):(e.push(void 0),"continue")},i=0;i<t.length;i++)n(i);return e}},refreshAll:function(){u.forEach(function(t){return t.refresh()})},removeOne:function(t){if(!(t instanceof HTMLElement)){if(!t.length||!t[0])return;t=t[0]}u.some(function(e){if(e._node===t)return e.remove(),!0})},remove:function(t){if(t instanceof HTMLElement&&(t=[t]),t.length)for(var e=function(e){var n=t[e];u.some(function(t){if(t._node===n)return t.remove(),!0})},n=0;n<t.length;n++)e(n)},removeAll:function(){for(;u.length;)u[0].remove()}};function m(){if(!s){s=!0,r(),e.addEventListener("scroll",r),e.addEventListener("resize",p.refreshAll),e.addEventListener("orientationchange",p.refreshAll);var t=void 0,i=void 0,o=void 0;"hidden"in n?(i="hidden",o="visibilitychange"):"webkitHidden"in n&&(i="webkitHidden",o="webkitvisibilitychange"),o?(n[i]||a(),n.addEventListener(o,function(){n[i]?clearInterval(t):a()})):a()}function r(){e.pageXOffset!=c.left?(c.top=e.pageYOffset,c.left=e.pageXOffset,p.refreshAll()):e.pageYOffset!=c.top&&(c.top=e.pageYOffset,c.left=e.pageXOffset,u.forEach(function(t){return t._recalcPosition()}))}function a(){t=setInterval(function(){u.forEach(function(t){return t._fastCheck()})},500)}}r||m(),t.exports?t.exports=p:a&&(e.Stickyfill=p)}(window,document)},7:function(t,e){t.exports=function(t){function e(t){"undefined"!=typeof console&&(console.error||console.log)("[Script Loader]",t)}try{"undefined"!=typeof execScript&&"undefined"!=typeof attachEvent&&"undefined"==typeof addEventListener?execScript(t):"undefined"!=typeof eval?eval.call(null,t):e("EvalError: No eval function available")}catch(t){e(t)}}},70:function(t,e,n){(function(n){var i;!function(n){"use strict";var o,r=['a[href]:not([tabindex^="-"]):not([inert])','area[href]:not([tabindex^="-"]):not([inert])',"input:not([disabled]):not([inert])","select:not([disabled]):not([inert])","textarea:not([disabled]):not([inert])","button:not([disabled]):not([inert])",'iframe:not([tabindex^="-"]):not([inert])','audio:not([tabindex^="-"]):not([inert])','video:not([tabindex^="-"]):not([inert])','[contenteditable]:not([tabindex^="-"]):not([inert])','[tabindex]:not([tabindex^="-"]):not([inert])'];function a(t,e){this._show=this.show.bind(this),this._hide=this.hide.bind(this),this._maintainFocus=this._maintainFocus.bind(this),this._bindKeypress=this._bindKeypress.bind(this),this.container=t,this.dialog=t.querySelector('dialog, [role="dialog"], [role="alertdialog"]'),this.role=this.dialog.getAttribute("role")||"dialog",this.useDialog="show"in document.createElement("dialog")&&"DIALOG"===this.dialog.nodeName,this._listeners={},this.create(e)}function s(t){return Array.prototype.slice.call(t)}function l(t,e){return s((e||document).querySelectorAll(t))}function c(t){var e=u(t),n=t.querySelector("[autofocus]")||e[0];n&&n.focus()}function u(t){return l(r.join(","),t).filter(function(t){return!!(t.offsetWidth||t.offsetHeight||t.getClientRects().length)})}a.prototype.create=function(t){var e,n;return this._targets=this._targets||function(t){if(NodeList.prototype.isPrototypeOf(t))return s(t);if(Element.prototype.isPrototypeOf(t))return[t];if("string"==typeof t)return l(t)}(t)||(e=this.container,(n=s(e.parentNode.childNodes).filter(function(t){return 1===t.nodeType})).splice(n.indexOf(e),1),n),this.shown=this.dialog.hasAttribute("open"),this.dialog.setAttribute("role",this.role),this.useDialog?this.container.setAttribute("data-a11y-dialog-native",""):this.shown?this.container.removeAttribute("aria-hidden"):this.container.setAttribute("aria-hidden",!0),this._openers=l('[data-a11y-dialog-show="'+this.container.id+'"]'),this._openers.forEach(function(t){t.addEventListener("click",this._show)}.bind(this)),this._closers=l("[data-a11y-dialog-hide]",this.container).concat(l('[data-a11y-dialog-hide="'+this.container.id+'"]')),this._closers.forEach(function(t){t.addEventListener("click",this._hide)}.bind(this)),this._fire("create"),this},a.prototype.show=function(t){return this.shown?this:(this.shown=!0,o=document.activeElement,this.useDialog?this.dialog.showModal(t instanceof Event?void 0:t):(this.dialog.setAttribute("open",""),this.container.removeAttribute("aria-hidden"),this._targets.forEach(function(t){t.setAttribute("aria-hidden","true")})),c(this.dialog),document.body.addEventListener("focus",this._maintainFocus,!0),document.addEventListener("keydown",this._bindKeypress),this._fire("show",t),this)},a.prototype.hide=function(t){return this.shown?(this.shown=!1,this.useDialog?this.dialog.close(t instanceof Event?void 0:t):(this.dialog.removeAttribute("open"),this.container.setAttribute("aria-hidden","true"),this._targets.forEach(function(t){t.removeAttribute("aria-hidden")})),o&&o.focus(),document.body.removeEventListener("focus",this._maintainFocus,!0),document.removeEventListener("keydown",this._bindKeypress),this._fire("hide",t),this):this},a.prototype.destroy=function(){return this.hide(),this._openers.forEach(function(t){t.removeEventListener("click",this._show)}.bind(this)),this._closers.forEach(function(t){t.removeEventListener("click",this._hide)}.bind(this)),this._fire("destroy"),this._listeners={},this},a.prototype.on=function(t,e){return void 0===this._listeners[t]&&(this._listeners[t]=[]),this._listeners[t].push(e),this},a.prototype.off=function(t,e){var n=this._listeners[t].indexOf(e);return n>-1&&this._listeners[t].splice(n,1),this},a.prototype._fire=function(t,e){(this._listeners[t]||[]).forEach(function(t){t(this.container,e)}.bind(this))},a.prototype._bindKeypress=function(t){this.shown&&27===t.which&&"alertdialog"!==this.role&&(t.preventDefault(),this.hide()),this.shown&&9===t.which&&function(t,e){var n=u(t),i=n.indexOf(document.activeElement);e.shiftKey&&0===i?(n[n.length-1].focus(),e.preventDefault()):e.shiftKey||i!==n.length-1||(n[0].focus(),e.preventDefault())}(this.dialog,t)},a.prototype._maintainFocus=function(t){this.shown&&!this.container.contains(t.target)&&c(this.dialog)},void 0!==t.exports?t.exports=a:void 0===(i=function(){return a}.apply(e,[]))||(t.exports=i)}(void 0!==n||window)}).call(this,n(3))}});
//# sourceMappingURL=credit-karma.min.js.map;
!function(t){var e={};function n(r){if(e[r])return e[r].exports;var o=e[r]={i:r,l:!1,exports:{}};return t[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}n.m=t,n.c=e,n.d=function(t,e,r){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:r})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var o in t)n.d(r,o,function(e){return t[e]}.bind(null,o));return r},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="",n(n.s=440)}({100:function(t,e,n){(function(n){var r,o;/*! smooth-scroll v12.1.5 | (c) 2017 Chris Ferdinandi | MIT License | http://github.com/cferdinandi/smooth-scroll */o=void 0!==n?n:"undefined"!=typeof window?window:this,void 0===(r=function(){return function(t){"use strict";var e="querySelector"in document&&"addEventListener"in t&&"requestAnimationFrame"in t&&"closest"in t.Element.prototype,n={ignore:"[data-scroll-ignore]",header:null,speed:500,offset:0,easing:"easeInOutCubic",customEasing:null,before:function(){},after:function(){}},r=function(){for(var t={},e=0,n=arguments.length;e<n;e++){var r=arguments[e];!function(e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])}(r)}return t},o=function(e){return parseInt(t.getComputedStyle(e).height,10)},i=function(t){"#"===t.charAt(0)&&(t=t.substr(1));for(var e,n=String(t),r=n.length,o=-1,i="",a=n.charCodeAt(0);++o<r;){if(0===(e=n.charCodeAt(o)))throw new InvalidCharacterError("Invalid character: the input contains U+0000.");i+=e>=1&&e<=31||127==e||0===o&&e>=48&&e<=57||1===o&&e>=48&&e<=57&&45===a?"\\"+e.toString(16)+" ":e>=128||45===e||95===e||e>=48&&e<=57||e>=65&&e<=90||e>=97&&e<=122?n.charAt(o):"\\"+n.charAt(o)}return"#"+i},a=function(t){return t?o(t)+t.offsetTop:0};return function(o,s){var l,c,u,d,f,h,p,g={cancelScroll:function(){cancelAnimationFrame(p)},animateScroll:function(e,o,i){var s=r(l||n,i||{}),c="[object Number]"===Object.prototype.toString.call(e),u=c||!e.tagName?null:e;if(c||u){var h=t.pageYOffset;s.header&&!d&&(d=document.querySelector(s.header)),f||(f=a(d));var p,m,y,v=c?e:function(t,e,n){var r=0;if(t.offsetParent)do{r+=t.offsetTop,t=t.offsetParent}while(t);return r=Math.max(r-e-n,0)}(u,f,parseInt("function"==typeof s.offset?s.offset():s.offset,10)),w=v-h,b=Math.max(document.body.scrollHeight,document.documentElement.scrollHeight,document.body.offsetHeight,document.documentElement.offsetHeight,document.body.clientHeight,document.documentElement.clientHeight),A=0,k=function(n,r){var i=t.pageYOffset;if(n==r||i==r||(h<r&&t.innerHeight+i)>=b)return g.cancelScroll(),function(e,n,r){r||(e.focus(),document.activeElement.id!==e.id&&(e.setAttribute("tabindex","-1"),e.focus(),e.style.outline="none"),t.scrollTo(0,n))}(e,r,c),s.after(e,o),p=null,!0},S=function(e){p||(p=e),m=(A+=e-p)/parseInt(s.speed,10),y=h+w*function(t,e){var n;return"easeInQuad"===t.easing&&(n=e*e),"easeOutQuad"===t.easing&&(n=e*(2-e)),"easeInOutQuad"===t.easing&&(n=e<.5?2*e*e:(4-2*e)*e-1),"easeInCubic"===t.easing&&(n=e*e*e),"easeOutCubic"===t.easing&&(n=--e*e*e+1),"easeInOutCubic"===t.easing&&(n=e<.5?4*e*e*e:(e-1)*(2*e-2)*(2*e-2)+1),"easeInQuart"===t.easing&&(n=e*e*e*e),"easeOutQuart"===t.easing&&(n=1- --e*e*e*e),"easeInOutQuart"===t.easing&&(n=e<.5?8*e*e*e*e:1-8*--e*e*e*e),"easeInQuint"===t.easing&&(n=e*e*e*e*e),"easeOutQuint"===t.easing&&(n=1+--e*e*e*e*e),"easeInOutQuint"===t.easing&&(n=e<.5?16*e*e*e*e*e:1+16*--e*e*e*e*e),t.customEasing&&(n=t.customEasing(e)),n||e}(s,m=m>1?1:m),t.scrollTo(0,Math.floor(y)),k(y,v)||(t.requestAnimationFrame(S),p=e)};0===t.pageYOffset&&t.scrollTo(0,0),s.before(e,o),g.cancelScroll(),t.requestAnimationFrame(S)}}},m=function(t){c&&(c.id=c.getAttribute("data-scroll-id"),g.animateScroll(c,u),c=null,u=null)},y=function(e){if(!("matchMedia"in t&&t.matchMedia("(prefers-reduced-motion)").matches)&&0===e.button&&!e.metaKey&&!e.ctrlKey&&(u=e.target.closest(o))&&"a"===u.tagName.toLowerCase()&&!e.target.closest(l.ignore)&&u.hostname===t.location.hostname&&u.pathname===t.location.pathname&&/#/.test(u.href)){var n;try{n=i(decodeURIComponent(u.hash))}catch(t){n=i(u.hash)}if("#"===n){e.preventDefault();var r=(c=document.body).id?c.id:"smooth-scroll-top";return c.setAttribute("data-scroll-id",r),c.id="",void(t.location.hash.substring(1)===r?m():t.location.hash=r)}(c=document.querySelector(n))&&(c.setAttribute("data-scroll-id",c.id),c.id="",u.hash===t.location.hash&&(e.preventDefault(),m()))}},v=function(t){h||(h=setTimeout(function(){h=null,f=a(d)},66))};return g.destroy=function(){l&&(document.removeEventListener("click",y,!1),t.removeEventListener("resize",v,!1),g.cancelScroll(),l=null,c=null,u=null,d=null,f=null,h=null,p=null)},g.init=function(o){e&&(g.destroy(),l=r(n,o||{}),d=l.header?document.querySelector(l.header):null,f=a(d),document.addEventListener("click",y,!1),t.addEventListener("hashchange",m,!1),d&&t.addEventListener("resize",v,!1))},g.init(s),g}}(o)}.apply(e,[]))||(t.exports=r)}).call(this,n(3))},225:function(t,e){
/**
@license Sticky-kit v1.1.3 | WTFPL | Leaf Corcoran 2015 | http://leafo.net
*/
(function(){var t,e;t=this.jQuery||window.jQuery,e=t(window),t.fn.stick_in_parent=function(n){var r,o,i,a,s,l,c,u,d,f,h,p,g;for(null==n&&(n={}),f=n.sticky_class,a=n.inner_scrolling,d=n.recalc_every,u=n.parent,l=n.offset_top,s=n.spacer,i=n.bottoming,null==l&&(l=0),null==u&&(u=void 0),null==a&&(a=!0),null==f&&(f="is_stuck"),r=t(document),null==i&&(i=!0),c=function(t){var e,n;return window.getComputedStyle?(t[0],e=window.getComputedStyle(t[0]),n=parseFloat(e.getPropertyValue("width"))+parseFloat(e.getPropertyValue("margin-left"))+parseFloat(e.getPropertyValue("margin-right")),"border-box"!==e.getPropertyValue("box-sizing")&&(n+=parseFloat(e.getPropertyValue("border-left-width"))+parseFloat(e.getPropertyValue("border-right-width"))+parseFloat(e.getPropertyValue("padding-left"))+parseFloat(e.getPropertyValue("padding-right"))),n):t.outerWidth(!0)},h=function(n,o,h,p,g,m,y,v){var w,b,A,k,S,x,O,_,E,T,C,L;if(!n.data("sticky_kit")){if(n.data("sticky_kit",!0),S=r.height(),O=n.parent(),null!=u&&(O=O.closest(u)),!O.length)throw"failed to find stick parent";if(A=!1,w=!1,(C=null!=s?s&&n.closest(s):t("<div />"))&&C.css("position",n.css("position")),(_=function(){var t,e,i;if(!v)return S=r.height(),t=parseInt(O.css("border-top-width"),10),e=parseInt(O.css("padding-top"),10),o=parseInt(O.css("padding-bottom"),10),h=O.offset().top+t+e,p=O.height(),A&&(A=!1,w=!1,null==s&&(n.insertAfter(C),C.detach()),n.css({position:"",top:"",width:"",bottom:""}).removeClass(f),i=!0),g=n.offset().top-(parseInt(n.css("margin-top"),10)||0)-l,m=n.outerHeight(!0),y=n.css("float"),C&&C.css({width:c(n),height:m,display:n.css("display"),"vertical-align":n.css("vertical-align"),float:y}),i?L():void 0})(),m!==p)return k=void 0,x=l,T=d,L=function(){var t,c,u,b,E,L;if(!v)return u=!1,null!=T&&(T-=1)<=0&&(T=d,_(),u=!0),u||r.height()===S||(_(),u=!0),b=e.scrollTop(),null!=k&&(c=b-k),k=b,A?(i&&(E=b+m+x>p+h,w&&!E&&(w=!1,n.css({position:"fixed",bottom:"",top:x}).trigger("sticky_kit:unbottom"))),b<g&&(A=!1,x=l,null==s&&("left"!==y&&"right"!==y||n.insertAfter(C),C.detach()),t={position:"",width:"",top:""},n.css(t).removeClass(f).trigger("sticky_kit:unstick")),a&&(L=e.height(),m+l>L&&(w||(x-=c,x=Math.max(L-m,x),x=Math.min(l,x),A&&n.css({top:x+"px"}))))):b>g&&(A=!0,(t={position:"fixed",top:x}).width="border-box"===n.css("box-sizing")?n.outerWidth()+"px":n.width()+"px",n.css(t).addClass(f),null==s&&(n.after(C),"left"!==y&&"right"!==y||C.append(n)),n.trigger("sticky_kit:stick")),A&&i&&(null==E&&(E=b+m+x>p+h),!w&&E)?(w=!0,"static"===O.css("position")&&O.css({position:"relative"}),n.css({position:"absolute",bottom:o,top:"auto"}).trigger("sticky_kit:bottom")):void 0},E=function(){return _(),L()},b=function(){if(v=!0,e.off("touchmove",L),e.off("scroll",L),e.off("resize",E),t(document.body).off("sticky_kit:recalc",E),n.off("sticky_kit:detach",b),n.removeData("sticky_kit"),n.css({position:"",bottom:"",top:"",width:""}),O.position("position",""),A)return null==s&&("left"!==y&&"right"!==y||n.insertAfter(C),C.remove()),n.removeClass(f)},e.on("touchmove",L),e.on("scroll",L),e.on("resize",E),t(document.body).on("sticky_kit:recalc",E),n.on("sticky_kit:detach",b),setTimeout(L,0)}},p=0,g=this.length;p<g;p++)o=this[p],h(t(o));return this}}).call(this)},227:function(t,e){
/*!
Waypoints - 4.0.1
Copyright © 2011-2016 Caleb Troughton
Licensed under the MIT license.
https://github.com/imakewebthings/waypoints/blob/master/licenses.txt
*/
!function(){"use strict";var t=0,e={};function n(r){if(!r)throw new Error("No options passed to Waypoint constructor");if(!r.element)throw new Error("No element option passed to Waypoint constructor");if(!r.handler)throw new Error("No handler option passed to Waypoint constructor");this.key="waypoint-"+t,this.options=n.Adapter.extend({},n.defaults,r),this.element=this.options.element,this.adapter=new n.Adapter(this.element),this.callback=r.handler,this.axis=this.options.horizontal?"horizontal":"vertical",this.enabled=this.options.enabled,this.triggerPoint=null,this.group=n.Group.findOrCreate({name:this.options.group,axis:this.axis}),this.context=n.Context.findOrCreateByElement(this.options.context),n.offsetAliases[this.options.offset]&&(this.options.offset=n.offsetAliases[this.options.offset]),this.group.add(this),this.context.add(this),e[this.key]=this,t+=1}n.prototype.queueTrigger=function(t){this.group.queueTrigger(this,t)},n.prototype.trigger=function(t){this.enabled&&this.callback&&this.callback.apply(this,t)},n.prototype.destroy=function(){this.context.remove(this),this.group.remove(this),delete e[this.key]},n.prototype.disable=function(){return this.enabled=!1,this},n.prototype.enable=function(){return this.context.refresh(),this.enabled=!0,this},n.prototype.next=function(){return this.group.next(this)},n.prototype.previous=function(){return this.group.previous(this)},n.invokeAll=function(t){var n=[];for(var r in e)n.push(e[r]);for(var o=0,i=n.length;o<i;o++)n[o][t]()},n.destroyAll=function(){n.invokeAll("destroy")},n.disableAll=function(){n.invokeAll("disable")},n.enableAll=function(){for(var t in n.Context.refreshAll(),e)e[t].enabled=!0;return this},n.refreshAll=function(){n.Context.refreshAll()},n.viewportHeight=function(){return window.innerHeight||document.documentElement.clientHeight},n.viewportWidth=function(){return document.documentElement.clientWidth},n.adapters=[],n.defaults={context:window,continuous:!0,enabled:!0,group:"default",horizontal:!1,offset:0},n.offsetAliases={"bottom-in-view":function(){return this.context.innerHeight()-this.adapter.outerHeight()},"right-in-view":function(){return this.context.innerWidth()-this.adapter.outerWidth()}},window.Waypoint=n}(),function(){"use strict";function t(t){window.setTimeout(t,1e3/60)}var e=0,n={},r=window.Waypoint,o=window.onload;function i(t){this.element=t,this.Adapter=r.Adapter,this.adapter=new this.Adapter(t),this.key="waypoint-context-"+e,this.didScroll=!1,this.didResize=!1,this.oldScroll={x:this.adapter.scrollLeft(),y:this.adapter.scrollTop()},this.waypoints={vertical:{},horizontal:{}},t.waypointContextKey=this.key,n[t.waypointContextKey]=this,e+=1,r.windowContext||(r.windowContext=!0,r.windowContext=new i(window)),this.createThrottledScrollHandler(),this.createThrottledResizeHandler()}i.prototype.add=function(t){var e=t.options.horizontal?"horizontal":"vertical";this.waypoints[e][t.key]=t,this.refresh()},i.prototype.checkEmpty=function(){var t=this.Adapter.isEmptyObject(this.waypoints.horizontal),e=this.Adapter.isEmptyObject(this.waypoints.vertical),r=this.element==this.element.window;t&&e&&!r&&(this.adapter.off(".waypoints"),delete n[this.key])},i.prototype.createThrottledResizeHandler=function(){var t=this;function e(){t.handleResize(),t.didResize=!1}this.adapter.on("resize.waypoints",function(){t.didResize||(t.didResize=!0,r.requestAnimationFrame(e))})},i.prototype.createThrottledScrollHandler=function(){var t=this;function e(){t.handleScroll(),t.didScroll=!1}this.adapter.on("scroll.waypoints",function(){t.didScroll&&!r.isTouch||(t.didScroll=!0,r.requestAnimationFrame(e))})},i.prototype.handleResize=function(){r.Context.refreshAll()},i.prototype.handleScroll=function(){var t={},e={horizontal:{newScroll:this.adapter.scrollLeft(),oldScroll:this.oldScroll.x,forward:"right",backward:"left"},vertical:{newScroll:this.adapter.scrollTop(),oldScroll:this.oldScroll.y,forward:"down",backward:"up"}};for(var n in e){var r=e[n],o=r.newScroll>r.oldScroll?r.forward:r.backward;for(var i in this.waypoints[n]){var a=this.waypoints[n][i];if(null!==a.triggerPoint){var s=r.oldScroll<a.triggerPoint,l=r.newScroll>=a.triggerPoint;(s&&l||!s&&!l)&&(a.queueTrigger(o),t[a.group.id]=a.group)}}}for(var c in t)t[c].flushTriggers();this.oldScroll={x:e.horizontal.newScroll,y:e.vertical.newScroll}},i.prototype.innerHeight=function(){return this.element==this.element.window?r.viewportHeight():this.adapter.innerHeight()},i.prototype.remove=function(t){delete this.waypoints[t.axis][t.key],this.checkEmpty()},i.prototype.innerWidth=function(){return this.element==this.element.window?r.viewportWidth():this.adapter.innerWidth()},i.prototype.destroy=function(){var t=[];for(var e in this.waypoints)for(var n in this.waypoints[e])t.push(this.waypoints[e][n]);for(var r=0,o=t.length;r<o;r++)t[r].destroy()},i.prototype.refresh=function(){var t,e=this.element==this.element.window,n=e?void 0:this.adapter.offset(),o={};for(var i in this.handleScroll(),t={horizontal:{contextOffset:e?0:n.left,contextScroll:e?0:this.oldScroll.x,contextDimension:this.innerWidth(),oldScroll:this.oldScroll.x,forward:"right",backward:"left",offsetProp:"left"},vertical:{contextOffset:e?0:n.top,contextScroll:e?0:this.oldScroll.y,contextDimension:this.innerHeight(),oldScroll:this.oldScroll.y,forward:"down",backward:"up",offsetProp:"top"}}){var a=t[i];for(var s in this.waypoints[i]){var l,c,u,d,f=this.waypoints[i][s],h=f.options.offset,p=f.triggerPoint,g=0,m=null==p;f.element!==f.element.window&&(g=f.adapter.offset()[a.offsetProp]),"function"==typeof h?h=h.apply(f):"string"==typeof h&&(h=parseFloat(h),f.options.offset.indexOf("%")>-1&&(h=Math.ceil(a.contextDimension*h/100))),l=a.contextScroll-a.contextOffset,f.triggerPoint=Math.floor(g+l-h),c=p<a.oldScroll,u=f.triggerPoint>=a.oldScroll,d=!c&&!u,!m&&(c&&u)?(f.queueTrigger(a.backward),o[f.group.id]=f.group):!m&&d?(f.queueTrigger(a.forward),o[f.group.id]=f.group):m&&a.oldScroll>=f.triggerPoint&&(f.queueTrigger(a.forward),o[f.group.id]=f.group)}}return r.requestAnimationFrame(function(){for(var t in o)o[t].flushTriggers()}),this},i.findOrCreateByElement=function(t){return i.findByElement(t)||new i(t)},i.refreshAll=function(){for(var t in n)n[t].refresh()},i.findByElement=function(t){return n[t.waypointContextKey]},window.onload=function(){o&&o(),i.refreshAll()},r.requestAnimationFrame=function(e){(window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||t).call(window,e)},r.Context=i}(),function(){"use strict";function t(t,e){return t.triggerPoint-e.triggerPoint}function e(t,e){return e.triggerPoint-t.triggerPoint}var n={vertical:{},horizontal:{}},r=window.Waypoint;function o(t){this.name=t.name,this.axis=t.axis,this.id=this.name+"-"+this.axis,this.waypoints=[],this.clearTriggerQueues(),n[this.axis][this.name]=this}o.prototype.add=function(t){this.waypoints.push(t)},o.prototype.clearTriggerQueues=function(){this.triggerQueues={up:[],down:[],left:[],right:[]}},o.prototype.flushTriggers=function(){for(var n in this.triggerQueues){var r=this.triggerQueues[n],o="up"===n||"left"===n;r.sort(o?e:t);for(var i=0,a=r.length;i<a;i+=1){var s=r[i];(s.options.continuous||i===r.length-1)&&s.trigger([n])}}this.clearTriggerQueues()},o.prototype.next=function(e){this.waypoints.sort(t);var n=r.Adapter.inArray(e,this.waypoints);return n===this.waypoints.length-1?null:this.waypoints[n+1]},o.prototype.previous=function(e){this.waypoints.sort(t);var n=r.Adapter.inArray(e,this.waypoints);return n?this.waypoints[n-1]:null},o.prototype.queueTrigger=function(t,e){this.triggerQueues[e].push(t)},o.prototype.remove=function(t){var e=r.Adapter.inArray(t,this.waypoints);e>-1&&this.waypoints.splice(e,1)},o.prototype.first=function(){return this.waypoints[0]},o.prototype.last=function(){return this.waypoints[this.waypoints.length-1]},o.findOrCreate=function(t){return n[t.axis][t.name]||new o(t)},r.Group=o}(),function(){"use strict";var t=window.Waypoint;function e(t){return t===t.window}function n(t){return e(t)?t:t.defaultView}function r(t){this.element=t,this.handlers={}}r.prototype.innerHeight=function(){return e(this.element)?this.element.innerHeight:this.element.clientHeight},r.prototype.innerWidth=function(){return e(this.element)?this.element.innerWidth:this.element.clientWidth},r.prototype.off=function(t,e){function n(t,e,n){for(var r=0,o=e.length-1;r<o;r++){var i=e[r];n&&n!==i||t.removeEventListener(i)}}var r=t.split("."),o=r[0],i=r[1],a=this.element;if(i&&this.handlers[i]&&o)n(a,this.handlers[i][o],e),this.handlers[i][o]=[];else if(o)for(var s in this.handlers)n(a,this.handlers[s][o]||[],e),this.handlers[s][o]=[];else if(i&&this.handlers[i]){for(var l in this.handlers[i])n(a,this.handlers[i][l],e);this.handlers[i]={}}},r.prototype.offset=function(){if(!this.element.ownerDocument)return null;var t=this.element.ownerDocument.documentElement,e=n(this.element.ownerDocument),r={top:0,left:0};return this.element.getBoundingClientRect&&(r=this.element.getBoundingClientRect()),{top:r.top+e.pageYOffset-t.clientTop,left:r.left+e.pageXOffset-t.clientLeft}},r.prototype.on=function(t,e){var n=t.split("."),r=n[0],o=n[1]||"__default",i=this.handlers[o]=this.handlers[o]||{};(i[r]=i[r]||[]).push(e),this.element.addEventListener(r,e)},r.prototype.outerHeight=function(t){var n,r=this.innerHeight();return t&&!e(this.element)&&(n=window.getComputedStyle(this.element),r+=parseInt(n.marginTop,10),r+=parseInt(n.marginBottom,10)),r},r.prototype.outerWidth=function(t){var n,r=this.innerWidth();return t&&!e(this.element)&&(n=window.getComputedStyle(this.element),r+=parseInt(n.marginLeft,10),r+=parseInt(n.marginRight,10)),r},r.prototype.scrollLeft=function(){var t=n(this.element);return t?t.pageXOffset:this.element.scrollLeft},r.prototype.scrollTop=function(){var t=n(this.element);return t?t.pageYOffset:this.element.scrollTop},r.extend=function(){var t=Array.prototype.slice.call(arguments);function e(t,e){if("object"==typeof t&&"object"==typeof e)for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}for(var n=1,r=t.length;n<r;n++)e(t[0],t[n]);return t[0]},r.inArray=function(t,e,n){return null==e?-1:e.indexOf(t,n)},r.isEmptyObject=function(t){for(var e in t)return!1;return!0},t.adapters.push({name:"noframework",Adapter:r}),t.Adapter=r}()},3:function(t,e){var n;n=function(){return this}();try{n=n||new Function("return this")()}catch(t){"object"==typeof window&&(n=window)}t.exports=n},347:function(t,e,n){var r;!function(o){var i,a;function s(t){return i?i[t]:(i=n(!function(){var t=new Error("Cannot find module 'unicode/category/So'");throw t.code="MODULE_NOT_FOUND",t}()),a=["sign","cross","of","symbol","staff","hand","black","white"].map(function(t){return new RegExp(t,"gi")}),i[t])}function l(t,e){t=t.toString(),"string"==typeof e&&(e={replacement:e}),(e=e||{}).mode=e.mode||l.defaults.mode;for(var n=l.defaults.modes[e.mode],r=["replacement","multicharmap","charmap","remove","lower"],o=0,i=r.length;o<i;o++)e[u=r[o]]=u in e?e[u]:n[u];void 0===e.symbols&&(e.symbols=n.symbols);var c=[];for(var u in e.multicharmap)if(e.multicharmap.hasOwnProperty(u)){var d=u.length;-1===c.indexOf(d)&&c.push(d)}var f,h,p,g="";for(o=0,i=t.length;o<i;o++){if(p=t[o],!c.some(function(n){var r=t.substr(o,n);return!!e.multicharmap[r]&&(o+=n-1,p=e.multicharmap[r],!0)})&&(f=e.charmap[p]?(p=e.charmap[p]).charCodeAt(0):t.charCodeAt(o),e.symbols&&(h=s(f)))){p=h.name.toLowerCase();for(var m=0,y=a.length;m<y;m++)p=p.replace(a[m],"");p=p.trim()}p=p.replace(/[^\w\s\-\.\_~]/g,""),e.remove&&(p=p.replace(e.remove,"")),g+=p}return g=(g=(g=g.trim()).replace(/[-\s]+/g,e.replacement)).replace(e.replacement+"$",""),e.lower&&(g=g.toLowerCase()),g}for(var c in l.defaults={mode:"pretty"},l.multicharmap=l.defaults.multicharmap={"<3":"love","&&":"and","||":"or","w/":"with"},l.charmap=l.defaults.charmap={"À":"A","Á":"A","Â":"A","Ã":"A","Ä":"A","Å":"A","Æ":"AE","Ç":"C","È":"E","É":"E","Ê":"E","Ë":"E","Ì":"I","Í":"I","Î":"I","Ï":"I","Ð":"D","Ñ":"N","Ò":"O","Ó":"O","Ô":"O","Õ":"O","Ö":"O","Ő":"O","Ø":"O","Ù":"U","Ú":"U","Û":"U","Ü":"U","Ű":"U","Ý":"Y","Þ":"TH","ß":"ss","à":"a","á":"a","â":"a","ã":"a","ä":"a","å":"a","æ":"ae","ç":"c","è":"e","é":"e","ê":"e","ë":"e","ì":"i","í":"i","î":"i","ï":"i","ð":"d","ñ":"n","ò":"o","ó":"o","ô":"o","õ":"o","ö":"o","ő":"o","ø":"o","ù":"u","ú":"u","û":"u","ü":"u","ű":"u","ý":"y","þ":"th","ÿ":"y","ẞ":"SS","α":"a","β":"b","γ":"g","δ":"d","ε":"e","ζ":"z","η":"h","θ":"8","ι":"i","κ":"k","λ":"l","μ":"m","ν":"n","ξ":"3","ο":"o","π":"p","ρ":"r","σ":"s","τ":"t","υ":"y","φ":"f","χ":"x","ψ":"ps","ω":"w","ά":"a","έ":"e","ί":"i","ό":"o","ύ":"y","ή":"h","ώ":"w","ς":"s","ϊ":"i","ΰ":"y","ϋ":"y","ΐ":"i","Α":"A","Β":"B","Γ":"G","Δ":"D","Ε":"E","Ζ":"Z","Η":"H","Θ":"8","Ι":"I","Κ":"K","Λ":"L","Μ":"M","Ν":"N","Ξ":"3","Ο":"O","Π":"P","Ρ":"R","Σ":"S","Τ":"T","Υ":"Y","Φ":"F","Χ":"X","Ψ":"PS","Ω":"W","Ά":"A","Έ":"E","Ί":"I","Ό":"O","Ύ":"Y","Ή":"H","Ώ":"W","Ϊ":"I","Ϋ":"Y","ş":"s","Ş":"S","ı":"i","İ":"I","ğ":"g","Ğ":"G","а":"a","б":"b","в":"v","г":"g","д":"d","е":"e","ё":"yo","ж":"zh","з":"z","и":"i","й":"j","к":"k","л":"l","м":"m","н":"n","о":"o","п":"p","р":"r","с":"s","т":"t","у":"u","ф":"f","х":"h","ц":"c","ч":"ch","ш":"sh","щ":"sh","ъ":"u","ы":"y","ь":"","э":"e","ю":"yu","я":"ya","А":"A","Б":"B","В":"V","Г":"G","Д":"D","Е":"E","Ё":"Yo","Ж":"Zh","З":"Z","И":"I","Й":"J","К":"K","Л":"L","М":"M","Н":"N","О":"O","П":"P","Р":"R","С":"S","Т":"T","У":"U","Ф":"F","Х":"H","Ц":"C","Ч":"Ch","Ш":"Sh","Щ":"Sh","Ъ":"U","Ы":"Y","Ь":"","Э":"E","Ю":"Yu","Я":"Ya","Є":"Ye","І":"I","Ї":"Yi","Ґ":"G","є":"ye","і":"i","ї":"yi","ґ":"g","č":"c","ď":"d","ě":"e","ň":"n","ř":"r","š":"s","ť":"t","ů":"u","ž":"z","Č":"C","Ď":"D","Ě":"E","Ň":"N","Ř":"R","Š":"S","Ť":"T","Ů":"U","Ž":"Z","ą":"a","ć":"c","ę":"e","ł":"l","ń":"n","ś":"s","ź":"z","ż":"z","Ą":"A","Ć":"C","Ę":"E","Ł":"L","Ń":"N","Ś":"S","Ź":"Z","Ż":"Z","ā":"a","ē":"e","ģ":"g","ī":"i","ķ":"k","ļ":"l","ņ":"n","ū":"u","Ā":"A","Ē":"E","Ģ":"G","Ī":"I","Ķ":"K","Ļ":"L","Ņ":"N","Ū":"U","ė":"e","į":"i","ų":"u","Ė":"E","Į":"I","Ų":"U","ț":"t","Ț":"T","ţ":"t","Ţ":"T","ș":"s","Ș":"S","ă":"a","Ă":"A","Ạ":"A","Ả":"A","Ầ":"A","Ấ":"A","Ậ":"A","Ẩ":"A","Ẫ":"A","Ằ":"A","Ắ":"A","Ặ":"A","Ẳ":"A","Ẵ":"A","Ẹ":"E","Ẻ":"E","Ẽ":"E","Ề":"E","Ế":"E","Ệ":"E","Ể":"E","Ễ":"E","Ị":"I","Ỉ":"I","Ĩ":"I","Ọ":"O","Ỏ":"O","Ồ":"O","Ố":"O","Ộ":"O","Ổ":"O","Ỗ":"O","Ơ":"O","Ờ":"O","Ớ":"O","Ợ":"O","Ở":"O","Ỡ":"O","Ụ":"U","Ủ":"U","Ũ":"U","Ư":"U","Ừ":"U","Ứ":"U","Ự":"U","Ử":"U","Ữ":"U","Ỳ":"Y","Ỵ":"Y","Ỷ":"Y","Ỹ":"Y","Đ":"D","ạ":"a","ả":"a","ầ":"a","ấ":"a","ậ":"a","ẩ":"a","ẫ":"a","ằ":"a","ắ":"a","ặ":"a","ẳ":"a","ẵ":"a","ẹ":"e","ẻ":"e","ẽ":"e","ề":"e","ế":"e","ệ":"e","ể":"e","ễ":"e","ị":"i","ỉ":"i","ĩ":"i","ọ":"o","ỏ":"o","ồ":"o","ố":"o","ộ":"o","ổ":"o","ỗ":"o","ơ":"o","ờ":"o","ớ":"o","ợ":"o","ở":"o","ỡ":"o","ụ":"u","ủ":"u","ũ":"u","ư":"u","ừ":"u","ứ":"u","ự":"u","ử":"u","ữ":"u","ỳ":"y","ỵ":"y","ỷ":"y","ỹ":"y","đ":"d","€":"euro","₢":"cruzeiro","₣":"french franc","£":"pound","₤":"lira","₥":"mill","₦":"naira","₧":"peseta","₨":"rupee","₩":"won","₪":"new shequel","₫":"dong","₭":"kip","₮":"tugrik","₯":"drachma","₰":"penny","₱":"peso","₲":"guarani","₳":"austral","₴":"hryvnia","₵":"cedi","¢":"cent","¥":"yen","元":"yuan","円":"yen","﷼":"rial","₠":"ecu","¤":"currency","฿":"baht",$:"dollar","₹":"indian rupee","©":"(c)","œ":"oe","Œ":"OE","∑":"sum","®":"(r)","†":"+","“":'"',"”":'"',"‘":"'","’":"'","∂":"d","ƒ":"f","™":"tm","℠":"sm","…":"...","˚":"o","º":"o","ª":"a","•":"*","∆":"delta","∞":"infinity","♥":"love","&":"and","|":"or","<":"less",">":"greater"},l.defaults.modes={rfc3986:{replacement:"-",symbols:!0,remove:null,lower:!0,charmap:l.defaults.charmap,multicharmap:l.defaults.multicharmap},pretty:{replacement:"-",symbols:!0,remove:/[.]/g,lower:!1,charmap:l.defaults.charmap,multicharmap:l.defaults.multicharmap}},l.defaults.modes)l.defaults.modes.hasOwnProperty(c)&&(l.defaults.modes[c].symbols=!1);void 0===(r=function(){return l}.apply(e,[]))||(t.exports=r)}()},440:function(t,e,n){n(441),t.exports=n(443)},441:function(t,e,n){"use strict";var r=a(n(100)),o=a(n(442)),i=a(n(347));function a(t){return t&&t.__esModule?t:{default:t}}n(225),n(227);document.body.classList.contains("single-post-guide")&&new function t(e){var n=this;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this.supportedTags=["h1","h2","h3","h4","h5"],this.startTag=e.startTag,this.endTag=null;var a=this.supportedTags.indexOf(e.startTag);-1!==a&&(this.endTag=this.supportedTags[a+1]);var s=document.querySelector(e.contentWrapper).querySelectorAll(":not(.ck-fast-facts) > "+this.startTag+", :not(.ck-fast-facts) > "+this.endTag),l=s.length,c=0;for(c=0;c<l;c++)s[c].getAttribute("id")||s[c].setAttribute("id","ck__unique--"+(0,i.default)(s[c].textContent).toLowerCase());var u='\n\t\t\t<div class="ck-sidebar__toc-inner" data-gumshoe-header>\n\t\t\t\t<div class="ck-sidebar__toc-toggle">\n\t\t\t\t\t<a href="#">\n\t\t\t\t\t\t<span class="screen-reader">Toggle Menu</span>\n\t\t\t\t\t</a>\n\t\t\t\t</div>\n\t\t\t\t<ul data-gumshoe>\n\t\t\t\t\t'+[].concat(function(t){if(Array.isArray(t)){for(var e=0,n=Array(t.length);e<t.length;e++)n[e]=t[e];return n}return Array.from(t)}(s)).map(function(t){return'\n\t\t\t\t\t\t<li class="'+(t.tagName.toLowerCase()===n.startTag?"ck-sidebar__toc-parent":"ck-sidebar__toc-child")+'">\n\t\t\t\t\t\t\t<a data-scroll href="#'+t.getAttribute("id")+'">\n\t\t\t\t\t\t\t\t'+t.textContent+"\n\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t</li>\n\t\t\t\t\t\t"}).join("")+"\n\t\t\t\t</ul>\n\t\t\t</div>\n\t\t",d=document.createElement("aside");d.setAttribute("class","ck-sidebar__toc--sticky-wrapper");var f=document.createElement("div");f.setAttribute("class","ck-sidebar__toc"),f.innerHTML=u,d.appendChild(f),document.querySelectorAll(e.appendAfter)[0].parentNode.insertBefore(d,document.querySelectorAll(e.appendAfter)[0].nextSibling);var h=jQuery(".ck-guide__content--main"),p=jQuery(".ck-guide__learn-more"),g=p.nextAll();h.wrapInner('<div class="ck-guide__content--main-inner"></div>'),h.append(p).append(g),jQuery(".ck-sidebar__toc--sticky-wrapper").stick_in_parent({parent:".ck-guide__content--main-inner"});var m=document.querySelector(".ck-sidebar__toc--sticky-wrapper");new r.default(".ck-sidebar__toc-inner ul a",{before:function(){"wide"!==window.getComputedStyle(document.querySelector("body"),":before").getPropertyValue("content").replace(/"/g,"")&&m.classList.toggle("is-open")}}),o.default.init({offset:-300}),document.querySelector(".ck-sidebar__toc-toggle").addEventListener("click",function(t){t.preventDefault(),m.classList.toggle("is-open")}),new Waypoint({element:document.querySelector(e.visibleAfter),handler:function(){m.classList.toggle("is-visible")},offset:20}),new Waypoint({element:document.querySelector(e.hiddenAfter),handler:function(){m.classList.toggle("is-visible")},offset:20})}({startTag:"h2",contentWrapper:".entry-content",appendAfter:"h2",visibleAfter:".ck-anchor__links",hiddenAfter:".ck-guide__learn-more"})},442:function(t,e,n){(function(n){var r,o,i,a;/*! gumshoejs v3.5.0 | (c) 2017 Chris Ferdinandi | MIT License | http://github.com/cferdinandi/gumshoe */a=void 0!==n?n:this.window||this.global,o=[],r=function(t){"use strict";var e,n,r,o,i,a,s={},l="querySelector"in document&&"addEventListener"in t&&"classList"in document.createElement("_"),c=[],u={selector:"[data-gumshoe] a",selectorHeader:"[data-gumshoe-header]",container:t,offset:0,activeClass:"active",scrollDelay:!1,callback:function(){}},d=function(t,e,n){if("[object Object]"===Object.prototype.toString.call(t))for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&e.call(n,t[r],r,t);else for(var o=0,i=t.length;o<i;o++)e.call(n,t[o],o,t)},f=function(){var t={},e=!1,n=0,r=arguments.length;for("[object Boolean]"===Object.prototype.toString.call(arguments[0])&&(e=arguments[0],n++);n<r;n++){var o=arguments[n];!function(n){for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e&&"[object Object]"===Object.prototype.toString.call(n[r])?t[r]=f(!0,t[r],n[r]):t[r]=n[r])}(o)}return t},h=function(t){var n=0;if(t.offsetParent)do{n+=t.offsetTop,t=t.offsetParent}while(t);else n=t.offsetTop;return(n=n-i-e.offset)>=0?n:0};s.setDistances=function(){r=Math.max(document.body.scrollHeight,document.documentElement.scrollHeight,document.body.offsetHeight,document.documentElement.offsetHeight,document.body.clientHeight,document.documentElement.clientHeight),i=o?function(t){return Math.max(t.scrollHeight,t.offsetHeight,t.clientHeight)}(o)+h(o):0,d(c,function(t){t.distance=h(t.target)}),c.sort(function(t,e){return t.distance>e.distance?-1:t.distance<e.distance?1:0})};var p=function(){a&&(a.nav.classList.remove(e.activeClass),a.parent&&a.parent.classList.remove(e.activeClass))},g=function(t){p(),t.nav.classList.add(e.activeClass),t.parent&&t.parent.classList.add(e.activeClass),e.callback(t),a={nav:t.nav,parent:t.parent}};s.getCurrentNav=function(){var n=t.pageYOffset;if(t.innerHeight+n>=r&&function(e){var n=e.getBoundingClientRect();return n.top>=0&&n.left>=0&&n.bottom<=(t.innerHeight||document.documentElement.clientHeight)&&n.right<=(t.innerWidth||document.documentElement.clientWidth)}(c[0].target))return g(c[0]),c[0];for(var o=0,i=c.length;o<i;o++){var a=c[o];if(a.distance<=n)return g(a),a}p(),e.callback()},s.destroy=function(){e&&(e.container.removeEventListener("resize",y,!1),e.container.removeEventListener("scroll",y,!1),c=[],e=null,n=null,r=null,o=null,i=null,a=null)};var m=function(t){window.clearTimeout(n),n=setTimeout(function(){s.setDistances(),s.getCurrentNav()},66)},y=function(t){n||(n=setTimeout(function(){n=null,"scroll"===t.type&&s.getCurrentNav(),"resize"===t.type&&(s.setDistances(),s.getCurrentNav())},66))};return s.init=function(t){l&&(s.destroy(),e=f(u,t||{}),o=document.querySelector(e.selectorHeader),function(){var t=document.querySelectorAll(e.selector);d(t,function(t){if(t.hash){var e=document.querySelector(t.hash);e&&c.push({nav:t,target:e,parent:"li"===t.parentNode.tagName.toLowerCase()?t.parentNode:null,distance:0})}})}(),0!==c.length&&(d(c,function(t){t.nav.classList.contains(e.activeClass)&&(a={nav:t.nav,parent:t.parent})}),s.setDistances(),s.getCurrentNav(),e.container.addEventListener("resize",y,!1),e.scrollDelay?e.container.addEventListener("scroll",m,!1):e.container.addEventListener("scroll",y,!1)))},s}(a),void 0===(i="function"==typeof r?r.apply(e,o):r)||(t.exports=i)}).call(this,n(3))},443:function(t,e,n){"use strict";var r=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),o=a(n(347)),i=a(n(100));function a(t){return t&&t.__esModule?t:{default:t}}var s=function(){function t(e){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this.startTag=e.startTag;var n=document.querySelectorAll(this.startTag+" a"),r=n.length,a=0,s=null,l=null,c=null;for(a=0;a<r;a++)(l=jQuery("h2:contains("+n[a].innerHTML+"), h3:contains("+n[a].innerHTML+"), h4:contains("+n[a].innerHTML+")")[0])&&((c=l.getAttribute("id"))?n[a].setAttribute("href","#"+c):(s="ck__unique--"+(0,o.default)(n[a].textContent).toLowerCase(),l.setAttribute("id",s),n[a].setAttribute("href","#"+s)));new i.default(".ck-anchor__links a")}return r(t,[{key:"addListeners",value:function(){var t=null;document.querySelector(".ck-anchor__links").addEventListener("click",function(e){"a"===e.target.tagName.toLowerCase()&&(e.preventDefault(),(t=e.target.getAttribute("href"))&&jQuery("html, body").animate({scrollTop:jQuery(t).offset().top},500))})}}]),t}();document.body.classList.contains("single-post-guide")&&new s({startTag:".ck-anchor_links--item"})}});
//# sourceMappingURL=guide-widgets.min.js.map;
!function(a,b){"use strict";function c(){if(!e){e=!0;var a,c,d,f,g=-1!==navigator.appVersion.indexOf("MSIE 10"),h=!!navigator.userAgent.match(/Trident.*rv:11\./),i=b.querySelectorAll("iframe.wp-embedded-content");for(c=0;c<i.length;c++){if(d=i[c],!d.getAttribute("data-secret"))f=Math.random().toString(36).substr(2,10),d.src+="#?secret="+f,d.setAttribute("data-secret",f);if(g||h)a=d.cloneNode(!0),a.removeAttribute("security"),d.parentNode.replaceChild(a,d)}}}var d=!1,e=!1;if(b.querySelector)if(a.addEventListener)d=!0;if(a.wp=a.wp||{},!a.wp.receiveEmbedMessage)if(a.wp.receiveEmbedMessage=function(c){var d=c.data;if(d)if(d.secret||d.message||d.value)if(!/[^a-zA-Z0-9]/.test(d.secret)){var e,f,g,h,i,j=b.querySelectorAll('iframe[data-secret="'+d.secret+'"]'),k=b.querySelectorAll('blockquote[data-secret="'+d.secret+'"]');for(e=0;e<k.length;e++)k[e].style.display="none";for(e=0;e<j.length;e++)if(f=j[e],c.source===f.contentWindow){if(f.removeAttribute("style"),"height"===d.message){if(g=parseInt(d.value,10),g>1e3)g=1e3;else if(~~g<200)g=200;f.height=g}if("link"===d.message)if(h=b.createElement("a"),i=b.createElement("a"),h.href=f.getAttribute("src"),i.href=d.value,i.host===h.host)if(b.activeElement===f)a.top.location.href=d.value}else;}},d)a.addEventListener("message",a.wp.receiveEmbedMessage,!1),b.addEventListener("DOMContentLoaded",c,!1),a.addEventListener("load",c,!1)}(window,document);;
